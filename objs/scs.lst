C166 COMPILER V7.57.0, SCS                                                                 12/14/2020 10:56:36 PAGE 1   


C166 COMPILER V7.57.0, COMPILATION OF MODULE SCS
OBJECT MODULE PLACED IN .\objs\scs.obj
COMPILER INVOKED BY: C:\Keil_v5\C166\BIN\C166.EXE Hw_Driver\scs.c MODV2 LARGE BROWSE INCDIR(.\src\hardware;.\src;.\EOL_D
                    -iag;.\DTC_Diag;.\Hw_Driver;.\CalTool;.\DTC_Diag\mcu2_prot;./CAN_Driver;.\xcp;.\src\include;.\EBS_Ctrl_Logic) MODV2 DEBUG
                    - CODE PRINT(.\objs\scs.lst) TABS(2) OBJECT(.\objs\scs.obj) 

 stmt lvl     source

    1         //****************************************************************************
    2         // @Module        Project Settings
    3         // @Filename      SCS.C
    4         // @Project       xc2kTest.dav
    5         //----------------------------------------------------------------------------
    6         // @Controller    Infineon XC2365A-104F80
    7         //
    8         // @Compiler      Keil
    9         //
   10         // @Codegenerator 2.0
   11         //
   12         // @Description   This file contains the SCS driver.
   13         //                      
   14         //                Note:
   15         //                This file should not be changed by 
   16         //                the user.
   17         //
   18         //----------------------------------------------------------------------------
   19         // @Date          2010-4-18 21:53:02
   20         //
   21         //****************************************************************************
   22         
   23         // USER CODE BEGIN (SCS_General,1)
   24         
   25         // USER CODE END
   26         
   27         
   28         
   29         //****************************************************************************
   30         // @Project Includes
   31         //****************************************************************************
   32         
   33         #include "scs.h"
   34         #include  "xc2365a.h"
   35         // USER CODE BEGIN (SCS_General,2)
   36         // USER CODE END
   37         
   38         
   39         //****************************************************************************
   40         // @Macros
   41         //****************************************************************************
   42         
   43         
   44         //****************************************************************************
   45         // @Defines
   46         //****************************************************************************
   47         
   48         // USER CODE BEGIN (SCS_General,3)
   49         
   50         // USER CODE END
   51         
   52         
   53         // Function-like macros ******************************************************
C166 COMPILER V7.57.0, SCS                                                                 12/14/2020 10:56:36 PAGE 2   

   54         
   55         // PLLSTAT_COND_3: For polling a PLLSTAT condition up to 3 times; an "if"
   56         // construct needs at least 12 instruction cycles before 3rd check. "
   57         // Depending on the compiler (optimization) and the program location, the
   58         // effective number of instruction cycles may be higher.
   59         #define PLLSTAT_COND_3(Condition) (((Condition) && (Condition)) && (Condition))
   60         
   61         // GET_CYCLES: Converts Time[us] and MaxSysFreq[Hz] into cycles for timer,
   62         // rounding up; for compile-time use only.
   63         #define GET_CYCLES(Time, MaxSysFreq) \
   64                 ((unsigned int)(((((long)(Time))*((MaxSysFreq)/1000))+15999)/16000))
   65         
   66         // Constants that may be overwritten by the user *****************************
   67         
   68         // If not user defined:
   69         // Number of attempts for high precision osc. start
   70         #ifndef SCS_ATTEMPTS_OSC_HP
   71         #define SCS_ATTEMPTS_OSC_HP 10
   72         #endif
   73         
   74         // If not user defined:
   75         // Timeout in [us] for PLLV after high precision osc. start
   76         #ifndef SCS_TIME_OSC_HP_PLLV
   77         #define SCS_TIME_OSC_HP_PLLV 5000
   78         #endif
   79         
   80         // If not user defined:
   81         // Delay time/timeout in [us] for 1024 cycles after high precision osc. start
   82         #ifndef SCS_TIME_OSC_HP_1024
   83         #define SCS_TIME_OSC_HP_1024 1000
   84         #endif
   85         
   86         // Constants that cannot be overwritten by the user **************************
   87         
   88         // Maximum system frequency values in [Hz]
   89         #define SCS_F_INT_5MHZ 5200000
   90         #define SCS_F_INT_10MHZ 10400000
   91         
   92         // Other times in [us]
   93         #define SCS_TIME_VCO_BAND_SWITCH 150
   94         #define SCS_TIME_VCO_FINDIS_TO_BASE 50
   95         #define SCS_TIME_VCO_K2 5
   96         #define SCS_TIME_VCO_LOCK 200
   97         
   98         // Check clock parameters ****************************************************
   99         
  100         // Check fXTAL
  101         #if SCS_F_XTAL < 4000000 || SCS_F_XTAL > 25000000
              #   error  "SCS_F_XTAL out of range"
              #endif
  104         
  105         // Check fPLL target frequency
  106         #if SCS_F_PLL_TARGET < 1000000 || SCS_F_PLL_TARGET > 80000000
              #   error  "SCS_F_PLL_TARGET out of range"
              #endif
  109         
  110         // check fP
  111         #if SCS_F_P < 4000000 || SCS_F_P > 16000000
              #   error  "SCS_F_P out of range"
              #endif
  114         
  115         // check fVCO
C166 COMPILER V7.57.0, SCS                                                                 12/14/2020 10:56:36 PAGE 3   

  116         #if SCS_F_VCO < 10000000 || SCS_F_VCO > 160000000
              #   error  "SCS_F_VCO out of range"
              #endif
  119         
  120         // Check P divider
  121         #if SCS_P < 1 || SCS_P > 16
              #   error  "SCS_P out of range"
              #endif
  124         
  125         // Check N divider
  126         #if SCS_N < 16 || SCS_N > 40
              #   error  "SCS_N out of range"
              #endif
  129         
  130         // Check K2_5MHZ divider
  131         #if SCS_K2_5MHZ < 1 || SCS_K2_5MHZ > 512
              #   error  "SCS_K2_5MHZ out of range"
              #endif
  134         
  135         // Check K2 divider and additional K2 divider steps if defined
  136         
  137         #if SCS_K2 < 1 || SCS_K2 > 512
              #   error  "SCS_K2 out of range"
              #endif
  140         
  141         #ifdef SCS_K2_1
  142         #  if SCS_K2_1 < 1 || SCS_K2_1 > 512
              #     error  "SCS_K2_1 out of range"
              #  endif
  145         #endif
  146         
  147         #ifdef SCS_K2_2
  148         #  if SCS_K2_2 < 1 || SCS_K2_2 > 512
              #     error  "SCS_K2_2 out of range"
              #  endif
  151         #endif
  152         
  153         #ifdef SCS_K2_3
  154         #  if SCS_K2_3 < 1 || SCS_K2_3 > 512
              #     error  "SCS_K2_3 out of range"
              #  endif
  157         #endif
  158         
  159         #ifdef SCS_K2_4
              #  if SCS_K2_4 < 1 || SCS_K2_4 > 512
              #     error  "SCS_K2_4 out of range"
              #  endif
              #endif
  164         
  165         
  166         
  167         //****************************************************************************
  168         // @Typedefs
  169         //****************************************************************************
  170         
  171         
  172         
  173         //****************************************************************************
  174         // @Imported Global Variables
  175         //****************************************************************************
  176         
  177         
C166 COMPILER V7.57.0, SCS                                                                 12/14/2020 10:56:36 PAGE 4   

  178         
  179         //****************************************************************************
  180         // @Global Variables
  181         //****************************************************************************
  182         
  183         
  184         
  185         //****************************************************************************
  186         // @Privare Variables
  187         //****************************************************************************
  188         
  189         // Saved value of CCU60_KSCFG
  190         static unsigned int Ccu60KscfgSave;
  191         
  192         // Saved value of CCU60 MCFG
  193         static unsigned int Ccu60McfgSave;
  194         
  195         // Saved value of CCU60 TCTR0
  196         static unsigned int Ccu60Tctr0Save;
  197         
  198         // Saved value of CCU60 TCTR2
  199         static unsigned int Ccu60Tctr2Save;
  200         
  201         // Saved value of CCU60 PISELH
  202         static unsigned int Ccu60PiselhSave;
  203         
  204         
  205         
  206         //****************************************************************************
  207         // @External Prototypes
  208         //****************************************************************************
  209         
  210         
  211         
  212         //****************************************************************************
  213         // @Prototypes Of Local Functions
  214         //****************************************************************************
  215         
  216         static SCS_ErrorType SCS_RampUpPllInNormalMode(void);
  217         
  218         
  219         //****************************************************************************
  220         // @Local Functions
  221         //****************************************************************************
  222         
  223         //****************************************************************************;
  224         // @Function      inline void SCS_EnableOscHiPrecCrystal(void)
  225         //
  226         //-----------------------------------------------------------------------------
  227         // @Description   This expert level function configures the high precision
  228         //                oscillator for crystal mode.
  229         //                
  230         //                Notes:
  231         //                - The user is responsible for disabling the register
  232         //                  protection.
  233         //
  234         //-----------------------------------------------------------------------------
  235         // @Returnvalue   None
  236         //
  237         //-----------------------------------------------------------------------------
  238         // @Parameters    None
  239         //
C166 COMPILER V7.57.0, SCS                                                                 12/14/2020 10:56:36 PAGE 5   

  240         //-----------------------------------------------------------------------------
  241         // @Date          2010-4-18
  242         //
  243         //-----------------------------------------------------------------------------
  244         
  245         // USER CODE BEGIN (SCS_EnableOscHiPrecCrystal,1)
  246         
  247         // USER CODE END
  248         
  249         _inline void SCS_EnableOscHiPrecCrystal(void)
  250         {
  251  1         // clear MODE for external crystal/clock, clear SHBY to disable shaper bypass,
  252  1         // clear rh and w bits, leave other bits unchanged
  253  1         SCU_HPOSCCON &=
  254  1          ((0U    <<0U) | // PLLV for PLL Valid Status Bit (rh)
  255  1                          // 0: OSC_HP frequency is not usable
  256  1                          // 1: OSC_HP frequency is usable
  257  1           (0U    <<1U) | // OSCWDTRST Oscillator Watchdog Reset
  258  1                          // 0 : Osc. watchdog is not reset and remains active
  259  1                          // 1 : Osc. watchdog is reset and restarted
  260  1           (0U    <<2U) | // MODE Oscillator Mode
  261  1                          // 0 : External crystal/clock, no osc. power-saving mode
  262  1                          // 1 : OSC_HP disabled, no osc. power-saving mode
  263  1                          // 2 : External clock, osc. power-saving mode
  264  1                          // 3 : OSC_HP disabled, osc. power-saving mode
  265  1           (0U    <<4U) | // GAINSEL Oscillator Gain Selection (rh)
  266  1                          // 0: gain control from 4 MHz to 8 MHz
  267  1                          // 1: gain control from 4 MHz to 16 MHz
  268  1                          // 2: gain control from 4 MHz to 20 MHz
  269  1                          // 3: gain control from 4 MHz to 25 MHz
  270  1           (0U    <<6U) | // X1D XTAL1 Data Value (rh)
  271  1                          // inverted level of pin XTAL1 if X1DEN is set
  272  1           (1U    <<7U) | // X1DEN XTAL1 Data Enable
  273  1                          // 0 : 0 Bit X1D is not updated
  274  1                          // 1 : 1 Bit X1D can be updated
  275  1           (0U    <<8U) | // SHBY Shaper Bypass
  276  1                          // 0 : 0 Shaper is not bypassed
  277  1                          // 1 : 1 Shaper is bypassed
  278  1           (1U    <<9U) | // EMCLKEN OSCWDT Emergency System Clock Source Select Enable
  279  1                          // 0 : MCM controlled by SYSCON0.CLKSEL in OSCWDT emergency case
  280  1                          // 1 : MCM controlled by SYSCON0.EMCLKSEL in OSCWDT emergency case
  281  1           (1U    <<10U)| // EMFINDISEN Emergency Input Clock Disconnect Enable
  282  1                          // 0 : PLLSTAT.FINDIS not updated in OSCWDT emergency case
  283  1                          // 1 : PLLSTAT.FINDIS is set in OSCWDT emergency case
  284  1           (0U    <<11U)| // OSC2L1 OSCWDT Reached Status (rh)
  285  1                          // 0: OSCWDT did not detect frequency below limit
  286  1                          // 1: OSCWDT detected frequency below limit
  287  1           (0U    <<12U));// OSC2L0 OSCWDT Left Status (rh)
  288  1                          // 0: OSCWDT did not detect frequency above limit
  289  1                          // 1: OSCWDT detected frequency above limit
  290  1      
  291  1      } // end of function SCS_EnableOscHiPrecCrystal
  292         
  293         //****************************************************************************;
  294         // @Function      inline void SCS_RestartVcoLockDetect(void)
  295         //
  296         //-----------------------------------------------------------------------------
  297         // @Description   This expert level function restarts the VCO lock detection.
  298         //                
  299         //                Notes:
  300         //                - The user is responsible for disabling the register
  301         //                  protection.
C166 COMPILER V7.57.0, SCS                                                                 12/14/2020 10:56:36 PAGE 6   

  302         //
  303         //-----------------------------------------------------------------------------
  304         // @Returnvalue   None
  305         //
  306         //-----------------------------------------------------------------------------
  307         // @Parameters    None
  308         //
  309         //-----------------------------------------------------------------------------
  310         // @Date          2010-4-18
  311         //
  312         //-----------------------------------------------------------------------------
  313         
  314         // USER CODE BEGIN (SCS_RestartVcoLockDetect,1)
  315         
  316         // USER CODE END
  317         
  318         _inline void SCS_RestartVcoLockDetect(void)
  319         {
  320  1         // restart VCO lock detection
  321  1         SCU_PLLCON1_RESLD =
  322  1          1U;             // RESLD: Restart VCO Lock Detection (w)
  323  1                          // Setting this bit will reset bit PLLSTAT.VCOLOCK and
  324  1                          // restart the VCO lock detection
  325  1      
  326  1      } // end of function SCS_RestartVcoLockDetect
  327         
  328         //****************************************************************************;
  329         // @Function      inline void SCS_DisconnectVcoInput(void)
  330         //
  331         //-----------------------------------------------------------------------------
  332         // @Description   This expert level function disconnects VCO from its clock
  333         //                input.
  334         //                
  335         //                Notes:
  336         //                - The user is responsible for disabling the register
  337         //                  protection.
  338         //
  339         //-----------------------------------------------------------------------------
  340         // @Returnvalue   None
  341         //
  342         //-----------------------------------------------------------------------------
  343         // @Parameters    None
  344         //
  345         //-----------------------------------------------------------------------------
  346         // @Date          2010-4-18
  347         //
  348         //-----------------------------------------------------------------------------
  349         
  350         // USER CODE BEGIN (SCS_DisconnectVcoInput,1)
  351         
  352         // USER CODE END
  353         
  354         _inline void SCS_DisconnectVcoInput(void)
  355         {
  356  1         // disconnect VCO from its clock input
  357  1         SCU_STATCLR1 =
  358  1           (0U    <<0U) | // Clear PLLSTAT.VCOL0 (w)
  359  1           (0U    <<1U) | // Clear PLLSTAT.VCOL1 (w)
  360  1           (0U    <<2U) | // Clear HPOSCCON.OSC2L1 (w)
  361  1           (0U    <<3U) | // Clear HPOSCCON.OSC2L2 (w)
  362  1           (1U    <<4U) | // Set PLLSTAT.FINDIS (w)
  363  1           (0U    <<5U) ; // Clear PLLSTAT.FINDIS (w)
C166 COMPILER V7.57.0, SCS                                                                 12/14/2020 10:56:36 PAGE 7   

  364  1      
  365  1      } // end of function SCS_DisconnectVcoInput
  366         
  367         //****************************************************************************;
  368         // @Function      inline void SCS_ConnectVcoInput(void)
  369         //
  370         //-----------------------------------------------------------------------------
  371         // @Description   This expert level function connects VCO from its clock
  372         //                input.
  373         //                
  374         //                Notes:
  375         //                - The user is responsible for disabling the register
  376         //                  protection.
  377         //
  378         //-----------------------------------------------------------------------------
  379         // @Returnvalue   None
  380         //
  381         //-----------------------------------------------------------------------------
  382         // @Parameters    None
  383         //
  384         //-----------------------------------------------------------------------------
  385         // @Date          2010-4-18
  386         //
  387         //-----------------------------------------------------------------------------
  388         
  389         // USER CODE BEGIN (SCS_ConnectVcoInput,1)
  390         
  391         // USER CODE END
  392         
  393         _inline void SCS_ConnectVcoInput(void)
  394         {
  395  1         // connect VCO from its clock input
  396  1         SCU_STATCLR1 =
  397  1           (0U    <<0U) | // Clear PLLSTAT.VCOL0 (w)
  398  1           (0U    <<1U) | // Clear PLLSTAT.VCOL1 (w)
  399  1           (0U    <<2U) | // Clear HPOSCCON.OSC2L1 (w)
  400  1           (0U    <<3U) | // Clear HPOSCCON.OSC2L2 (w)
  401  1           (0U    <<4U) | // Set PLLSTAT.FINDIS (w)
  402  1           (1U    <<5U) ; // Clear PLLSTAT.FINDIS (w)
  403  1      
  404  1      } // end of function SCS_ConnectVcoInput
  405         
  406         //****************************************************************************;
  407         // @Function      inline void SCS_SelectVcoBand(unsigned int VcoBand)
  408         //
  409         //-----------------------------------------------------------------------------
  410         // @Description   This expert level function sets the required VCO band.
  411         //                
  412         //                Notes:
  413         //                - The user is responsible for disabling the register
  414         //                  protection.
  415         //
  416         //-----------------------------------------------------------------------------
  417         // @Returnvalue   None
  418         //
  419         //-----------------------------------------------------------------------------
  420         // @Parameters    VcoBand: 0 or 1
  421         //
  422         //-----------------------------------------------------------------------------
  423         // @Date          2010-4-18
  424         //
  425         //-----------------------------------------------------------------------------
C166 COMPILER V7.57.0, SCS                                                                 12/14/2020 10:56:36 PAGE 8   

  426         
  427         // USER CODE BEGIN (SCS_SelectVcoBand,1)
  428         
  429         // USER CODE END
  430         
  431         _inline void SCS_SelectVcoBand(unsigned int VcoBand)
  432         {
  433  1         // select VCO band
  434  1         SCU_PLLCON0_VCOSEL = VcoBand;
  435  1      
  436  1      } // end of function SCS_SelectVcoBand
  437         
  438         //****************************************************************************;
  439         // @Function      inline void SCS_StartTimer(unsigned int Cycles)
  440         //
  441         //-----------------------------------------------------------------------------
  442         // @Description   This expert level function starts timer T13 for counting
  443         //                a certain number of clocks.
  444         //                
  445         //                Notes:
  446         //                - It is assumed that the timer is already initialized by 
  447         //                  SCS_InitTimer.
  448         //                - Cycles < 3 are set to 3 for hardware reasons.
  449         //
  450         //-----------------------------------------------------------------------------
  451         // @Returnvalue   None
  452         //
  453         //-----------------------------------------------------------------------------
  454         // @Parameters    Cycles: Number of T13 clocks to count, 0...65535
  455         //
  456         //-----------------------------------------------------------------------------
  457         // @Date          2010-4-18
  458         //
  459         //-----------------------------------------------------------------------------
  460         
  461         // USER CODE BEGIN (SCS_StartTimer,1)
  462         
  463         // USER CODE END
  464         
  465         _inline void SCS_StartTimer(unsigned int Cycles)
  466         {
  467  1         // stop T13 for security reasons, clear T13
  468  1         CCU60_TCTR4 =
  469  1           (0U    <<0U) | // T12RR Timer 12 Run Reset (w)
  470  1           (0U    <<1U) | // T12RS Timer 12 Run Set (w)
  471  1           (0U    <<2U) | // T12RES Timer 12 Reset (w)
  472  1           (0U    <<3U) | // DTRES Dead-Time Counter Reset (w))
  473  1           (0U    <<5U) | // T12CNT Timer T12 Count Event if enabled (PISELH) (w)
  474  1           (0U    <<6U) | // T12STR Timer 12 Shadow Transfer Request (w)
  475  1           (0U    <<7U) | // T12STD Timer 12 Shadow Transfer Disable (w)
  476  1           (1U    <<8U) | // T13RR Timer 13 Run Reset (w)
  477  1           (0U    <<9U) | // T13RS Timer 13 Run Set (w)
  478  1           (1U    <<10U)| // T13RES Timer 13 Reset (w)
  479  1           (0U    <<13U)| // T13CNT Timer T13 Count Event if enabled (PISELH) (w)
  480  1           (0U    <<14U)| // T13STR Timer 13 Shadow Transfer Request (w)
  481  1           (0U    <<15U); // T13STD Timer 13 Shadow Transfer Disable (w)
  482  1      
  483  1         // limit T13 period
  484  1         if (Cycles < 3U)
  485  1         {
  486  2           Cycles = 3U;
  487  2         }
C166 COMPILER V7.57.0, SCS                                                                 12/14/2020 10:56:36 PAGE 9   

  488  1      
  489  1         //set T13 period
  490  1         CCU60_T13PR = Cycles - 2U;
  491  1      
  492  1         // enable T13 shadow transfer for period setting
  493  1         CCU60_TCTR4 =
  494  1           (0U    <<0U) | // T12RR Timer 12 Run Reset (w)
  495  1           (0U    <<1U) | // T12RS Timer 12 Run Set (w)
  496  1           (0U    <<2U) | // T12RES Timer 12 Reset (w)
  497  1           (0U    <<3U) | // DTRES Dead-Time Counter Reset (w))
  498  1           (0U    <<5U) | // T12CNT Timer T12 Count Event if enabled (PISELH) (w)
  499  1           (0U    <<6U) | // T12STR Timer 12 Shadow Transfer Request (w)
  500  1           (0U    <<7U) | // T12STD Timer 12 Shadow Transfer Disable (w)
  501  1           (0U    <<8U) | // T13RR Timer 13 Run Reset (w)
  502  1           (0U    <<9U) | // T13RS Timer 13 Run Set (w)
  503  1           (0U    <<10U)| // T13RES Timer 13 Reset (w)
  504  1           (0U    <<13U)| // T13CNT Timer T13 Count Event if enabled (PISELH) (w)
  505  1           (1U    <<14U)| // T13STR Timer 13 Shadow Transfer Request (w)
  506  1           (0U    <<15U); // T13STD Timer 13 Shadow Transfer Disable (w)
  507  1      
  508  1         // start T13
  509  1         CCU60_TCTR4 =
  510  1           (0U    <<0U) | // T12RR Timer 12 Run Reset (w)
  511  1           (0U    <<1U) | // T12RS Timer 12 Run Set (w)
  512  1           (0U    <<2U) | // T12RES Timer 12 Reset (w)
  513  1           (0U    <<3U) | // DTRES Dead-Time Counter Reset (w))
  514  1           (0U    <<5U) | // T12CNT Timer T12 Count Event if enabled (PISELH) (w)
  515  1           (0U    <<6U) | // T12STR Timer 12 Shadow Transfer Request (w)
  516  1           (0U    <<7U) | // T12STD Timer 12 Shadow Transfer Disable (w)
  517  1           (0U    <<8U) | // T13RR Timer 13 Run Reset (w)
  518  1           (1U    <<9U) | // T13RS Timer 13 Run Set (w)
  519  1           (0U    <<10U)| // T13RES Timer 13 Reset (w)
  520  1           (0U    <<13U)| // T13CNT Timer T13 Count Event if enabled (PISELH) (w)
  521  1           (0U    <<14U)| // T13STR Timer 13 Shadow Transfer Request (w)
  522  1           (0U    <<15U); // T13STD Timer 13 Shadow Transfer Disable (w)
  523  1      
  524  1      } // end of function SCS_StartTimer
  525         
  526         //****************************************************************************;
  527         // @Function      inline void SCS_DelayByTimer(unsigned int Cycles)
  528         //
  529         //-----------------------------------------------------------------------------
  530         // @Description   This expert level function starts timer T13 and waits until
  531         //                the specified number of clocks is counted.
  532         //                
  533         //                Notes:
  534         //                - It is assumed that the timer is already initialized by 
  535         //                  SCS_InitTimer.
  536         //                - Cycles < 3 are set to 3 for hardware reasons.
  537         //
  538         //-----------------------------------------------------------------------------
  539         // @Returnvalue   None
  540         //
  541         //-----------------------------------------------------------------------------
  542         // @Parameters    Cycles: Number of T13 clocks to count, 0...65535
  543         //
  544         //-----------------------------------------------------------------------------
  545         // @Date          2010-4-18
  546         //
  547         //-----------------------------------------------------------------------------
  548         
  549         // USER CODE BEGIN (SCS_DelayByTimer,1)
C166 COMPILER V7.57.0, SCS                                                                 12/14/2020 10:56:36 PAGE 10  

  550         
  551         // USER CODE END
  552         
  553         _inline void SCS_DelayByTimer(unsigned int Cycles)
  554         {
  555  1         // start delay timer T13
  556  1         SCS_StartTimer(Cycles);
  557  1      
  558  1         // wait until delay time clocks are counted
  559  1         do
  560  1         {
  561  2         }
  562  1         while(CCU60_TCTR0_T13R);
  563  1      
  564  1      } // end of function SCS_DelayByTimer
  565         
  566         
  567         //****************************************************************************;
  568         // @Function      SCS_ErrorType SCS_RampUpPllInNormalMode (void)
  569         //
  570         //-----------------------------------------------------------------------------
  571         // @Description   This private function performs a ramp-up of the PLL in 
  572         //                Normal Operation Mode.
  573         //
  574         //                Notes: 
  575         //                - The user is responsible for disabling the register
  576         //                  protection.
  577         //-----------------------------------------------------------------------------
  578         // @Returnvalue   Error code
  579         //
  580         //-----------------------------------------------------------------------------
  581         // @Parameters    None
  582         //
  583         //-----------------------------------------------------------------------------
  584         // @Date          2010-4-18
  585         //
  586         //-----------------------------------------------------------------------------
  587         
  588         // USER CODE BEGIN (SCS_RampUpPllInNormalMode,1)
  589         
  590         // USER CODE END
  591         
  592         
  593         static SCS_ErrorType SCS_RampUpPllInNormalMode(void)
  594         {
  595  1         SCS_ErrorType Error;
  596  1      
  597  1         #ifdef SCS_K2_1
  598  1           // set additional K2 divider step SCS_K2_1 if needed
  599  1           Error = SCS_ApplyNewK2Div(((unsigned int)SCS_K2_1) - 1U);
  600  1           if(Error)
  601  1           {
  602  2             return Error;
  603  2           }
  604  1      
  605  1           #ifdef SCS_K2_2
  606  1             // wait delay time for K2 with new system clock
  607  1             SCS_DelayByTimer(GET_CYCLES(SCS_TIME_VCO_K2, SCS_F_VCO/SCS_K2_1));
  608  1      
  609  1             // set additional K2 divider step SCS_K2_2 if needed
  610  1             Error = SCS_ApplyNewK2Div(((unsigned int)SCS_K2_2) - 1U);
  611  1             if(Error)
C166 COMPILER V7.57.0, SCS                                                                 12/14/2020 10:56:36 PAGE 11  

  612  1             {
  613  2               return Error;
  614  2             }
  615  1      
  616  1             #ifdef SCS_K2_3
  617  1               // wait delay time for K2 switch with new system clock
  618  1               SCS_DelayByTimer(GET_CYCLES(SCS_TIME_VCO_K2, SCS_F_VCO/SCS_K2_2));
  619  1      
  620  1               // set additional K2 divider step SCS_K2_3 if needed
  621  1               Error = SCS_ApplyNewK2Div((((unsigned int)SCS_K2_3)) - 1U);
  622  1               if(Error)
  623  1               {
  624  2                 return Error;
  625  2               }
  626  1               // wait delay time for K2_3 with new system clock
  627  1               SCS_DelayByTimer(GET_CYCLES(SCS_TIME_VCO_K2, SCS_F_VCO/SCS_K2_3));
  628  1             #else
                       // no SCS_K2_3: wait delay time for K2_2 with new system clock
                       SCS_DelayByTimer(GET_CYCLES(SCS_TIME_VCO_K2, SCS_F_VCO/SCS_K2_2));
                     #endif  // SCS_K2_3
  632  1      
  633  1           #else
                     // no SCS_K2_2: wait delay time for K2_1 with new system clock
                     SCS_DelayByTimer(GET_CYCLES(SCS_TIME_VCO_K2, SCS_F_VCO/SCS_K2_1));
                   #endif  // SCS_K2_2
  637  1      
  638  1         #endif  // SCS_K2_1
  639  1      
  640  1         // set final K2 divider SCS_K2
  641  1         Error = SCS_ApplyNewK2Div((((unsigned int)SCS_K2)) - 1U);
  642  1         if(Error)
  643  1         {
  644  2           return Error;
  645  2         }
  646  1      
  647  1         // no error
  648  1         return SCS_STATE_NO_ERROR;
  649  1      
  650  1      }  // end of function SCS_RampUpPllInNormalMode
  651         
  652         
  653         //****************************************************************************;
  654         // @Function      SCS_ErrorType SCS_GoFromBaseToNormalMode (void)
  655         //
  656         //-----------------------------------------------------------------------------
  657         // @Description   This use case function performs a transition from Base Mode 
  658         //                to Normal Operation Mode.
  659         //
  660         //                Notes: 
  661         //                - The user is responsible for disabling the register
  662         //                  protection.
  663         //-----------------------------------------------------------------------------
  664         // @Returnvalue   Error code
  665         //
  666         //-----------------------------------------------------------------------------
  667         // @Parameters    None
  668         //
  669         //-----------------------------------------------------------------------------
  670         // @Date          2010-4-18
  671         //
  672         //-----------------------------------------------------------------------------
  673         
C166 COMPILER V7.57.0, SCS                                                                 12/14/2020 10:56:36 PAGE 12  

  674         // USER CODE BEGIN (SCS_GoFromBaseToNormalMode,1)
  675         
  676         // USER CODE END
  677         
  678         
  679         SCS_ErrorType SCS_GoFromBaseToNormalMode(void)
  680         {
  681  1         SCS_ErrorType Error;
  682  1      
  683  1         // enable high precision oscillator for crystal
  684  1         SCS_EnableOscHiPrecCrystal();
  685  1      
  686  1         // check high precision oscillator frequency
  687  1         Error = SCS_CheckFreqOscHiPrec();
  688  1         if(Error)
  689  1         {
  690  2           return Error;
  691  2         }
  692  1      
  693  1         // set K1 divider = 1 for VCO bypass frequency of 5 MHz
  694  1         Error = SCS_ApplyNewK1Div(1U - 1U);
  695  1         if(Error)
  696  1         {
  697  2           return Error;
  698  2         }
  699  1      
  700  1         // enable VCO bypass, new fSYS = 5 MHz
  701  1         Error = SCS_EnableVcoBypass();
  702  1         if(Error)
  703  1         {
  704  2           return Error;
  705  2         }
  706  1      
  707  1         if(!SCU_PLLCON0_VCOSEL)
  708  1         {  // current VCO band = 0:
  709  2      
  710  2            // select VCO band 1
  711  2            SCS_SelectVcoBand(1U);
  712  2      
  713  2            // wait band switch delay time with 5 MHz int. osc.
  714  2            SCS_DelayByTimer(GET_CYCLES(SCS_TIME_VCO_BAND_SWITCH, SCS_F_INT_5MHZ));
  715  2         }
  716  1         else
  717  1         {  // current VCO band = 1:
  718  2      
  719  2            // set K2 divider = 8
  720  2            Error = SCS_ApplyNewK2Div(8U - 1U);
  721  2            if(Error)
  722  2            {
  723  3              return Error;
  724  3            }
  725  2         }
  726  1      
  727  1         // set final P divider
  728  1         Error = SCS_ApplyNewPDiv((((unsigned int)SCS_P)) - 1U);
  729  1         if(Error)
  730  1         {
  731  2           return Error;
  732  2         }
  733  1      
  734  1         // set final N divider
  735  1         Error = SCS_ApplyNewNDiv((((unsigned int)SCS_N)) - 1U);
C166 COMPILER V7.57.0, SCS                                                                 12/14/2020 10:56:36 PAGE 13  

  736  1         if(Error)
  737  1         {
  738  2           return Error;
  739  2         }
  740  1      
  741  1         // disconnect VCO from clock input (enable free-running oscillator)
  742  1         SCS_DisconnectVcoInput();
  743  1      
  744  1         // wait until base frequency is reached with 10 MHz int. osc.
  745  1         SCS_DelayByTimer(GET_CYCLES(SCS_TIME_VCO_FINDIS_TO_BASE, SCS_F_INT_10MHZ));
  746  1      
  747  1         // disable VCO bypass, new fSYS ~ (50 MHz / 8) ~ 6.3 MHz
  748  1         Error = SCS_DisableVcoBypass();
  749  1         if(Error)
  750  1         {
  751  2           return Error;
  752  2         }
  753  1      
  754  1         // select high precision oscillator as VCO source
  755  1         Error = SCS_SelectVcoSrcOscHiPrec();
  756  1         if(Error)
  757  1         {
  758  2           return Error;
  759  2         }
  760  1      
  761  1         // set K2 for fSYS = 5 MHz with final settings, new fSYS ~ (50 MHz / K2)
  762  1         // for fVCO = 160 MHz: K2 = 32, new fSYS ~ 1.6 MHz
  763  1         Error = SCS_ApplyNewK2Div(((unsigned int)SCS_K2_5MHZ) - 1U);
  764  1         if(Error)
  765  1         {
  766  2           return Error;
  767  2         }
  768  1      
  769  1         // connect VCO to clock input, new fSYS ~ 5MHz
  770  1         SCS_ConnectVcoInput();
  771  1      
  772  1         // restart VCO lock detection
  773  1         SCS_RestartVcoLockDetect();
  774  1      
  775  1         // start timer for VCO lock with maximum ~ 5 MHz
  776  1         SCS_StartTimer(GET_CYCLES(SCS_TIME_VCO_LOCK, SCS_F_INT_5MHZ));
  777  1      
  778  1         // wait until lock occurs or timeout is over
  779  1         do
  780  1         {
  781  2         }
  782  1         while((!SCU_PLLSTAT_VCOLOCK) && CCU60_TCTR0_T13R);
  783  1         if(!SCU_PLLSTAT_VCOLOCK)
  784  1         {
  785  2           // no VCO lock
  786  2           return SCS_STATE_TO_VCO_LOCK;
  787  2         }
  788  1      
  789  1         // enable VCOLCK emergency
  790  1         Error = SCS_EnableVcoLockEmerg();
  791  1         if(Error)
  792  1         {
  793  2           return Error;
  794  2         }
  795  1      
  796  1         // ramp up PLL for fSys = final value in normal operation mode
  797  1         Error = SCS_RampUpPllInNormalMode();
C166 COMPILER V7.57.0, SCS                                                                 12/14/2020 10:56:36 PAGE 14  

  798  1         if(Error)
  799  1         {
  800  2           return Error;
  801  2         }
  802  1      
  803  1         // no error
  804  1         return SCS_STATE_NO_ERROR;
  805  1      
  806  1      }  // end of function SCS_GoFromBaseToNormalMode
  807         
  808         
  809         //****************************************************************************;
  810         // @Function      void SCS_InitTimer (void)
  811         //-----------------------------------------------------------------------------
  812         // @Description   This function configures CCU6 timer T13 as one-shot timer with
  813         //                a resolution of 16 CCU6 clocks = 16 system clocks.
  814         //
  815         //                Notes:
  816         //                - The function will enable CCU6 and will overwrite previous
  817         //                  settings for T13.
  818         //                - The function will save the previous CCU6 register contents;
  819         //                  they may be restored via SCS_RestoreTimer.
  820         //                - The user must call this function before any other SCS driver
  821         //                  function. (except SCS_SelectBandgapHiPrec if needed).
  822         //                - The user is responsible for disabling the register protection.
  823         //
  824         //-----------------------------------------------------------------------------
  825         // @Returnvalue   None
  826         //
  827         //-----------------------------------------------------------------------------
  828         // @Parameters    None
  829         //
  830         //-----------------------------------------------------------------------------
  831         // @Date          2010-4-18
  832         //
  833         //-----------------------------------------------------------------------------
  834         
  835         // USER CODE BEGIN (SCS_InitTimer,1)
  836         
  837         // USER CODE END
  838         
  839         void SCS_InitTimer(void)
  840         {
  841  1         volatile unsigned int Work;
  842  1      
  843  1         // save CCU60_KSCFG
  844  1         Ccu60KscfgSave = CCU60_KSCFG;
  845  1      
  846  1         // enable CC60 module
  847  1         CCU60_KSCFG |=
  848  1           (1U    <<0U) | // MODEN Module Enable
  849  1           (1U    <<1U) | // BPMODEN Bit Protection for MODEN, set to 1 for change (w)
  850  1           (0U    <<4U) | // NOMCFG Normal Operation Mode Configuration
  851  1                          // kernel mode applied in normal operation mode
  852  1           (0U    <<7U) | // BPNOM Bit Protection for NOMCFG, set to 1 for change (w)
  853  1           (0U    <<8U) | // SUMCFG Suspend Mode Configuration
  854  1                          // Kernel mode applied in suspend mode
  855  1           (0U    <<11U)| // BPSUM Bit Protection for SUMCFG, set to 1 for change (w)
  856  1           (0U    <<12U)| // COMCFG Clock Off Mode Configuration
  857  1                          // kernel mode applied in clock off mode
  858  1           (0U    <<15U); // BPCOM Bit Protection for COMCFG, set to 1 for change (w)
  859  1      
C166 COMPILER V7.57.0, SCS                                                                 12/14/2020 10:56:36 PAGE 15  

  860  1         // read SFR back to avoid pipeline effects
  861  1         Work = CCU60_KSCFG;
  862  1      
  863  1         // save CCU60_MCFG
  864  1         Ccu60McfgSave = CCU60_MCFG;
  865  1      
  866  1         // enable T13 functionality, leave other bits unchanged
  867  1         CCU60_MCFG |=
  868  1           (0U    <<0U) | // T12 T12 Available
  869  1           (1U    <<1U) | // T13 T13 Available
  870  1           (0U    <<2U);  // MCM Multi-Channel Mode Available
  871  1       
  872  1         // stop T13, clear T13
  873  1         // (CCU60_TCTR4 needs not be saved)
  874  1         CCU60_TCTR4 =
  875  1           (0U    <<0U) | // T12RR Timer 12 Run Reset (w)
  876  1           (0U    <<1U) | // T12RS Timer 12 Run Set (w)
  877  1           (0U    <<2U) | // T12RES Timer 12 Reset (w)
  878  1           (0U    <<3U) | // DTRES Dead-Time Counter Reset (w)
  879  1           (0U    <<5U) | // T12CNT Timer T12 Count Event if enabled (PISELH) (w)
  880  1           (0U    <<6U) | // T12STR Timer 12 Shadow Transfer Request (w)
  881  1           (0U    <<7U) | // T12STD Timer 12 Shadow Transfer Disable (w)
  882  1           (1U    <<8U) | // T13RR Timer 13 Run Reset (w)
  883  1           (0U    <<9U) | // T13RS Timer 13 Run Set (w)
  884  1           (1U    <<10U)| // T13RES Timer 13 Reset (w)
  885  1           (0U    <<13U)| // T13CNT Timer T13 Count Event if enabled (PISELH) (w)
  886  1           (0U    <<14U)| // T13STR Timer 13 Shadow Transfer Request (w)
  887  1           (0U    <<15U); // T13STD Timer 13 Shadow Transfer Disable (w)
  888  1      
  889  1         // save CCU60_TCTR0
  890  1         Ccu60Tctr0Save = CCU60_TCTR0;
  891  1       
  892  1         // set T13 period, for fCC6/16, clear T13PRE to disable additional prescaler,
  893  1         // leave bits T12CLK, T12PRE, CTM unchanged
  894  1         CCU60_TCTR0 = (CCU60_TCTR0 & ((7U <<0U)|(1U <<3U)|(1U <<7U))) |
  895  1           ((0U    <<0U) | // T12CLK Timer T12 Input Clock Select
  896  1                          // 0: f = fCC6
  897  1                          // 1: f = fCC6 / 2
  898  1                          // 2: f = fCC6 / 4
  899  1                          // 3: f = fCC6 / 8
  900  1                          // 4: f = fCC6 / 16
  901  1                          // 5: f = fCC6 / 32
  902  1                          // 6: f = fCC6 / 64
  903  1                          // 7: f = fCC6 / 128
  904  1           (0U    <<3U) | // T12PRE Timer T12 Prescaler Bit
  905  1                          // 0: additional prescaler disabled
  906  1                          // 1: additional prescaler enabled
  907  1           (0U    <<4U) | // T12R Timer T12 Run Bit (rh)
  908  1                          // 0: Timer is stopped
  909  1                          // 1: Timer is running
  910  1           (0U    <<5U) | // STE12 Timer T12 Shadow Transfer Enable (rh)
  911  1                          // 0: Shadow register transfer is disabled
  912  1                          // 1: Shadow register transfer is enabled
  913  1           (0U    <<6U) | // CDIR Count Direction of Timer T12 (rh)
  914  1                          // 0: T12 counts up
  915  1                          // 1: T12 counts down
  916  1           (0U    <<7U) | // CTM T12 Operating Mode
  917  1                          // 0: Edge-aligned Mode
  918  1                          // 1: Center-aligned Mode
  919  1           (4U    <<8U) | // T13CLK Timer T13 Input Clock Select
  920  1                          // 0: f = fCC6
  921  1                          // 1: f = fCC6 / 2
C166 COMPILER V7.57.0, SCS                                                                 12/14/2020 10:56:36 PAGE 16  

  922  1                          // 2: f = fCC6 / 4
  923  1                          // 3: f = fCC6 / 8
  924  1                          // 4: f = fCC6 / 16
  925  1                          // 5: f = fCC6 / 32
  926  1                          // 6: f = fCC6 / 64
  927  1                          // 7: f = fCC6 / 128
  928  1           (0U    <<11U)| // T13PRE Timer T13 Prescaler Bit
  929  1                          // 0: additional prescaler disabled
  930  1                          // 1: additional prescaler enabled
  931  1           (0U    <<12U)| // T13R Timer T13 Run Bit (rh)
  932  1                          // 0: Timer is stopped
  933  1                          // 1: Timer is running
  934  1           (0U    <<13U));// STE13 Timer T13 Shadow Transfer Enable (rh)
  935  1                          // 0: Shadow register transfer is disabled
  936  1                          // 1: Shadow register transfer is enabled
  937  1      
  938  1         // save CCU60_TCTR2
  939  1         Ccu60Tctr2Save = CCU60_TCTR2;
  940  1      
  941  1         // enable T13 single-shot, clear other T13 bits,
  942  1         // leave bits T12SSC and T12RSEL unchanged
  943  1         CCU60_TCTR2 = (CCU60_TCTR2 & ((1U <<0U)|(3U <<8U))) |
  944  1         ((0U    <<0U) | // T12SSC T12 Single Shot Control
  945  1          (1U    <<1U) | // T13SSC T13 Single Shot Control
  946  1          (0U    <<2U) | // T13TEC T13 Trigger Event Control to start T13
  947  1                         // 0: No action
  948  1                         // 1: T13R set on T12 compare event on channel 0
  949  1                         // 2: T13R set on T12 compare event on channel 1
  950  1                         // 3: T13R set on T12 compare event on channel 2
  951  1                         // 4: T13R set on any T12 compare event (ch. 0, 1, 2)
  952  1                         // 5: T13R set on period-match of T12
  953  1                         // 6: T13R set on zero-match of T12 (while counting up)
  954  1                         // 7: Any edge of inputs CCPOSx
  955  1          (0U    <<5U) | // T13TED T13 Trigger Event Direction for T13TEC trigger
  956  1                         // 0: Reserved, no action
  957  1                         // 1: While T12 is counting up
  958  1                         // 2: While T12 is counting down
  959  1                         // 3: Independent on the count direction of T12
  960  1          (0U    <<8U) | // T12RSEL T12 External Run Selection
  961  1                         // 0: External setting of T12R disabled
  962  1                         // 1: T12R set on rising edge of T12HR
  963  1                         // 2: T12R set on falling edge of T12HR
  964  1                         // 3: T12R set on any edge of T12HR
  965  1          (0U    <<10U));// T13RSEL T13 External Run Selection
  966  1                         // 0: External setting of T13R is disabled
  967  1                         // 1: T13R set on rising edge of T13HR
  968  1                         // 2: T13R set on falling edge of T13HR
  969  1                         // 3: T13R set on any edge of T13HR
  970  1      
  971  1         // save CCU60_PISELH
  972  1         Ccu60PiselhSave = CCU60_PISELH;
  973  1      
  974  1         // enable T13HRA input (rising edge), leave T12 bits unchanged
  975  1          CCU60_PISELH = (CCU60_PISELH & (3U <<2U)) |
  976  1          ((0U    <<0U) | // IST13HR T13 Input Select for T13HR
  977  1                          // 0: T13HRA, 1: T13HRB, 2: T13HRC, 3: T13HRD
  978  1           (0U    <<2U) | // ISCNT12 T12 Input Select for Counting Input
  979  1                          // 0: T12 prescaler, 1: TCTR4.CNT12 written with 1,
  980  1                          // 2: Rising edge on T12HR signal, 3: Falling edge on T12HR signal
  981  1           (0U    <<4U)); // ISCNT13 T13 Input Select for Counting Input
  982  1                          // 0: T13 prescaler, 1: TCTR4.CNT13 written with 1,
  983  1                          // 2: Rising edge on T13HR signal, 3: Falling edge on T13HR signal
C166 COMPILER V7.57.0, SCS                                                                 12/14/2020 10:56:36 PAGE 17  

  984  1      
  985  1      } // end of function SCS_InitTimer
  986         
  987         //****************************************************************************;
  988         // @Function      void SCS_RestoreTimer (void)
  989         //-----------------------------------------------------------------------------
  990         // @Description   This expert level function restores the old CCU6 register
  991         //                values.
  992         //
  993         //                Notes:
  994         //                - It is assumed that the CCU6 registers have been saved by
  995         //                  execution of SCS_InitTimer.
  996         //                - The function will stop and clear T13.
  997         //                - The user may call this function after the last SCS driver
  998         //                  function.
  999         //                - The user is responsible for disabling the register protection.
 1000         //
 1001         //-----------------------------------------------------------------------------
 1002         // @Returnvalue   None
 1003         //
 1004         //-----------------------------------------------------------------------------
 1005         // @Parameters    None
 1006         //
 1007         //-----------------------------------------------------------------------------
 1008         // @Date          2010-4-18
 1009         //
 1010         //-----------------------------------------------------------------------------
 1011         
 1012         // USER CODE BEGIN (SCS_RestoreTimer,1)
 1013         
 1014         // USER CODE END
 1015         
 1016         void SCS_RestoreTimer(void)
 1017         {
 1018  1         // stop T13, clear T13
 1019  1         CCU60_TCTR4 =
 1020  1           (0U    <<0U) | // T12RR Timer 12 Run Reset (w)
 1021  1           (0U    <<1U) | // T12RS Timer 12 Run Set (w)
 1022  1           (0U    <<2U) | // T12RES Timer 12 Reset (w)
 1023  1           (0U    <<3U) | // DTRES Dead-Time Counter Reset (w)
 1024  1           (0U    <<5U) | // T12CNT Timer T12 Count Event if enabled (PISELH) (w)
 1025  1           (0U    <<6U) | // T12STR Timer 12 Shadow Transfer Request (w)
 1026  1           (0U    <<7U) | // T12STD Timer 12 Shadow Transfer Disable (w)
 1027  1           (1U    <<8U) | // T13RR Timer 13 Run Reset (w)
 1028  1           (0U    <<9U) | // T13RS Timer 13 Run Set (w)
 1029  1           (1U    <<10U)| // T13RES Timer 13 Reset (w)
 1030  1           (0U    <<13U)| // T13CNT Timer T13 Count Event if enabled (PISELH) (w)
 1031  1           (0U    <<14U)| // T13STR Timer 13 Shadow Transfer Request (w)
 1032  1           (0U    <<15U); // T13STD Timer 13 Shadow Transfer Disable (w)
 1033  1      
 1034  1        // restore CCU60_MCFG
 1035  1        CCU60_MCFG = Ccu60McfgSave;
 1036  1      
 1037  1        // restore CCU60_TCTR0
 1038  1        CCU60_TCTR0 = Ccu60Tctr0Save;
 1039  1      
 1040  1        // restore CCU60_TCTR2
 1041  1        CCU60_TCTR2 = Ccu60Tctr2Save;
 1042  1      
 1043  1        // restore CCU60_PISELH
 1044  1        CCU60_PISELH = Ccu60PiselhSave;
 1045  1      
C166 COMPILER V7.57.0, SCS                                                                 12/14/2020 10:56:36 PAGE 18  

 1046  1        // restore CCU60_KSCFG, enable change
 1047  1        CCU60_KSCFG = Ccu60KscfgSave |
 1048  1          ((0U    <<0U) | // MODEN Module Enable
 1049  1           (1U    <<1U) | // BPMODEN Bit Protection for MODEN, set to 1 for change (w)
 1050  1           (0U    <<4U) | // NOMCFG Normal Operation Mode Configuration
 1051  1                          // kernel mode applied in normal operation mode
 1052  1           (0U    <<7U) | // BPNOM Bit Protection for NOMCFG, set to 1 for change (w)
 1053  1           (0U    <<8U) | // SUMCFG Suspend Mode Configuration
 1054  1                          // Kernel mode applied in suspend mode
 1055  1           (0U    <<11U)| // BPSUM Bit Protection for SUMCFG, set to 1 for change (w)
 1056  1           (0U    <<12U)| // COMCFG Clock Off Mode Configuration
 1057  1                          // kernel mode applied in clock off mode
 1058  1           (0U    <<15U));// BPCOM Bit Protection for COMCFG, set to 1 for change (w)
 1059  1      
 1060  1      } // end of function SCS_RestoreTimer
 1061         
 1062         //****************************************************************************;
 1063         // @Function      SCS_ErrorType SCS_CheckFreqOscHiPrec (void)
 1064         //
 1065         //-----------------------------------------------------------------------------
 1066         // @Description   This expert level function checks the high precision
 1067         //                oscillator for valid output frequency.
 1068         //
 1069         //-----------------------------------------------------------------------------
 1070         // @Returnvalue   Error code
 1071         //
 1072         //-----------------------------------------------------------------------------
 1073         // @Parameters    None
 1074         //
 1075         //-----------------------------------------------------------------------------
 1076         // @Date          2010-4-18
 1077         //
 1078         //-----------------------------------------------------------------------------
 1079         
 1080         // USER CODE BEGIN (SCS_CheckFreqOscHiPrec,1)
 1081         
 1082         // USER CODE END
 1083         
 1084         
 1085         SCS_ErrorType SCS_CheckFreqOscHiPrec(void)
 1086         {
 1087  1         unsigned int Attempts;
 1088  1      
 1089  1         // initialize attempts
 1090  1         Attempts = (unsigned int)SCS_ATTEMPTS_OSC_HP;
 1091  1      
 1092  1         do
 1093  1         {
 1094  2           // start timer
 1095  2           SCS_StartTimer(GET_CYCLES(SCS_TIME_OSC_HP_PLLV, SCS_F_INT_10MHZ));
 1096  2      
 1097  2           // wait until oscillator is usable or time is over
 1098  2           do
 1099  2           {
 1100  3           }
 1101  2           while((!SCU_HPOSCCON_PLLV) && CCU60_TCTR0_T13R);
 1102  2      
 1103  2           if(!SCU_HPOSCCON_PLLV)
 1104  2           {
 1105  3             // timeout error
 1106  3             return SCS_STATE_TO_OSC_HP_PLLV;
 1107  3           }
C166 COMPILER V7.57.0, SCS                                                                 12/14/2020 10:56:36 PAGE 19  

 1108  2      
 1109  2           // clear status bit for high precision osc. frequency below limit
 1110  2           SCU_STATCLR1 =
 1111  2             (0U    <<0U) | // Clear PLLSTAT.VCOL0 (w)
 1112  2             (0U    <<1U) | // Clear PLLSTAT.VCOL1 (w)
 1113  2             (1U    <<2U) | // Clear HPOSCCON.OSC2L1 (w)
 1114  2             (0U    <<3U) | // Clear HPOSCCON.OSC2L0 (w)
 1115  2             (0U    <<4U) | // Set PLLSTAT.FINDIS (w)
 1116  2             (0U    <<5U) ; // Clear PLLSTAT.FINDIS (w)
 1117  2      
 1118  2      
 1119  2           // start timer, timeout for fSYS = 10 MHz
 1120  2           SCS_StartTimer(GET_CYCLES(SCS_TIME_OSC_HP_1024, SCS_F_INT_10MHZ));
 1121  2      
 1122  2           // wait until frequency error occurs, oscillator is stable or time is over
 1123  2           do
 1124  2           {
 1125  3           }
 1126  2           while((!SCU_HPOSCCON_OSC2L1) && (!SCU_PLLSTAT_OSCLOCK) && CCU60_TCTR0_T13R);
 1127  2           if(!SCU_HPOSCCON_OSC2L1 && SCU_PLLSTAT_OSCLOCK)
 1128  2           {
 1129  3             // no frequency error, oscillator is stable
 1130  3             return SCS_STATE_NO_ERROR;
 1131  3           }
 1132  2           // decrement attempts
 1133  2           Attempts--;
 1134  2         }
 1135  1         while(Attempts != 0U);
 1136  1      
 1137  1         // error: too many attempts
 1138  1         return SCS_STATE_OFW_ATTEMPTS_OSC_HP;
 1139  1      
 1140  1      }  // end of function SCS_CheckFreqOscHiPrec
 1141         
 1142         //****************************************************************************;
 1143         // @Function      SCS_ErrorType SCS_ApplyNewPDiv (unsigned int PDiv)
 1144         //
 1145         //-----------------------------------------------------------------------------
 1146         // @Description   This expert level function applies a new P divider value to
 1147         //                the PLL frequency.
 1148         //                Notes:
 1149         //                - If the divider is already set to the specified value, the
 1150         //                  function will return immediately without error.
 1151         //                - The user is responsible for disabling the register protection.
 1152         //
 1153         //-----------------------------------------------------------------------------
 1154         // @Returnvalue   Error code
 1155         //
 1156         //-----------------------------------------------------------------------------
 1157         // @Parameters    PDiv: P divider value
 1158         //
 1159         //-----------------------------------------------------------------------------
 1160         // @Date          2010-4-18
 1161         //
 1162         //-----------------------------------------------------------------------------
 1163         
 1164         // USER CODE BEGIN (SCS_ApplyNewPDiv,1)
 1165         
 1166         // USER CODE END
 1167         
 1168         
 1169         SCS_ErrorType SCS_ApplyNewPDiv(unsigned int PDiv)
C166 COMPILER V7.57.0, SCS                                                                 12/14/2020 10:56:36 PAGE 20  

 1170         {
 1171  1         if(PDiv == SCU_PLLCON1_PDIV)
 1172  1         {
 1173  2           // new value = old value: do nothing, return without error
 1174  2           return SCS_STATE_NO_ERROR;
 1175  2         }
 1176  1      
 1177  1         // clear status bit for high precision osc. frequency below limit
 1178  1         SCU_STATCLR1 =
 1179  1           (1U    <<0U) | // Clear PLLSTAT.VCOL0 (w)
 1180  1           (1U    <<1U) | // Clear PLLSTAT.VCOL1 (w)
 1181  1           (0U    <<2U) | // Clear HPOSCCON.OSC2L1 (w)
 1182  1           (0U    <<3U) | // Clear HPOSCCON.OSC2L0 (w)
 1183  1           (0U    <<4U) | // Set PLLSTAT.FINDIS (w)
 1184  1           (0U    <<5U) ; // Clear PLLSTAT.FINDIS (w)
 1185  1      
 1186  1         // set P divider value. clear P acknowledge
 1187  1         // leave bits PLLPWD, OSCSEL, AOSCSEL, EMCLKEN, EMFINDISEN unchanged
 1188  1         SCU_PLLCON1 = 
 1189  1           (SCU_PLLCON1 & ((1U <<0U)|(1U <<1U)|(1U <<3U)|(1U <<5U)|(1U <<6U))) | 
 1190  1          ((0U    <<0U) | // PLLPWD PLL Power Saving Mode
 1191  1                          // 0: Normal behavior
 1192  1                          // 1: PLL block is put into power saving mode
 1193  1           (0U    <<1U) | // OSCSEL Oscillator Input Selection
 1194  1                          // 0: PLL external oscillator
 1195  1                          // 1: PLL internal oscillator
 1196  1           (0U    <<2U) | // RESLD Restart VCO Lock Detection (w)
 1197  1                          // Resets PLLSTAT.VCOLOCK and restarts VCO lock detection
 1198  1           (0U    <<3U) | // AOSCSEL Asynchronous Oscillator Input Selection
 1199  1                          // 0: Configuration is controlled via bit OSCSEL
 1200  1                          // 1: PLL internal clock is selected asynchronously
 1201  1           (0U    <<5U) | // EMCLKEN VCOLCK Emergency System Clock Source Select Enable
 1202  1                          // 0: MCM controlled by SYSCON0.CLKSEL in VCOLCK emergency case
 1203  1                          // 1: MCM controlled by SYSCON0.EMCLKSEL in VCOLCK emergency case
 1204  1           (0U    <<6U) | // EMFINDISEN Emergency Input Clock Disconnect Enable
 1205  1                          // 0: PLLSTAT.FINDIS not updated in VCOLCK emergency case
 1206  1                          // 1: PLLSTAT.FINDIS is set in VCOLCK emergency case
 1207  1           (PDiv  <<8U) | // PDIV P-Divider Value
 1208  1                          // 0..15: P-Divider = PDIV + 1
 1209  1           (0U    <<15U));// PACK P-Divider Ready Acknowledge
 1210  1                          // Provides acknowledge to PRDY
 1211  1      
 1212  1         // wait until P acknowledge = 0 with timeout
 1213  1         if(PLLSTAT_COND_3(SCU_PLLSTAT_PRDY))
 1214  1         {
 1215  2           return SCS_STATE_TO_PDIV;
 1216  2         }
 1217  1      
 1218  1         // set P acknowledge
 1219  1         // SCU_PLLCON1_PACK = 1U; ; not available depending on SFR file
 1220  1         SCU_PLLCON1 |= (1U <<15U);
 1221  1      
 1222  1         // wait until P acknowledge = 1 with timeout
 1223  1         if(PLLSTAT_COND_3(!SCU_PLLSTAT_PRDY))
 1224  1         {
 1225  2           return SCS_STATE_TO_PDIV;
 1226  2         }
 1227  1      
 1228  1         // no error
 1229  1         return SCS_STATE_NO_ERROR;
 1230  1      
 1231  1      }  // end of function SCS_ApplyNewPDiv
C166 COMPILER V7.57.0, SCS                                                                 12/14/2020 10:56:36 PAGE 21  

 1232         
 1233         //****************************************************************************;
 1234         // @Function      SCS_ErrorType SCS_ApplyNewNDiv (unsigned int NDiv)
 1235         //
 1236         //-----------------------------------------------------------------------------
 1237         // @Description   This expert level function applies a new N divider value to
 1238         //                the PLL frequency.
 1239         //                Notes:
 1240         //                - If the divider is already set to the specified value, the
 1241         //                  function will return immediately without error.
 1242         //                - The user is responsible for disabling the register protection.
 1243         //
 1244         //-----------------------------------------------------------------------------
 1245         // @Returnvalue   Error code
 1246         //
 1247         //-----------------------------------------------------------------------------
 1248         // @Parameters    NDiv: N divider value
 1249         //
 1250         //-----------------------------------------------------------------------------
 1251         // @Date          2010-4-18
 1252         //
 1253         //-----------------------------------------------------------------------------
 1254         
 1255         // USER CODE BEGIN (SCS_ApplyNewNDiv,1)
 1256         
 1257         // USER CODE END
 1258         
 1259         
 1260         SCS_ErrorType SCS_ApplyNewNDiv(unsigned int NDiv)
 1261         {
 1262  1         if(NDiv == SCU_PLLCON0_NDIV)
 1263  1         {
 1264  2           // new value = old value: do nothing, return without error
 1265  2           return SCS_STATE_NO_ERROR;
 1266  2         }
 1267  1      
 1268  1         // clear VCO Lock Detection Lost and VCO Lock Detection Reached
 1269  1         SCU_STATCLR1 =
 1270  1           (1U    <<0U) | // Clear PLLSTAT.VCOL0 (w)
 1271  1           (1U    <<1U) | // Clear PLLSTAT.VCOL1 (w)
 1272  1           (0U    <<2U) | // Clear HPOSCCON.OSC2L1 (w)
 1273  1           (0U    <<3U) | // Clear HPOSCCON.OSC2L0 (w)
 1274  1           (0U    <<4U) | // Set PLLSTAT.FINDIS (w)
 1275  1           (0U    <<5U) ; // Clear PLLSTAT.FINDIS (w)
 1276  1      
 1277  1         // set N divider value. clear N acknowledge
 1278  1         // leave bits VCOBY, VCOPWD, VCOSEL unchanged
 1279  1         SCU_PLLCON0 = (SCU_PLLCON0 & ((1U <<0U)|(1U <<1U)|(1U <<2U))) |
 1280  1          ((0U    <<0U) | // VCOBY Bypass
 1281  1                          // 0: Normal operation, VCO is not bypassed
 1282  1                          // 1: Prescaler Mode; VCO is bypassed
 1283  1           (0U    <<1U) | // VCOPWD VCO Power Saving Mode
 1284  1                          // 0: Normal behavior
 1285  1                          // 1: VCO is put into power saving mode
 1286  1           (0U    <<2U) | // VCOSEL VCO Range Select
 1287  1                          // 0: 48...112 MHz
 1288  1                          // 1: 96...160 MHz
 1289  1           (0U    <<4U) | // REGENCLR PLL Power Regulator Enable Clear (w)
 1290  1                          // 0: Configuration for PLL power regulator  unchanged
 1291  1                          // 1: PLL is not powered (no operation possible)
 1292  1           (0U    <<5U) | // REGENSET PLL Power Regulator Enable Set (w)
 1293  1                          // 0: Configuration for PLL power regulator unchanged
C166 COMPILER V7.57.0, SCS                                                                 12/14/2020 10:56:36 PAGE 22  

 1294  1                          // 1: PLL is powered (operation possible)
 1295  1           (NDiv  <<8U) | // NDIV N-Divider Value
 1296  1                          // 0..63: N-Divider = NDIV + 1
 1297  1           (0U    <<15U));// NACK N-Divider Ready Acknowledge
 1298  1                          // Provides acknowledge to NRDY
 1299  1      
 1300  1         // wait until N acknowledge = 0 with timeout
 1301  1         if(PLLSTAT_COND_3(SCU_PLLSTAT_NRDY))
 1302  1         {
 1303  2           return SCS_STATE_TO_NDIV;
 1304  2         }
 1305  1      
 1306  1         // set N acknowledge
 1307  1         // SCU_PLLCON0_NACK = 1U; not available depending on SFR file
 1308  1         SCU_PLLCON0 |= (1U <<15U);
 1309  1      
 1310  1         // wait until N acknowledge = 1 with timeout
 1311  1         if(PLLSTAT_COND_3(!SCU_PLLSTAT_NRDY))
 1312  1         {
 1313  2           return SCS_STATE_TO_NDIV;
 1314  2         }
 1315  1      
 1316  1         // no error
 1317  1         return SCS_STATE_NO_ERROR;
 1318  1      
 1319  1      }  // end of function SCS_ApplyNewNDiv
 1320         
 1321         //****************************************************************************;
 1322         // @Function      SCS_ErrorType SCS_ApplyNewK1Div (unsigned int K1Div)
 1323         //
 1324         //-----------------------------------------------------------------------------
 1325         // @Description   This expert level function applies a new K1 divider value to
 1326         //                the PLL frequency.
 1327         //                Notes:
 1328         //                - If the divider is already set to the specified value, the
 1329         //                  function will return immediately without error.
 1330         //                - The user is responsible for disabling the register protection.
 1331         //
 1332         //-----------------------------------------------------------------------------
 1333         // @Returnvalue   Error code
 1334         //
 1335         //-----------------------------------------------------------------------------
 1336         // @Parameters    K1Div: K1 divider value
 1337         //
 1338         //-----------------------------------------------------------------------------
 1339         // @Date          2010-4-18
 1340         //
 1341         //-----------------------------------------------------------------------------
 1342         
 1343         // USER CODE BEGIN (SCS_ApplyNewK1Div,1)
 1344         
 1345         // USER CODE END
 1346         
 1347         
 1348         SCS_ErrorType SCS_ApplyNewK1Div(unsigned int K1Div)
 1349         {
 1350  1         if(K1Div == SCU_PLLCON2_K1DIV)
 1351  1         {
 1352  2           // new value = old value: do nothing, return without error
 1353  2           return SCS_STATE_NO_ERROR;
 1354  2         }
 1355  1      
C166 COMPILER V7.57.0, SCS                                                                 12/14/2020 10:56:36 PAGE 23  

 1356  1         // set K1 divider value, clear K1 acknowledge 
 1357  1         SCU_PLLCON2 = 
 1358  1           (K1Div <<0U) | // K1DIV K1-Divider Value
 1359  1                          // 0..511: K1-Divider = K1DIV + 1
 1360  1           (0U    <<15U); // K1ACK K1-Divider Ready Acknowledge
 1361  1                          // Provides acknowledge to K1RDY
 1362  1      
 1363  1         // wait until K1 acknowledge = 0 with timeout
 1364  1         if(PLLSTAT_COND_3(SCU_PLLSTAT_K1RDY))
 1365  1         {
 1366  2           return SCS_STATE_TO_K1DIV;
 1367  2         }
 1368  1      
 1369  1         // set K1 acknowledge
 1370  1         SCU_PLLCON2_K1ACK = 1U;
 1371  1      
 1372  1         // wait until K1 acknowledge = 1 with timeout
 1373  1         if(PLLSTAT_COND_3(!SCU_PLLSTAT_K1RDY))
 1374  1         {
 1375  2           return SCS_STATE_TO_K1DIV;
 1376  2         }
 1377  1      
 1378  1         // no error
 1379  1         return SCS_STATE_NO_ERROR;
 1380  1      
 1381  1      }  // end of function SCS_ApplyNewK1Div
 1382         
 1383         //****************************************************************************;
 1384         // @Function      SCS_ErrorType SCS_ApplyNewK2Div (unsigned int K2Div)
 1385         //
 1386         //-----------------------------------------------------------------------------
 1387         // @Description   This expert level function applies a new K2 divider value to
 1388         //                the PLL frequency.
 1389         //                Notes:
 1390         //                - If the divider is already set to the specified value, the
 1391         //                  function will return immediately without error.
 1392         //                - The user is responsible for disabling the register protection.
 1393         //
 1394         //-----------------------------------------------------------------------------
 1395         // @Returnvalue   Error code
 1396         //
 1397         //-----------------------------------------------------------------------------
 1398         // @Parameters    K2Div: K2 divider value
 1399         //
 1400         //-----------------------------------------------------------------------------
 1401         // @Date          2010-4-18
 1402         //
 1403         //-----------------------------------------------------------------------------
 1404         
 1405         // USER CODE BEGIN (SCS_ApplyNewK2Div,1)
 1406         
 1407         // USER CODE END
 1408         
 1409         
 1410         SCS_ErrorType SCS_ApplyNewK2Div(unsigned int K2Div)
 1411         {
 1412  1         if(K2Div == SCU_PLLCON3_K2DIV)
 1413  1         {
 1414  2           // new value = old value: do nothing, return without error
 1415  2           return SCS_STATE_NO_ERROR;
 1416  2         }
 1417  1      
C166 COMPILER V7.57.0, SCS                                                                 12/14/2020 10:56:36 PAGE 24  

 1418  1         // set K2 divider value, clear K2 acknowledge 
 1419  1         SCU_PLLCON3 = 
 1420  1           (K2Div <<0U) | // K2DIV K2-Divider Value
 1421  1                          // 0..511: K2-Divider = K2DIV + 1
 1422  1           (0U    <<15U); // K2ACK K2-Divider Ready Acknowledge
 1423  1                          // Provides acknowledge to K2RDY
 1424  1      
 1425  1         // wait until K2 acknowledge = 0 with timeout
 1426  1         if(PLLSTAT_COND_3(SCU_PLLSTAT_K2RDY))
 1427  1         {
 1428  2           return SCS_STATE_TO_K2DIV;
 1429  2         }
 1430  1      
 1431  1         // set K2 acknowledge
 1432  1         // SCU_PLLCON3_K2ACK = 1U; not available depending on SFR file
 1433  1         SCU_PLLCON3 |= (1U <<15U);
 1434  1      
 1435  1         // wait until K2 acknowledge = 1 with timeout
 1436  1         if(PLLSTAT_COND_3(!SCU_PLLSTAT_K2RDY))
 1437  1         {
 1438  2           return SCS_STATE_TO_K2DIV;
 1439  2         }
 1440  1      
 1441  1         // no error
 1442  1         return SCS_STATE_NO_ERROR;
 1443  1      
 1444  1      }  // end of function SCS_ApplyNewK2Div
 1445         
 1446         //****************************************************************************;
 1447         // @Function      SCS_ErrorType SCS_SelectVcoSrcOscHiPrec (void)
 1448         //
 1449         //-----------------------------------------------------------------------------
 1450         // @Description   This expert level function selects the high precision 
 1451         //                oscillator as the source for the VCO.
 1452         //                Notes:
 1453         //                - The user is responsible for disabling the register protection.
 1454         //
 1455         //-----------------------------------------------------------------------------
 1456         // @Returnvalue   Error code
 1457         //
 1458         //-----------------------------------------------------------------------------
 1459         // @Parameters    None
 1460         //
 1461         //-----------------------------------------------------------------------------
 1462         // @Date          2010-4-18
 1463         //
 1464         //-----------------------------------------------------------------------------
 1465         
 1466         // USER CODE BEGIN (SCS_SelectVcoSrcOscHiPrec,1)
 1467         
 1468         // USER CODE END
 1469         
 1470         
 1471         SCS_ErrorType SCS_SelectVcoSrcOscHiPrec(void)
 1472         
 1473         {
 1474  1         // clear OSCSEL. clear AOSCSEL, leave other bits unchanged
 1475  1         SCU_PLLCON1 &=
 1476  1           (1U    <<0U) | // PLLPWD PLL Power Saving Mode
 1477  1                          // 0: Normal behavior
 1478  1                          // 1: PLL block is put into power saving mode
 1479  1           (0U    <<1U) | // OSCSEL Oscillator Input Selection
C166 COMPILER V7.57.0, SCS                                                                 12/14/2020 10:56:36 PAGE 25  

 1480  1                          // 0: PLL external oscillator
 1481  1                          // 1: PLL internal oscillator
 1482  1           (1U    <<2U) | // RESLD Restart VCO Lock Detection (w)
 1483  1                          // Resets PLLSTAT.VCOLOCK and restarts VCO lock detection
 1484  1           (0U    <<3U) | // AOSCSEL Asynchronous Oscillator Input Selection
 1485  1                          // 0: Configuration is controlled via bit OSCSEL
 1486  1                          // 1: PLL internal clock is selected asynchronously
 1487  1           (1U    <<5U) | // EMCLKEN VCOLCK Emergency System Clock Source Select Enable
 1488  1                          // 0: MCM controlled by SYSCON0.CLKSEL in VCOLCK emergency case
 1489  1                          // 1: MCM controlled by SYSCON0.EMCLKSEL in VCOLCK emergency case
 1490  1           (1U    <<6U) | // EMFINDISEN Emergency Input Clock Disconnect Enable
 1491  1                          // 0: PLLSTAT.FINDIS not updated in VCOLCK emergency case
 1492  1                          // 1: PLLSTAT.FINDIS is set in VCOLCK emergency case
 1493  1           (0xFU  <<8U) | // PDIV P-Divider Value
 1494  1                          // 0..15: P-Divider = PDIV + 1
 1495  1           (1U    <<15U); // PACK P-Divider Ready Acknowledge
 1496  1                          // Provides acknowledge to PRDY
 1497  1      
 1498  1         // wait until high precision oscillator is selected (OSCSELST = 0), with timeout
 1499  1         if(PLLSTAT_COND_3(SCU_PLLSTAT_OSCSELST))
 1500  1         {
 1501  2           return SCS_STATE_TO_OSC_HP_SEL;
 1502  2         }
 1503  1      
 1504  1         // no error
 1505  1         return SCS_STATE_NO_ERROR;
 1506  1      
 1507  1      }  // end of function SCS_SelectVcoSrcOscHiPrec
 1508         
 1509         //****************************************************************************;
 1510         // @Function      SCS_ErrorType SCS_EnableVcoLockEmerg (void)
 1511         //
 1512         //-----------------------------------------------------------------------------
 1513         // @Description   This expert level function enables the VCO loss-of-lock
 1514         //                emergency handling.
 1515         //
 1516         //-----------------------------------------------------------------------------
 1517         // @Returnvalue   Error code
 1518         //
 1519         //-----------------------------------------------------------------------------
 1520         // @Parameters    None
 1521         //
 1522         //-----------------------------------------------------------------------------
 1523         // @Date          2010-4-18
 1524         //
 1525         //-----------------------------------------------------------------------------
 1526         
 1527         // USER CODE BEGIN (SCS_EnableVcoLockEmerg,1)
 1528         
 1529         // USER CODE END
 1530         
 1531         
 1532         SCS_ErrorType SCS_EnableVcoLockEmerg(void)
 1533         
 1534         {
 1535  1         unsigned int Work;
 1536  1      
 1537  1         if(!SCU_PLLSTAT_VCOLOCK)
 1538  1         {
 1539  2           // VCO unlocked
 1540  2           return SCS_STATE_VCO_UNLOCKED;
 1541  2         }
C166 COMPILER V7.57.0, SCS                                                                 12/14/2020 10:56:36 PAGE 26  

 1542  1      
 1543  1         // clear VCO Lock Detection Lost and VCO Lock Detection Reached
 1544  1         SCU_STATCLR1 =
 1545  1           (1U    <<0U) | // Clear PLLSTAT.VCOL0 (w)
 1546  1           (1U    <<1U) | // Clear PLLSTAT.VCOL1 (w)
 1547  1           (0U    <<2U) | // Clear HPOSCCON.OSC2L1 (w)
 1548  1           (0U    <<3U) | // Clear HPOSCCON.OSC2L0 (w)
 1549  1           (0U    <<4U) | // Set PLLSTAT.FINDIS (w)
 1550  1           (0U    <<5U) ; // Clear PLLSTAT.FINDIS (w)
 1551  1      
 1552  1        // disable emergency clock selection
 1553  1        SCU_PLLCON1_EMCLKEN = 0U;
 1554  1      
 1555  1        // disable emergency clock selection
 1556  1        SCU_SYSCON0_EMCLKSELEN = 0U;
 1557  1      
 1558  1         // clear loss-of-lock emergency state
 1559  1         SCU_STATCLR0 =
 1560  1           (0U    <<12U) | // Clear bit SYSCON0.EMSOSC (w)
 1561  1           (1U    <<13U) ; // Clear bit SYSCON0.EMSVCO (w)
 1562  1      
 1563  1        // enable emergency input clock disconnection
 1564  1        SCU_PLLCON1_EMFINDISEN = 1U;
 1565  1      
 1566  1        // clear VCOLCK Trap Request Flag
 1567  1        SCU_TRAPCLR =
 1568  1          (0U    <<0U) | // FAT Clear Flash Access Trap Request
 1569  1          (0U    <<1U) | // ESR0T Clear ESR0 Trap Request
 1570  1          (0U    <<2U) | // ESR1T Clear ESR1 Trap Request
 1571  1          (0U    <<3U) | // ESR2T Clear ESR2 Trap Request
 1572  1          (0U    <<4U) | // OSCWDTT Clear OSCWDT Trap Request
 1573  1          (0U    <<5U) | // RAT Clear Register Access Trap Request
 1574  1          (0U    <<6U) | // PET Clear Register Parity Error Trap Request
 1575  1          (1U    <<7U) ; // VCOLCKT Clear VCOLCK Trap Request
 1576  1      
 1577  1        // enable VCOLCK trap request
 1578  1        SCU_TRAPDIS &=
 1579  1         ((1U    <<0U) | // FAT Disable Flash Access Trap Request
 1580  1          (1U    <<1U) | // ESR0T Disable ESR0 Trap Request
 1581  1          (1U    <<2U) | // ESR1T Disable ESR1 Trap Request
 1582  1          (1U    <<3U) | // ESR2T Disable ESR2 Trap Request
 1583  1          (1U    <<4U) | // OSCWDTT Disable OSCWDT Trap Request
 1584  1          (1U    <<5U) | // RAT Disable Register Access Trap Request
 1585  1          (1U    <<6U) | // PET Disable Register Parity Error Trap Request
 1586  1          (0U    <<7U)); // VCOLCKT Disable VCOLCK Trap Request
 1587  1      
 1588  1        Work = SCU_PLLSTAT;
 1589  1      
 1590  1        if((Work &
 1591  1         ((0U    <<0U) | // VCOBYST VCO Bypass Status Freerunning/Normal (rh)
 1592  1          (0U    <<1U) | // PWDSTAT Power-saving Mode Status (rh)
 1593  1          (0U    <<2U) | // OSCSELST Oscillator Input Selection Status OSC_PLL (rh)
 1594  1          (0U    <<3U) | // VCOLOCK PLL VCO Lock Status (rh)
 1595  1          (0U    <<4U) | // BY Bypass Mode Status (rh)
 1596  1          (0U    <<5U) | // PRDY P-Divider Ready Status (rh)
 1597  1          (0U    <<6U) | // NRDY N-Divider Ready Status (rh)
 1598  1          (0U    <<7U) | // K1RDY K1-Divider Ready Status (rh)
 1599  1          (0U    <<8U) | // K2RDY K1-Divider Ready Status (rh)
 1600  1          (0U    <<9U) | // FINDIS Input Clock Disconnect Select Status (rh)
 1601  1          (1U    <<10U)| // VCOL0 VCO Lock Detection Lost Status (rh)
 1602  1          (1U    <<11U)| // VCOL1 VCO Lock Detection Reached Status (rh)
 1603  1          (0U    <<12U)))// REGSTAT PLL Power Regulator Status powered (operation possible) (rh)
C166 COMPILER V7.57.0, SCS                                                                 12/14/2020 10:56:36 PAGE 27  

 1604  1          || (!(Work &
 1605  1          (1U    <<3U))))// VCOLOCK PLL VCO Lock Status (rh)
 1606  1      
 1607  1          {
 1608  2            // VCOL0 = 1 or VCOL1 = 1 or VCOLOCK = 0: VCO unlocked
 1609  2            return SCS_STATE_VCO_UNLOCKED;
 1610  2          }
 1611  1      
 1612  1         // no error
 1613  1         return SCS_STATE_NO_ERROR;
 1614  1      
 1615  1      }  // end of function SCS_EnableVcoLockEmerg
 1616         
 1617         //****************************************************************************;
 1618         // @Function      SCS_ErrorType SCS_DisableVcoBypass (void)
 1619         //
 1620         //-----------------------------------------------------------------------------
 1621         // @Description   This expert level function disables VCO bypass.
 1622         //                Notes:
 1623         //                - The user is responsible for disabling the register protection.
 1624         //
 1625         //-----------------------------------------------------------------------------
 1626         // @Returnvalue   Error code
 1627         //
 1628         //-----------------------------------------------------------------------------
 1629         // @Parameters    None
 1630         //
 1631         //-----------------------------------------------------------------------------
 1632         // @Date          2010-4-18
 1633         //
 1634         //-----------------------------------------------------------------------------
 1635         
 1636         // USER CODE BEGIN (SCS_DisableVcoBypass,1)
 1637         
 1638         // USER CODE END
 1639         
 1640         
 1641         SCS_ErrorType SCS_DisableVcoBypass(void)
 1642         
 1643         {
 1644  1         // disable VCO bypass
 1645  1         SCU_PLLCON0_VCOBY = 0U;
 1646  1      
 1647  1         // wait until VCO bypass status = 1 with timeout
 1648  1         if(PLLSTAT_COND_3(!SCU_PLLSTAT_VCOBYST))
 1649  1         {
 1650  2           return SCS_STATE_TO_VCOBYST;
 1651  2         }
 1652  1      
 1653  1      
 1654  1         // no error
 1655  1         return SCS_STATE_NO_ERROR;
 1656  1      
 1657  1      }  // end of function SCS_DisableVcoBypass
 1658         
 1659         //****************************************************************************;
 1660         // @Function      SCS_ErrorType SCS_EnableVcoBypass (void)
 1661         //
 1662         //-----------------------------------------------------------------------------
 1663         // @Description   This expert level function enables VCO bypass.
 1664         //                Notes:
 1665         //                - The user is responsible for disabling the register protection.
C166 COMPILER V7.57.0, SCS                                                                 12/14/2020 10:56:36 PAGE 28  

 1666         //
 1667         //-----------------------------------------------------------------------------
 1668         // @Returnvalue   Error code
 1669         //
 1670         //-----------------------------------------------------------------------------
 1671         // @Parameters    None
 1672         //
 1673         //-----------------------------------------------------------------------------
 1674         // @Date          2010-4-18
 1675         //
 1676         //-----------------------------------------------------------------------------
 1677         
 1678         // USER CODE BEGIN (SCS_EnableVcoBypass,1)
 1679         
 1680         // USER CODE END
 1681         
 1682         
 1683         SCS_ErrorType SCS_EnableVcoBypass(void)
 1684         
 1685         {
 1686  1         // enable VCO bypass
 1687  1         SCU_PLLCON0_VCOBY = 1U;
 1688  1      
 1689  1         // wait until VCO bypass status = 0 with timeout
 1690  1         if(PLLSTAT_COND_3(SCU_PLLSTAT_VCOBYST))
 1691  1         {
 1692  2           return SCS_STATE_TO_VCOBYST;
 1693  2         }
 1694  1      
 1695  1      
 1696  1         // no error
 1697  1         return SCS_STATE_NO_ERROR;
 1698  1      
 1699  1      }  // end of function SCS_EnableVcoBypass
C166 COMPILER V7.57.0, SCS                                                                 12/14/2020 10:56:36 PAGE 29  

ASSEMBLY LISTING OF GENERATED OBJECT CODE


             ; FUNCTION SCS_EnableOscHiPrecCrystal (BEGIN  RMASK = @0x8000)
                                           ; SOURCE LINE # 249
                                           ; SOURCE LINE # 287
0000 D180          EXTR      #01H
0002 66DA8006      AND       SCU_HPOSCCON,#0680H
                                           ; SOURCE LINE # 291
0006 DB00          RETS      
             ; FUNCTION SCS_EnableOscHiPrecCrystal (END    RMASK = @0x8000)

             ; FUNCTION SCS_RestartVcoLockDetect (BEGIN  RMASK = @0x4000)
                                           ; SOURCE LINE # 318
                                           ; SOURCE LINE # 322
0008 D180          EXTR      #01H
000A 2FDD          BSET      SCU_PLLCON1_RESLD
                                           ; SOURCE LINE # 326
000C DB00          RETS      
             ; FUNCTION SCS_RestartVcoLockDetect (END    RMASK = @0x4000)

             ; FUNCTION SCS_DisconnectVcoInput (BEGIN  RMASK = @0x8000)
                                           ; SOURCE LINE # 354
                                           ; SOURCE LINE # 363
000E D180          EXTR      #01H
0010 E6711000      MOV       SCU_STATCLR1,#010H
                                           ; SOURCE LINE # 365
0014 DB00          RETS      
             ; FUNCTION SCS_DisconnectVcoInput (END    RMASK = @0x8000)

             ; FUNCTION SCS_ConnectVcoInput (BEGIN  RMASK = @0x8000)
                                           ; SOURCE LINE # 393
                                           ; SOURCE LINE # 402
0016 D180          EXTR      #01H
0018 E6712000      MOV       SCU_STATCLR1,#020H
                                           ; SOURCE LINE # 404
001C DB00          RETS      
             ; FUNCTION SCS_ConnectVcoInput (END    RMASK = @0x8000)

             ; FUNCTION SCS_SelectVcoBand (BEGIN  RMASK = @0x4010)
                                           ; SOURCE LINE # 431
;---- Variable 'VcoBand' assigned to Register 'R8' ----
                                           ; SOURCE LINE # 434
001E F048          MOV       R4,R8
0020 3A88F430      BMOVN     R4.0,Z
0024 D180          EXTR      #01H
0026 4AF4DC02      BMOV      SCU_PLLCON0_VCOSEL,R4.0
                                           ; SOURCE LINE # 436
002A DB00          RETS      
             ; FUNCTION SCS_SelectVcoBand (END    RMASK = @0x4010)

             ; FUNCTION SCS_StartTimer (BEGIN  RMASK = @0x4110)
                                           ; SOURCE LINE # 465
;---- Variable 'Cycles' assigned to Register 'R8' ----
                                           ; SOURCE LINE # 481
002C E6F40005      MOV       R4,#0500H
0030 F6F426EA      MOV       0EA26H,R4
                                           ; SOURCE LINE # 484
0034 4883          CMP       R8,#03H
0036 9D01          JMPR      cc_UGE,?C0001
                                           ; SOURCE LINE # 486
0038 E038          MOV       R8,#03H
C166 COMPILER V7.57.0, SCS                                                                 12/14/2020 10:56:36 PAGE 30  

                                           ; SOURCE LINE # 487
003A         ?C0001:
                                           ; SOURCE LINE # 490
003A F048          MOV       R4,R8
003C 2842          SUB       R4,#02H
003E F6F432EA      MOV       0EA32H,R4
                                           ; SOURCE LINE # 506
0042 E6F40040      MOV       R4,#04000H
0046 F6F426EA      MOV       0EA26H,R4
                                           ; SOURCE LINE # 522
004A E6F40002      MOV       R4,#0200H
004E F6F426EA      MOV       0EA26H,R4
                                           ; SOURCE LINE # 524
0052 DB00          RETS      
             ; FUNCTION SCS_StartTimer (END    RMASK = @0x4110)

             ; FUNCTION SCS_DelayByTimer (BEGIN  RMASK = @0x4110)
                                           ; SOURCE LINE # 553
;---- Variable 'Cycles' assigned to Register 'R8' ----
                                           ; SOURCE LINE # 556
;---- Variable 'Cycles?1?SCS_StartTimer' assigned to Register 'R8' ----
                                           ; SOURCE LINE # 481
0054 E6F40005      MOV       R4,#0500H
0058 F6F426EA      MOV       0EA26H,R4
                                           ; SOURCE LINE # 484
005C 4883          CMP       R8,#03H
005E 9D01          JMPR      cc_UGE,?C0002
                                           ; SOURCE LINE # 486
0060 E038          MOV       R8,#03H
                                           ; SOURCE LINE # 487
0062         ?C0002:
                                           ; SOURCE LINE # 490
0062 F048          MOV       R4,R8
0064 2842          SUB       R4,#02H
0066 F6F432EA      MOV       0EA32H,R4
                                           ; SOURCE LINE # 506
006A E6F40040      MOV       R4,#04000H
006E F6F426EA      MOV       0EA26H,R4
                                           ; SOURCE LINE # 522
0072 E6F40002      MOV       R4,#0200H
0076 F6F426EA      MOV       0EA26H,R4
                                           ; SOURCE LINE # 559
                                           ; SOURCE LINE # 561
007A         ?C0005:
007A F2F42CEA      MOV       R4,0EA2CH
007E 8AF4FCC0      JB        R4.12,?C0005
0082         ?C0006:
                                           ; SOURCE LINE # 564
0082 DB00          RETS      
             ; FUNCTION SCS_DelayByTimer (END    RMASK = @0x4110)

             ; FUNCTION SCS_RampUpPllInNormalMode (BEGIN  RMASK = @0x7FFF)
                                           ; SOURCE LINE # 593
0084 ECFD          PUSH      R13
                                           ; SOURCE LINE # 594
                                           ; SOURCE LINE # 599
0086 E068          MOV       R8,#06H
0088 DA000000 R    CALLS     SEG (SCS_ApplyNewK2Div),SCS_ApplyNewK2Div
008C F0D4          MOV       R13,R4
;---- Variable 'Error' assigned to Register 'R13' ----
                                           ; SOURCE LINE # 600
008E 48D0          CMP       R13,#00H
C166 COMPILER V7.57.0, SCS                                                                 12/14/2020 10:56:36 PAGE 31  

0090 2D01          JMPR      cc_Z,?C0007
                                           ; SOURCE LINE # 602
0092 0D20          JMPR      cc_UC,?C0008
                                           ; SOURCE LINE # 603
0094         ?C0007:
                                           ; SOURCE LINE # 607
0094 E088          MOV       R8,#08H
0096 DA000000 R    CALLS     SEG (SCS_DelayByTimer),SCS_DelayByTimer
                                           ; SOURCE LINE # 610
009A E038          MOV       R8,#03H
009C DA000000 R    CALLS     SEG (SCS_ApplyNewK2Div),SCS_ApplyNewK2Div
00A0 F0D4          MOV       R13,R4
                                           ; SOURCE LINE # 611
00A2 48D0          CMP       R13,#00H
00A4 2D01          JMPR      cc_Z,?C0009
                                           ; SOURCE LINE # 613
00A6 0D16          JMPR      cc_UC,?C0008
                                           ; SOURCE LINE # 614
00A8         ?C0009:
                                           ; SOURCE LINE # 618
00A8 E0D8          MOV       R8,#0DH
00AA DA000000 R    CALLS     SEG (SCS_DelayByTimer),SCS_DelayByTimer
                                           ; SOURCE LINE # 621
00AE E028          MOV       R8,#02H
00B0 DA000000 R    CALLS     SEG (SCS_ApplyNewK2Div),SCS_ApplyNewK2Div
00B4 F0D4          MOV       R13,R4
                                           ; SOURCE LINE # 622
00B6 48D0          CMP       R13,#00H
00B8 2D01          JMPR      cc_Z,?C0010
                                           ; SOURCE LINE # 624
00BA 0D0C          JMPR      cc_UC,?C0008
                                           ; SOURCE LINE # 625
00BC         ?C0010:
                                           ; SOURCE LINE # 627
00BC E6F81100      MOV       R8,#011H
00C0 DA000000 R    CALLS     SEG (SCS_DelayByTimer),SCS_DelayByTimer
                                           ; SOURCE LINE # 641
00C4 E018          MOV       R8,#01H
00C6 DA000000 R    CALLS     SEG (SCS_ApplyNewK2Div),SCS_ApplyNewK2Div
00CA F0D4          MOV       R13,R4
                                           ; SOURCE LINE # 642
00CC 48D0          CMP       R13,#00H
00CE 2D01          JMPR      cc_Z,?C0011
                                           ; SOURCE LINE # 644
00D0 0D01          JMPR      cc_UC,?C0008
                                           ; SOURCE LINE # 645
00D2         ?C0011:
                                           ; SOURCE LINE # 648
00D2 E004          MOV       R4,#00H
                                           ; SOURCE LINE # 650
00D4         ?C0008:
00D4 FCFD          POP       R13
00D6 DB00          RETS      
             ; FUNCTION SCS_RampUpPllInNormalMode (END    RMASK = @0x7FFF)

             ; FUNCTION SCS_GoFromBaseToNormalMode (BEGIN  RMASK = @0x7FFF)
                                           ; SOURCE LINE # 679
00D8 ECFD          PUSH      R13
                                           ; SOURCE LINE # 680
                                           ; SOURCE LINE # 287
00DA D180          EXTR      #01H
00DC 66DA8006      AND       SCU_HPOSCCON,#0680H
C166 COMPILER V7.57.0, SCS                                                                 12/14/2020 10:56:36 PAGE 32  

                                           ; SOURCE LINE # 687
00E0 DA000000 R    CALLS     SEG (SCS_CheckFreqOscHiPrec),SCS_CheckFreqOscHiPrec
00E4 F0D4          MOV       R13,R4
;---- Variable 'Error' assigned to Register 'R13' ----
                                           ; SOURCE LINE # 688
00E6 48D0          CMP       R13,#00H
00E8 2D01          JMPR      cc_Z,?C0012
                                           ; SOURCE LINE # 690
00EA 0D7C          JMPR      cc_UC,?C0013
                                           ; SOURCE LINE # 691
00EC         ?C0012:
                                           ; SOURCE LINE # 694
00EC E008          MOV       R8,#00H
00EE DA000000 R    CALLS     SEG (SCS_ApplyNewK1Div),SCS_ApplyNewK1Div
00F2 F0D4          MOV       R13,R4
                                           ; SOURCE LINE # 695
00F4 48D0          CMP       R13,#00H
00F6 2D01          JMPR      cc_Z,?C0014
                                           ; SOURCE LINE # 697
00F8 0D75          JMPR      cc_UC,?C0013
                                           ; SOURCE LINE # 698
00FA         ?C0014:
                                           ; SOURCE LINE # 701
00FA DA000000 R    CALLS     SEG (SCS_EnableVcoBypass),SCS_EnableVcoBypass
00FE F0D4          MOV       R13,R4
                                           ; SOURCE LINE # 702
0100 48D0          CMP       R13,#00H
0102 2D01          JMPR      cc_Z,?C0015
                                           ; SOURCE LINE # 704
0104 0D6F          JMPR      cc_UC,?C0013
                                           ; SOURCE LINE # 705
0106         ?C0015:
                                           ; SOURCE LINE # 707
0106 D180          EXTR      #01H
0108 8ADC0C20      JB        SCU_PLLCON0_VCOSEL,?C0016
                                           ; SOURCE LINE # 711
                                           ; SOURCE LINE # 434
010C E014          MOV       R4,#01H
010E 6044          AND       R4,R4
0110 3A88F430      BMOVN     R4.0,Z
0114 D180          EXTR      #01H
0116 4AF4DC02      BMOV      SCU_PLLCON0_VCOSEL,R4.0
                                           ; SOURCE LINE # 714
011A E6F83100      MOV       R8,#031H
011E DA000000 R    CALLS     SEG (SCS_DelayByTimer),SCS_DelayByTimer
                                           ; SOURCE LINE # 715
0122 0D07          JMPR      cc_UC,?C0017
0124         ?C0016:
                                           ; SOURCE LINE # 720
0124 E078          MOV       R8,#07H
0126 DA000000 R    CALLS     SEG (SCS_ApplyNewK2Div),SCS_ApplyNewK2Div
012A F0D4          MOV       R13,R4
                                           ; SOURCE LINE # 721
012C 48D0          CMP       R13,#00H
012E 2D01          JMPR      cc_Z,?C0017
                                           ; SOURCE LINE # 723
0130 0D59          JMPR      cc_UC,?C0013
                                           ; SOURCE LINE # 724
0132         ?C0017:
                                           ; SOURCE LINE # 728
0132 E018          MOV       R8,#01H
0134 DA000000 R    CALLS     SEG (SCS_ApplyNewPDiv),SCS_ApplyNewPDiv
C166 COMPILER V7.57.0, SCS                                                                 12/14/2020 10:56:36 PAGE 33  

0138 F0D4          MOV       R13,R4
                                           ; SOURCE LINE # 729
013A 48D0          CMP       R13,#00H
013C 2D01          JMPR      cc_Z,?C0019
                                           ; SOURCE LINE # 731
013E 0D52          JMPR      cc_UC,?C0013
                                           ; SOURCE LINE # 732
0140         ?C0019:
                                           ; SOURCE LINE # 735
0140 E6F82700      MOV       R8,#027H
0144 DA000000 R    CALLS     SEG (SCS_ApplyNewNDiv),SCS_ApplyNewNDiv
0148 F0D4          MOV       R13,R4
                                           ; SOURCE LINE # 736
014A 48D0          CMP       R13,#00H
014C 2D01          JMPR      cc_Z,?C0020
                                           ; SOURCE LINE # 738
014E 0D4A          JMPR      cc_UC,?C0013
                                           ; SOURCE LINE # 739
0150         ?C0020:
                                           ; SOURCE LINE # 363
0150 D180          EXTR      #01H
0152 E6711000      MOV       SCU_STATCLR1,#010H
                                           ; SOURCE LINE # 745
0156 E6F82100      MOV       R8,#021H
015A DA000000 R    CALLS     SEG (SCS_DelayByTimer),SCS_DelayByTimer
                                           ; SOURCE LINE # 748
015E DA000000 R    CALLS     SEG (SCS_DisableVcoBypass),SCS_DisableVcoBypass
0162 F0D4          MOV       R13,R4
                                           ; SOURCE LINE # 749
0164 48D0          CMP       R13,#00H
0166 2D01          JMPR      cc_Z,?C0021
                                           ; SOURCE LINE # 751
0168 0D3D          JMPR      cc_UC,?C0013
                                           ; SOURCE LINE # 752
016A         ?C0021:
                                           ; SOURCE LINE # 755
016A DA000000 R    CALLS     SEG (SCS_SelectVcoSrcOscHiPrec),SCS_SelectVcoSrcOscHiPrec
016E F0D4          MOV       R13,R4
                                           ; SOURCE LINE # 756
0170 48D0          CMP       R13,#00H
0172 2D01          JMPR      cc_Z,?C0022
                                           ; SOURCE LINE # 758
0174 0D37          JMPR      cc_UC,?C0013
                                           ; SOURCE LINE # 759
0176         ?C0022:
                                           ; SOURCE LINE # 763
0176 E6F81F00      MOV       R8,#01FH
017A DA000000 R    CALLS     SEG (SCS_ApplyNewK2Div),SCS_ApplyNewK2Div
017E F0D4          MOV       R13,R4
                                           ; SOURCE LINE # 764
0180 48D0          CMP       R13,#00H
0182 2D01          JMPR      cc_Z,?C0023
                                           ; SOURCE LINE # 766
0184 0D2F          JMPR      cc_UC,?C0013
                                           ; SOURCE LINE # 767
0186         ?C0023:
                                           ; SOURCE LINE # 402
0186 D190          EXTR      #02H
0188 E6712000      MOV       SCU_STATCLR1,#020H
                                           ; SOURCE LINE # 322
018C 2FDD          BSET      SCU_PLLCON1_RESLD
                                           ; SOURCE LINE # 776
C166 COMPILER V7.57.0, SCS                                                                 12/14/2020 10:56:36 PAGE 34  

                                           ; SOURCE LINE # 481
018E E6F40005      MOV       R4,#0500H
0192 F6F426EA      MOV       0EA26H,R4
                                           ; SOURCE LINE # 484
                                           ; SOURCE LINE # 486
                                           ; SOURCE LINE # 487
                                           ; SOURCE LINE # 490
0196 E6F43F00      MOV       R4,#03FH
019A F6F432EA      MOV       0EA32H,R4
                                           ; SOURCE LINE # 506
019E E6F40040      MOV       R4,#04000H
01A2 F6F426EA      MOV       0EA26H,R4
                                           ; SOURCE LINE # 522
01A6 E6F40002      MOV       R4,#0200H
01AA F6F426EA      MOV       0EA26H,R4
                                           ; SOURCE LINE # 779
                                           ; SOURCE LINE # 781
01AE         ?C0027:
01AE F2F4BCF0      MOV       R4,SCU_PLLSTAT
01B2 8AF40430      JB        R4.3,?C0028
01B6 F2F42CEA      MOV       R4,0EA2CH
01BA 8AF4F8C0      JB        R4.12,?C0027
01BE         ?C0028:
                                           ; SOURCE LINE # 783
01BE F2F4BCF0      MOV       R4,SCU_PLLSTAT
01C2 8AF40230      JB        R4.3,?C0030
                                           ; SOURCE LINE # 786
01C6 E094          MOV       R4,#09H
01C8 0D0D          JMPR      cc_UC,?C0013
                                           ; SOURCE LINE # 787
01CA         ?C0030:
                                           ; SOURCE LINE # 790
01CA DA000000 R    CALLS     SEG (SCS_EnableVcoLockEmerg),SCS_EnableVcoLockEmerg
01CE F0D4          MOV       R13,R4
                                           ; SOURCE LINE # 791
01D0 48D0          CMP       R13,#00H
01D2 2D01          JMPR      cc_Z,?C0031
                                           ; SOURCE LINE # 793
01D4 0D07          JMPR      cc_UC,?C0013
                                           ; SOURCE LINE # 794
01D6         ?C0031:
                                           ; SOURCE LINE # 797
01D6 DA000000 R    CALLS     SEG (SCS_RampUpPllInNormalMode),SCS_RampUpPllInNormalMode
01DA F0D4          MOV       R13,R4
                                           ; SOURCE LINE # 798
01DC 48D0          CMP       R13,#00H
01DE 2D01          JMPR      cc_Z,?C0032
                                           ; SOURCE LINE # 800
01E0 0D01          JMPR      cc_UC,?C0013
                                           ; SOURCE LINE # 801
01E2         ?C0032:
                                           ; SOURCE LINE # 804
01E2 E004          MOV       R4,#00H
                                           ; SOURCE LINE # 806
01E4         ?C0013:
01E4 FCFD          POP       R13
01E6 DB00          RETS      
             ; FUNCTION SCS_GoFromBaseToNormalMode (END    RMASK = @0x7FFF)

             ; FUNCTION SCS_InitTimer (BEGIN  RMASK = @0x4010)
                                           ; SOURCE LINE # 839
01E8 2802          SUB       R0,#02H
C166 COMPILER V7.57.0, SCS                                                                 12/14/2020 10:56:36 PAGE 35  

                                           ; SOURCE LINE # 840
                                           ; SOURCE LINE # 844
01EA F2F400EA      MOV       R4,0EA00H
01EE F6F40600 R    MOV       Ccu60KscfgSave,R4
                                           ; SOURCE LINE # 858
01F2 F2F400EA      MOV       R4,0EA00H
01F6 7843          OR        R4,#03H
01F8 F6F400EA      MOV       0EA00H,R4
                                           ; SOURCE LINE # 861
01FC F2F400EA      MOV       R4,0EA00H
0200 B840          MOV       [R0],R4       ; Work
                                           ; SOURCE LINE # 864
0202 F2F40CEA      MOV       R4,0EA0CH
0206 F6F40400 R    MOV       Ccu60McfgSave,R4
                                           ; SOURCE LINE # 870
020A F2F40CEA      MOV       R4,0EA0CH
020E 7842          OR        R4,#02H
0210 F6F40CEA      MOV       0EA0CH,R4
                                           ; SOURCE LINE # 887
0214 E6F40005      MOV       R4,#0500H
0218 F6F426EA      MOV       0EA26H,R4
                                           ; SOURCE LINE # 890
021C F2F42CEA      MOV       R4,0EA2CH
0220 F6F40200 R    MOV       Ccu60Tctr0Save,R4
                                           ; SOURCE LINE # 934
0224 F2F42CEA      MOV       R4,0EA2CH
0228 66F48F00      AND       R4,#08FH
022C AFF4          BSET      R4.10
022E F6F42CEA      MOV       0EA2CH,R4
                                           ; SOURCE LINE # 939
0232 F2F42EEA      MOV       R4,0EA2EH
0236 F6F40000 R    MOV       Ccu60Tctr2Save,R4
                                           ; SOURCE LINE # 965
023A F2F42EEA      MOV       R4,0EA2EH
023E 66F40103      AND       R4,#0301H
0242 7842          OR        R4,#02H
0244 F6F42EEA      MOV       0EA2EH,R4
                                           ; SOURCE LINE # 972
0248 F2F406EA      MOV       R4,0EA06H
024C F6F40800 R    MOV       Ccu60PiselhSave,R4
                                           ; SOURCE LINE # 981
0250 F2F406EA      MOV       R4,0EA06H
0254 66F40C00      AND       R4,#0CH
0258 F6F406EA      MOV       0EA06H,R4
                                           ; SOURCE LINE # 985
025C 0802          ADD       R0,#02H
025E DB00          RETS      
             ; FUNCTION SCS_InitTimer (END    RMASK = @0x4010)

             ; FUNCTION SCS_RestoreTimer (BEGIN  RMASK = @0x4010)
                                           ; SOURCE LINE # 1016
                                           ; SOURCE LINE # 1032
0260 E6F40005      MOV       R4,#0500H
0264 F6F426EA      MOV       0EA26H,R4
                                           ; SOURCE LINE # 1035
0268 F2F40400 R    MOV       R4,Ccu60McfgSave
026C F6F40CEA      MOV       0EA0CH,R4
                                           ; SOURCE LINE # 1038
0270 F2F40200 R    MOV       R4,Ccu60Tctr0Save
0274 F6F42CEA      MOV       0EA2CH,R4
                                           ; SOURCE LINE # 1041
0278 F2F40000 R    MOV       R4,Ccu60Tctr2Save
C166 COMPILER V7.57.0, SCS                                                                 12/14/2020 10:56:36 PAGE 36  

027C F6F42EEA      MOV       0EA2EH,R4
                                           ; SOURCE LINE # 1044
0280 F2F40800 R    MOV       R4,Ccu60PiselhSave
0284 F6F406EA      MOV       0EA06H,R4
                                           ; SOURCE LINE # 1058
0288 F2F40600 R    MOV       R4,Ccu60KscfgSave
028C 7842          OR        R4,#02H
028E F6F400EA      MOV       0EA00H,R4
                                           ; SOURCE LINE # 1060
0292 DB00          RETS      
             ; FUNCTION SCS_RestoreTimer (END    RMASK = @0x4010)

             ; FUNCTION SCS_CheckFreqOscHiPrec (BEGIN  RMASK = @0x4030)
                                           ; SOURCE LINE # 1085
                                           ; SOURCE LINE # 1086
                                           ; SOURCE LINE # 1090
0294 E0A5          MOV       R5,#0AH
;---- Variable 'Attempts' assigned to Register 'R5' ----
                                           ; SOURCE LINE # 1092
0296         ?C0033:
                                           ; SOURCE LINE # 1095
                                           ; SOURCE LINE # 481
0296 E6F40005      MOV       R4,#0500H
029A F6F426EA      MOV       0EA26H,R4
                                           ; SOURCE LINE # 484
                                           ; SOURCE LINE # 486
                                           ; SOURCE LINE # 487
                                           ; SOURCE LINE # 490
029E E6F4B00C      MOV       R4,#0CB0H
02A2 F6F432EA      MOV       0EA32H,R4
                                           ; SOURCE LINE # 506
02A6 E6F40040      MOV       R4,#04000H
02AA F6F426EA      MOV       0EA26H,R4
                                           ; SOURCE LINE # 522
02AE E6F40002      MOV       R4,#0200H
02B2 F6F426EA      MOV       0EA26H,R4
                                           ; SOURCE LINE # 1098
                                           ; SOURCE LINE # 1100
02B6         ?C0040:
02B6 D180          EXTR      #01H
02B8 8ADA0400      JB        SCU_HPOSCCON_PLLV,?C0041
02BC F2F42CEA      MOV       R4,0EA2CH
02C0 8AF4F9C0      JB        R4.12,?C0040
02C4         ?C0041:
                                           ; SOURCE LINE # 1103
02C4 D180          EXTR      #01H
02C6 8ADA0200      JB        SCU_HPOSCCON_PLLV,?C0043
                                           ; SOURCE LINE # 1106
02CA E014          MOV       R4,#01H
02CC DB00          RETS      
                                           ; SOURCE LINE # 1107
02CE         ?C0043:
                                           ; SOURCE LINE # 1116
02CE D180          EXTR      #01H
02D0 E6710400      MOV       SCU_STATCLR1,#04H
                                           ; SOURCE LINE # 1120
                                           ; SOURCE LINE # 481
02D4 E6F40005      MOV       R4,#0500H
02D8 F6F426EA      MOV       0EA26H,R4
                                           ; SOURCE LINE # 484
                                           ; SOURCE LINE # 486
                                           ; SOURCE LINE # 487
C166 COMPILER V7.57.0, SCS                                                                 12/14/2020 10:56:36 PAGE 37  

                                           ; SOURCE LINE # 490
02DC E6F48802      MOV       R4,#0288H
02E0 F6F432EA      MOV       0EA32H,R4
                                           ; SOURCE LINE # 506
02E4 E6F40040      MOV       R4,#04000H
02E8 F6F426EA      MOV       0EA26H,R4
                                           ; SOURCE LINE # 522
02EC E6F40002      MOV       R4,#0200H
02F0 F6F426EA      MOV       0EA26H,R4
                                           ; SOURCE LINE # 1123
                                           ; SOURCE LINE # 1125
02F4         ?C0048:
02F4 D180          EXTR      #01H
02F6 8ADA08B0      JB        SCU_HPOSCCON_OSC2L1,?C0049
02FA F2F4BCF0      MOV       R4,SCU_PLLSTAT
02FE 8AF404F0      JB        R4.15,?C0049
0302 F2F42CEA      MOV       R4,0EA2CH
0306 8AF4F5C0      JB        R4.12,?C0048
030A         ?C0049:
                                           ; SOURCE LINE # 1127
030A D180          EXTR      #01H
030C 8ADA06B0      JB        SCU_HPOSCCON_OSC2L1,?C0051
0310 F2F4BCF0      MOV       R4,SCU_PLLSTAT
0314 9AF402F0      JNB       R4.15,?C0051
                                           ; SOURCE LINE # 1130
0318 E004          MOV       R4,#00H
031A DB00          RETS      
                                           ; SOURCE LINE # 1131
031C         ?C0051:
                                           ; SOURCE LINE # 1133
031C 2851          SUB       R5,#01H
                                           ; SOURCE LINE # 1134
031E 4850          CMP       R5,#00H
0320 3DBA          JMPR      cc_NZ,?C0033
0322         ?C0036:
                                           ; SOURCE LINE # 1138
0322 E024          MOV       R4,#02H
                                           ; SOURCE LINE # 1140
0324         ?C0044:
0324 DB00          RETS      
             ; FUNCTION SCS_CheckFreqOscHiPrec (END    RMASK = @0x4030)

             ; FUNCTION SCS_ApplyNewPDiv (BEGIN  RMASK = @0x4030)
                                           ; SOURCE LINE # 1169
;---- Variable 'PDiv' assigned to Register 'R8' ----
                                           ; SOURCE LINE # 1171
0326 F2F5BAF1      MOV       R5,SCU_PLLCON1
032A 7C85          SHR       R5,#08H
032C 66F50F00      AND       R5,#0FH
0330 4058          CMP       R5,R8
0332 3D02          JMPR      cc_NZ,?C0052
                                           ; SOURCE LINE # 1174
0334 E004          MOV       R4,#00H
0336 DB00          RETS      
                                           ; SOURCE LINE # 1175
0338         ?C0052:
                                           ; SOURCE LINE # 1184
0338 D180          EXTR      #01H
033A E6710300      MOV       SCU_STATCLR1,#03H
                                           ; SOURCE LINE # 1209
033E F058          MOV       R5,R8
0340 5C85          SHL       R5,#08H
C166 COMPILER V7.57.0, SCS                                                                 12/14/2020 10:56:36 PAGE 38  

0342 F2F4BAF1      MOV       R4,SCU_PLLCON1
0346 66F46B00      AND       R4,#06BH
034A 7045          OR        R4,R5
034C F6F4BAF1      MOV       SCU_PLLCON1,R4
                                           ; SOURCE LINE # 1213
0350 F2F4BCF0      MOV       R4,SCU_PLLSTAT
0354 9AF40A50      JNB       R4.5,?C0054
0358 F2F4BCF0      MOV       R4,SCU_PLLSTAT
035C 9AF40650      JNB       R4.5,?C0054
0360 F2F4BCF0      MOV       R4,SCU_PLLSTAT
0364 9AF40250      JNB       R4.5,?C0054
                                           ; SOURCE LINE # 1215
0368 E064          MOV       R4,#06H
036A DB00          RETS      
                                           ; SOURCE LINE # 1216
036C         ?C0054:
                                           ; SOURCE LINE # 1220
036C D180          EXTR      #01H
036E 76DD0080      OR        SCU_PLLCON1,#08000H
                                           ; SOURCE LINE # 1223
0372 F2F4BCF0      MOV       R4,SCU_PLLSTAT
0376 8AF40A50      JB        R4.5,?C0055
037A F2F4BCF0      MOV       R4,SCU_PLLSTAT
037E 8AF40650      JB        R4.5,?C0055
0382 F2F4BCF0      MOV       R4,SCU_PLLSTAT
0386 8AF40250      JB        R4.5,?C0055
                                           ; SOURCE LINE # 1225
038A E064          MOV       R4,#06H
038C DB00          RETS      
                                           ; SOURCE LINE # 1226
038E         ?C0055:
                                           ; SOURCE LINE # 1229
038E E004          MOV       R4,#00H
                                           ; SOURCE LINE # 1231
0390         ?C0053:
0390 DB00          RETS      
             ; FUNCTION SCS_ApplyNewPDiv (END    RMASK = @0x4030)

             ; FUNCTION SCS_ApplyNewNDiv (BEGIN  RMASK = @0x4030)
                                           ; SOURCE LINE # 1260
;---- Variable 'NDiv' assigned to Register 'R8' ----
                                           ; SOURCE LINE # 1262
0392 F2F5B8F1      MOV       R5,SCU_PLLCON0
0396 7C85          SHR       R5,#08H
0398 66F53F00      AND       R5,#03FH
039C 4058          CMP       R5,R8
039E 3D02          JMPR      cc_NZ,?C0056
                                           ; SOURCE LINE # 1265
03A0 E004          MOV       R4,#00H
03A2 DB00          RETS      
                                           ; SOURCE LINE # 1266
03A4         ?C0056:
                                           ; SOURCE LINE # 1275
03A4 D180          EXTR      #01H
03A6 E6710300      MOV       SCU_STATCLR1,#03H
                                           ; SOURCE LINE # 1297
03AA F058          MOV       R5,R8
03AC 5C85          SHL       R5,#08H
03AE F2F4B8F1      MOV       R4,SCU_PLLCON0
03B2 6847          AND       R4,#07H
03B4 7045          OR        R4,R5
03B6 F6F4B8F1      MOV       SCU_PLLCON0,R4
C166 COMPILER V7.57.0, SCS                                                                 12/14/2020 10:56:36 PAGE 39  

                                           ; SOURCE LINE # 1301
03BA F2F4BCF0      MOV       R4,SCU_PLLSTAT
03BE 9AF40A60      JNB       R4.6,?C0058
03C2 F2F4BCF0      MOV       R4,SCU_PLLSTAT
03C6 9AF40660      JNB       R4.6,?C0058
03CA F2F4BCF0      MOV       R4,SCU_PLLSTAT
03CE 9AF40260      JNB       R4.6,?C0058
                                           ; SOURCE LINE # 1303
03D2 E074          MOV       R4,#07H
03D4 DB00          RETS      
                                           ; SOURCE LINE # 1304
03D6         ?C0058:
                                           ; SOURCE LINE # 1308
03D6 D180          EXTR      #01H
03D8 76DC0080      OR        SCU_PLLCON0,#08000H
                                           ; SOURCE LINE # 1311
03DC F2F4BCF0      MOV       R4,SCU_PLLSTAT
03E0 8AF40A60      JB        R4.6,?C0059
03E4 F2F4BCF0      MOV       R4,SCU_PLLSTAT
03E8 8AF40660      JB        R4.6,?C0059
03EC F2F4BCF0      MOV       R4,SCU_PLLSTAT
03F0 8AF40260      JB        R4.6,?C0059
                                           ; SOURCE LINE # 1313
03F4 E074          MOV       R4,#07H
03F6 DB00          RETS      
                                           ; SOURCE LINE # 1314
03F8         ?C0059:
                                           ; SOURCE LINE # 1317
03F8 E004          MOV       R4,#00H
                                           ; SOURCE LINE # 1319
03FA         ?C0057:
03FA DB00          RETS      
             ; FUNCTION SCS_ApplyNewNDiv (END    RMASK = @0x4030)

             ; FUNCTION SCS_ApplyNewK1Div (BEGIN  RMASK = @0x4030)
                                           ; SOURCE LINE # 1348
;---- Variable 'K1Div' assigned to Register 'R8' ----
                                           ; SOURCE LINE # 1350
03FC F2F5BCF1      MOV       R5,SCU_PLLCON2
0400 66F5FF03      AND       R5,#03FFH
0404 4058          CMP       R5,R8
0406 3D02          JMPR      cc_NZ,?C0060
                                           ; SOURCE LINE # 1353
0408 E004          MOV       R4,#00H
040A DB00          RETS      
                                           ; SOURCE LINE # 1354
040C         ?C0060:
                                           ; SOURCE LINE # 1360
040C F6F8BCF1      MOV       SCU_PLLCON2,R8
                                           ; SOURCE LINE # 1364
0410 F2F4BCF0      MOV       R4,SCU_PLLSTAT
0414 9AF40A70      JNB       R4.7,?C0062
0418 F2F4BCF0      MOV       R4,SCU_PLLSTAT
041C 9AF40670      JNB       R4.7,?C0062
0420 F2F4BCF0      MOV       R4,SCU_PLLSTAT
0424 9AF40270      JNB       R4.7,?C0062
                                           ; SOURCE LINE # 1366
0428 E044          MOV       R4,#04H
042A DB00          RETS      
                                           ; SOURCE LINE # 1367
042C         ?C0062:
                                           ; SOURCE LINE # 1370
C166 COMPILER V7.57.0, SCS                                                                 12/14/2020 10:56:36 PAGE 40  

042C D180          EXTR      #01H
042E FFDE          BSET      SCU_PLLCON2_K1ACK
                                           ; SOURCE LINE # 1373
0430 F2F4BCF0      MOV       R4,SCU_PLLSTAT
0434 8AF40A70      JB        R4.7,?C0063
0438 F2F4BCF0      MOV       R4,SCU_PLLSTAT
043C 8AF40670      JB        R4.7,?C0063
0440 F2F4BCF0      MOV       R4,SCU_PLLSTAT
0444 8AF40270      JB        R4.7,?C0063
                                           ; SOURCE LINE # 1375
0448 E044          MOV       R4,#04H
044A DB00          RETS      
                                           ; SOURCE LINE # 1376
044C         ?C0063:
                                           ; SOURCE LINE # 1379
044C E004          MOV       R4,#00H
                                           ; SOURCE LINE # 1381
044E         ?C0061:
044E DB00          RETS      
             ; FUNCTION SCS_ApplyNewK1Div (END    RMASK = @0x4030)

             ; FUNCTION SCS_ApplyNewK2Div (BEGIN  RMASK = @0x4030)
                                           ; SOURCE LINE # 1410
;---- Variable 'K2Div' assigned to Register 'R8' ----
                                           ; SOURCE LINE # 1412
0450 F2F5BEF1      MOV       R5,SCU_PLLCON3
0454 66F5FF03      AND       R5,#03FFH
0458 4058          CMP       R5,R8
045A 3D02          JMPR      cc_NZ,?C0064
                                           ; SOURCE LINE # 1415
045C E004          MOV       R4,#00H
045E DB00          RETS      
                                           ; SOURCE LINE # 1416
0460         ?C0064:
                                           ; SOURCE LINE # 1422
0460 F6F8BEF1      MOV       SCU_PLLCON3,R8
                                           ; SOURCE LINE # 1426
0464 F2F4BCF0      MOV       R4,SCU_PLLSTAT
0468 9AF40A80      JNB       R4.8,?C0066
046C F2F4BCF0      MOV       R4,SCU_PLLSTAT
0470 9AF40680      JNB       R4.8,?C0066
0474 F2F4BCF0      MOV       R4,SCU_PLLSTAT
0478 9AF40280      JNB       R4.8,?C0066
                                           ; SOURCE LINE # 1428
047C E054          MOV       R4,#05H
047E DB00          RETS      
                                           ; SOURCE LINE # 1429
0480         ?C0066:
                                           ; SOURCE LINE # 1433
0480 D180          EXTR      #01H
0482 76DF0080      OR        SCU_PLLCON3,#08000H
                                           ; SOURCE LINE # 1436
0486 F2F4BCF0      MOV       R4,SCU_PLLSTAT
048A 8AF40A80      JB        R4.8,?C0067
048E F2F4BCF0      MOV       R4,SCU_PLLSTAT
0492 8AF40680      JB        R4.8,?C0067
0496 F2F4BCF0      MOV       R4,SCU_PLLSTAT
049A 8AF40280      JB        R4.8,?C0067
                                           ; SOURCE LINE # 1438
049E E054          MOV       R4,#05H
04A0 DB00          RETS      
                                           ; SOURCE LINE # 1439
C166 COMPILER V7.57.0, SCS                                                                 12/14/2020 10:56:36 PAGE 41  

04A2         ?C0067:
                                           ; SOURCE LINE # 1442
04A2 E004          MOV       R4,#00H
                                           ; SOURCE LINE # 1444
04A4         ?C0065:
04A4 DB00          RETS      
             ; FUNCTION SCS_ApplyNewK2Div (END    RMASK = @0x4030)

             ; FUNCTION SCS_SelectVcoSrcOscHiPrec (BEGIN  RMASK = @0x4010)
                                           ; SOURCE LINE # 1471
                                           ; SOURCE LINE # 1495
04A6 D180          EXTR      #01H
04A8 66DD658F      AND       SCU_PLLCON1,#08F65H
                                           ; SOURCE LINE # 1499
04AC F2F4BCF0      MOV       R4,SCU_PLLSTAT
04B0 9AF40A20      JNB       R4.2,?C0068
04B4 F2F4BCF0      MOV       R4,SCU_PLLSTAT
04B8 9AF40620      JNB       R4.2,?C0068
04BC F2F4BCF0      MOV       R4,SCU_PLLSTAT
04C0 9AF40220      JNB       R4.2,?C0068
                                           ; SOURCE LINE # 1501
04C4 E034          MOV       R4,#03H
04C6 DB00          RETS      
                                           ; SOURCE LINE # 1502
04C8         ?C0068:
                                           ; SOURCE LINE # 1505
04C8 E004          MOV       R4,#00H
                                           ; SOURCE LINE # 1507
04CA         ?C0069:
04CA DB00          RETS      
             ; FUNCTION SCS_SelectVcoSrcOscHiPrec (END    RMASK = @0x4010)

             ; FUNCTION SCS_EnableVcoLockEmerg (BEGIN  RMASK = @0x4030)
                                           ; SOURCE LINE # 1532
                                           ; SOURCE LINE # 1534
                                           ; SOURCE LINE # 1537
04CC F2F4BCF0      MOV       R4,SCU_PLLSTAT
04D0 8AF40230      JB        R4.3,?C0070
                                           ; SOURCE LINE # 1540
04D4 E0A4          MOV       R4,#0AH
04D6 DB00          RETS      
                                           ; SOURCE LINE # 1541
04D8         ?C0070:
                                           ; SOURCE LINE # 1550
04D8 D190          EXTR      #02H
04DA E6710300      MOV       SCU_STATCLR1,#03H
                                           ; SOURCE LINE # 1553
04DE 5EDD          BCLR      SCU_PLLCON1_EMCLKEN
                                           ; SOURCE LINE # 1556
04E0 6EA5          BCLR      SCU_SYSCON0_EMCLKSELEN
                                           ; SOURCE LINE # 1561
04E2 D190          EXTR      #02H
04E4 E6700020      MOV       SCU_STATCLR0,#02000H
                                           ; SOURCE LINE # 1564
04E8 6FDD          BSET      SCU_PLLCON1_EMFINDISEN
                                           ; SOURCE LINE # 1575
04EA E6478000      MOV       SCU_TRAPCLR,#080H
                                           ; SOURCE LINE # 1586
04EE 66487F00      AND       SCU_TRAPDIS,#07FH
                                           ; SOURCE LINE # 1588
04F2 F2F5BCF0      MOV       R5,SCU_PLLSTAT
;---- Variable 'Work' assigned to Register 'R5' ----
C166 COMPILER V7.57.0, SCS                                                                 12/14/2020 10:56:36 PAGE 42  

                                           ; SOURCE LINE # 1590
04F6 F045          MOV       R4,R5
04F8 66F4000C      AND       R4,#0C00H
04FC 3D02          JMPR      cc_NZ,?C0073
04FE 8AF50230      JB        R5.3,?C0072
0502         ?C0073:
                                           ; SOURCE LINE # 1609
0502 E0A4          MOV       R4,#0AH
0504 DB00          RETS      
                                           ; SOURCE LINE # 1610
0506         ?C0072:
                                           ; SOURCE LINE # 1613
0506 E004          MOV       R4,#00H
                                           ; SOURCE LINE # 1615
0508         ?C0071:
0508 DB00          RETS      
             ; FUNCTION SCS_EnableVcoLockEmerg (END    RMASK = @0x4030)

             ; FUNCTION SCS_DisableVcoBypass (BEGIN  RMASK = @0x4010)
                                           ; SOURCE LINE # 1641
                                           ; SOURCE LINE # 1645
050A D180          EXTR      #01H
050C 0EDC          BCLR      SCU_PLLCON0_VCOBY
                                           ; SOURCE LINE # 1648
050E F2F4BCF0      MOV       R4,SCU_PLLSTAT
0512 8AF40A00      JB        R4.0,?C0074
0516 F2F4BCF0      MOV       R4,SCU_PLLSTAT
051A 8AF40600      JB        R4.0,?C0074
051E F2F4BCF0      MOV       R4,SCU_PLLSTAT
0522 8AF40200      JB        R4.0,?C0074
                                           ; SOURCE LINE # 1650
0526 E084          MOV       R4,#08H
0528 DB00          RETS      
                                           ; SOURCE LINE # 1651
052A         ?C0074:
                                           ; SOURCE LINE # 1655
052A E004          MOV       R4,#00H
                                           ; SOURCE LINE # 1657
052C         ?C0075:
052C DB00          RETS      
             ; FUNCTION SCS_DisableVcoBypass (END    RMASK = @0x4010)

             ; FUNCTION SCS_EnableVcoBypass (BEGIN  RMASK = @0x4010)
                                           ; SOURCE LINE # 1683
                                           ; SOURCE LINE # 1687
052E D180          EXTR      #01H
0530 0FDC          BSET      SCU_PLLCON0_VCOBY
                                           ; SOURCE LINE # 1690
0532 F2F4BCF0      MOV       R4,SCU_PLLSTAT
0536 9AF40A00      JNB       R4.0,?C0076
053A F2F4BCF0      MOV       R4,SCU_PLLSTAT
053E 9AF40600      JNB       R4.0,?C0076
0542 F2F4BCF0      MOV       R4,SCU_PLLSTAT
0546 9AF40200      JNB       R4.0,?C0076
                                           ; SOURCE LINE # 1692
054A E084          MOV       R4,#08H
054C DB00          RETS      
                                           ; SOURCE LINE # 1693
054E         ?C0076:
                                           ; SOURCE LINE # 1697
054E E004          MOV       R4,#00H
                                           ; SOURCE LINE # 1699
C166 COMPILER V7.57.0, SCS                                                                 12/14/2020 10:56:36 PAGE 43  

0550         ?C0077:
0550 DB00          RETS      
             ; FUNCTION SCS_EnableVcoBypass (END    RMASK = @0x4010)



MODULE INFORMATION:   INITIALIZED  UNINITIALIZED
  CODE SIZE        =        1362     --------
  NEAR-CONST SIZE  =    --------     --------
  FAR-CONST SIZE   =    --------     --------
  HUGE-CONST SIZE  =    --------     --------
  XHUGE-CONST SIZE =    --------     --------
  NEAR-DATA SIZE   =          10     --------
  FAR-DATA SIZE    =    --------     --------
  XHUGE-DATA SIZE  =    --------     --------
  IDATA-DATA SIZE  =    --------     --------
  SDATA-DATA SIZE  =    --------     --------
  BDATA-DATA SIZE  =    --------     --------
  HUGE-DATA SIZE   =    --------     --------
  BIT SIZE         =    --------     --------
  INIT'L SIZE      =    --------     --------
END OF MODULE INFORMATION.


C166 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
