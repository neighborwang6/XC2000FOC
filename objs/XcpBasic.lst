C166 COMPILER V7.57.0, XCPBASIC                                                            01/03/2020 16:20:10 PAGE 1   


C166 COMPILER V7.57.0, COMPILATION OF MODULE XCPBASIC
OBJECT MODULE PLACED IN .\objs\XcpBasic.obj
COMPILER INVOKED BY: C:\Keil_v5\C166\BIN\C166.EXE xcp\XcpBasic.c MODV2 LARGE BROWSE INCDIR(.\src\hardware;.\src;.\EOL_Di
                    -ag;.\DTC_Diag;.\Hw_Driver;.\CalTool;.\DTC_Diag\mcu2_prot;./CAN_Driver;.\xcp;.\src\include;.\EBS_Ctrl_Logic) MODV2 DEBUG 
                    -CODE PRINT(.\objs\XcpBasic.lst) TABS(2) OBJECT(.\objs\XcpBasic.obj) 

 stmt lvl     source

    1         
    2         
    3         /*****************************************************************************
    4         | Project Name:   XCP Protocol Layer
    5         |    File Name:   XcpBasic.c
    6         |
    7         |  Description:   Implementation of the XCP Protocol Layer 
    8         |                 XCP V1.0 slave device driver
    9         |                 Basic Version (see feature list below)
   10         |
   11         |
   12         |     Limitations of the XCP basic version:
   13         |
   14         |     - Stimulation (Bypassing) is not available
   15         |         XCP_ENABLE_STIM
   16         |     - Bit stimulation is not available
   17         |         XCP_ENABLE_STIM_BIT
   18         |     - SHORT_DOWNLOAD is not available
   19         |         XCP_ENABLE_SHORT_DOWNLOAD
   20         |     - MODIFY_BITS is not available
   21         |         XCP_ENABLE_MODIFY_BITS
   22         |     - FLASH and EEPROM Programming is not available
   23         |         XCP_ENABLE_PROGRAM, XCP_ENABLE_BOOTLOADER_DOWNLOAD, XCP_ENABLE_READ_EEPROM, XCP_ENABLE_WRITE_EEP
             -ROM
   24         |     - Block mode for UPLOAD, DOWNLOAD and PROGRAM is not available
   25         |         XCP_ENABLE_BLOCK_UPLOAD, XCP_ENABLE_BLOCK_DOWNLOAD
   26         |     - Resume mode is not available
   27         |         XCP_ENABLE_DAQ_RESUME
   28         |     - Memory write and read protection is not supported
   29         |         XCP_ENABLE_WRITE_PROTECTION
   30         |         XCP_ENABLE_READ_PROTECTION
   31         |     - Checksum calculation with AUTOSAR CRC module is not supported
   32         |         XCP_ENABLE_AUTOSAR_CRC_MODULE
   33         |     - No support from Vector Generation Tool
   34         |
   35         |       All these feature are available in the full version.
   36         |       Please contact Vector Informatik GmbH for more information
   37         |
   38         |     General limitations:
   39         |
   40         |     - Daq and Event numbers are BYTE
   41         |     - Only dynamic DAQ list allocation supported
   42         |     - Max. checksum block size is 0xFFFF
   43         |     - CECKSUM_TYPE CRC16, CRC32 and 'user defined' are not supported
   44         |     - MAX_DTO is limited to max. 255
   45         |     - The resume bits in daq lists are not set
   46         |     - STORE_DAQ, CLEAR_DAQ and STORE_CAL will not send a event message 
   47         |     - Entering resume mode will not send a event message
   48         |     - Overload indication by event is not supported
   49         |     - Page Info and Segment Info is not supported
   50         |     - DAQ does not support address extensions
   51         |     - DAQ-list and event channel prioritization is not supported
   52         |     - Event channels contain one DAQ-list
C166 COMPILER V7.57.0, XCPBASIC                                                            01/03/2020 16:20:10 PAGE 2   

   53         |     - ODT optimization not supported
   54         |     - Interleaved communication mode is not supported
   55         |     - The seed size is equal or less MAX_CTO-2
   56         |     - The key size is equal or less MAX_CTO-2
   57         |     - Only default programming data format is supported
   58         |     - GET_SECTOR_INFO does not return sequence numbers
   59         |     - PROGRAM_VERIFY and PROGRAM_FORMAT are not supported
   60         |
   61         |-----------------------------------------------------------------------------
   62         |               D E M O
   63         |-----------------------------------------------------------------------------
   64         |
   65         |       Please note, that the demo and example programs 
   66         |       only show special aspects of the software. 
   67         |       With regard to the fact that these programs are meant 
   68         |       for demonstration purposes only,
   69         |       Vector Informatik's liability shall be expressly excluded in cases 
   70         |       of ordinary negligence, to the extent admissible by law or statute.
   71         |
   72         |-----------------------------------------------------------------------------
   73         |               C O P Y R I G H T
   74         |-----------------------------------------------------------------------------
   75         | Copyright (c) 2017 by Vector Informatik GmbH.           All rights reserved.
   76         |
   77         |       This software is copyright protected and 
   78         |       proporietary to Vector Informatik GmbH.
   79         |       Vector Informatik GmbH grants to you only
   80         |       those rights as set out in the license conditions.
   81         |       All other rights remain with Vector Informatik GmbH.
   82         | 
   83         |       Diese Software ist urheberrechtlich geschuetzt. 
   84         |       Vector Informatik GmbH raeumt Ihnen an dieser Software nur 
   85         |       die in den Lizenzbedingungen ausdruecklich genannten Rechte ein.
   86         |       Alle anderen Rechte verbleiben bei Vector Informatik GmbH.
   87         |
   88         |-----------------------------------------------------------------------------
   89         |               A U T H O R   I D E N T I T Y
   90         |-----------------------------------------------------------------------------
   91         | Initials     Name                      Company
   92         | --------     ---------------------     -------------------------------------
   93         | Ds           Sven Deckardt             Vector Informatik GmbH
   94         | Eta          Edgar Tongoona            Vector Informatik GmbH
   95         | Hr           Andreas Herkommer         Vector Informatik GmbH
   96         | Svh          Sven Hesselmann           Vector Informatik GmbH
   97         | Tri          Frank Triem               Vector Informatik GmbH
   98         | Za           Rainer Zaiser             Vector Informatik GmbH
   99         | Ore          Oliver Reineke            Vector Informatik GmbH
  100         | Bwr          Brandon Root              Vector CANtech
  101         |-----------------------------------------------------------------------------
  102         |               R E V I S I O N   H I S T O R Y
  103         |-----------------------------------------------------------------------------
  104         |  Date       Version  Author  Description
  105         | ----------  -------  ------  -----------------------------------------------
  106         | 2003-03-01  0.9.00    Ds     Created  
  107         | 2003-05-01  0.9.10    Za     Still a lot of changes, no detailled history yet
  108         | 2003-06-31  1.0.00    Za     Released
  109         | 2003-09-19  1.0.00    Za     XCP_DAQ_TIMESTAMP_FIXED
  110         | 2003-10-22  1.0.01    Ds     Change #if def instruction
  111         | 2003-10-30  1.0.02    Ds     Bugfix in the loop of the ODT Entry
  112         | 2003-10-30  1.0.03    Ds     Rename xcp20.c to xcpProf.c 
  113         | 2003-11-20  1.01.00   Tri    Updated to PSC standard
  114         |                              MISRA rules applied.
C166 COMPILER V7.57.0, XCPBASIC                                                            01/03/2020 16:20:10 PAGE 3   

  115         |                              Minor changes.
  116         | 2004-02-11  1.01.01   Ds,Tri Updated and adaption for CANape
  117         |                              ESCAN00007511: Warning when compiling XCP.H
  118         |                              ESCAN00007517: Compiler error when using a packet length of 253 bytes or gr
             -eater
  119         |                              ESCAN00007518: Seed & Key: reading of the unlock key not performed correctl
             -y
  120         |                              ESCAN00007532: Division by zero in calculation of the queue size
  121         |                              ESCAN00007533: Memory overflow check during memory allocation might not be 
             -detected.
  122         | 2004-06-16  1.02.00   Tri    ESCAN00008482: Add user defined function to service GET_ID
  123         | 2005-01-03  1.03.00   Tri,Za ESCAN00008009: Rename module versions according to PD_PSC_Development
  124         |                              ESCAN00009121: Add copyright note
  125         |                              ESCAN00009125: Remove defines for revision 18
  126         |                              ESCAN00009127: Remove XCP_ENABLE_SEND_BUFFER
  127         |                              ESCAN00009130: Add support for data stimulation (STIM)
  128         |                              ESCAN00007824: Warning due to unreferenced label 'negative_response1'
  129         |                              ESCAN00008012: Remove include definitions of the standard libraries within 
             -XCP Professional
  130         |                              ESCAN00008015: Avoid usage of the test mode within XCP Professional
  131         |                              ESCAN00008018: XCP module version in response of CC_GET_COMM_MODE_INFO corr
             -ected
  132         |                              ESCAN00008004: Compiler error when block upload is enabled and block downlo
             -ad is disabled
  133         |                              ESCAN00008005: Resource bit for CAL/PAG always set in response upon CC_CONN
             -ECT
  134         |                              ESCAN00009141: Compiler warnings while compilation with Tasking Compiler
  135         |                              ESCAN00007823: Warning about unreferenced variable 'prescaler'
  136         |                              ESCAN00008003: Compiler error when block download is disabled and Programmi
             -ng enabled
  137         |                              ESCAN00008060: Issue in negative response of command BUILD_CHECKSUM
  138         |                              ESCAN00008013: Checksum calculation wrong
  139         |                              ESCAN00008072: Compiler warning in range check of defines
  140         |                              ESCAN00007971: Implement and support 'session configuration id'
  141         |                              ESCAN00008006: Page switching always enabled when programming is enabled.
  142         |                              ESCAN00008010: Remove extern declaration for xcp struct
  143         |                              ESCAN00009154: Update Seed & Key
  144         |                              ESCAN00010703: PROGRAM size = 0 is valid
  145         |                              ESCAN00008017: Rework of Flash Programming by Flash Kernel
  146         |                              ESCAN00009200: Positive Response upon command PROGRAM_START not correct
  147         |                              ESCAN00010705: Rework command PROGRAM_RESET
  148         |                              ESCAN00010706: Return the status of event channels
  149         |                              ESCAN00010707: Consistency check in case of no DAQ released
  150         |                              ESCAN00008008: Apply PSC naming convention for types and structures
  151         |                              ESCAN00009173: Consistency check for generator DLL and component
  152         |                              ESCAN00008007: Rename the post-organified filenames to xcpProf.h and xcpPro
             -f.c
  153         |                              ESCAN00009172: Atmega only: Compiler error due to pointer conversion from R
             -AM to Flash
  154         |                              ESCAN00007209: Apply naming convention to callback functions
  155         |                              ESCAN00009144: Minor changes
  156         | 2005-02-01  1.04.00   Tri    ESCAN00010989: Update comment for version scan
  157         |                              ESCAN00010848: Move timestamp unit of response to GET_DAQ_EVENT_INFO in low
             - nibble
  158         | 2005-02-17  1.05.00   Tri    ESCAN00011210: Support GENy Fwk 1.3 DLL Versions
  159         | 2005-02-28  1.06.00   Tri    ESCAN00010961: Include XCP Transport Layer on CAN
  160         | 2005-05-10  1.07.00   Tri    ESCAN00011446: Tasking Compiler only: Compiler Warnings
  161         |                              ESCAN00012314: Compatibility with CANape 5.5.x regarding timestamp unit
  162         |                              ESCAN00012356: Support data paging on Star12X / Metrowerks
  163         |                              ESCAN00012617: Add service to retrieve XCP state
  164         | 2006-01-03  1.08.00   Tri    ESCAN00013899: Data acquisition not possible during cold start
  165         |                              ESCAN00009196: PROGRAM_FORMAT is not implemented as specified
C166 COMPILER V7.57.0, XCPBASIC                                                            01/03/2020 16:20:10 PAGE 4   

  166         |                              ESCAN00009199: Negative Response to command PROGRAM_PREPARE is not correct
  167         |                              ESCAN00009202: Programming Info not implemented correctly
  168         |                              ESCAN00014313: Warning because of undefined 'kXcpStimOdtCount'
  169         |                              ESCAN00013634: Remove kXcpPacketHeaderSize
  170         |                              ESCAN00014710: Rework Calibration Data Page Freeze
  171         |                              ESCAN00014712: Rework Segment Info and Page Info
  172         |                              ESCAN00014775: Delayed EEPROM read access not possible
  173         | 2006-03-09  1.09.00   Tri    ESCAN00013637: Support command TRANSPORT_LAYER_CMD
  174         |                              ESCAN00015283: Start of a single DAQ list is not possible
  175         |                              ESCAN00015607: Support XCP on FlexRay Transport Layer
  176         | 2006-05-05  1.10.00   Tri    ESCAN00016158: Add demo disclaimer to XCP Basic
  177         |                              ESCAN00016098: Calculation of CRC16 CCITT is not correct
  178         | 2006-05-30  1.11.00   Tri    ESCAN00016225: Support Cp_XcpOnLin
  179         | 2006-07-18  1.12.00   Tri    ESCAN00016955: Support AUTOSAR CRC module
  180         |                              ESCAN00016958: Delayed EEPROM read access not possible
  181         | 2006-10-26  1.13.00   Tri    ESCAN00017516: Support Cp_XcpOnCanAsr
  182         |                              ESCAN00017504: Replace P_MEM_ROM by MEMORY_FAR resp. V_MEMRAM2_FAR
  183         |                              ESCAN00017804: Multiple definitions of XCP_DISABLE_TESTMODE
  184         |                              ESCAN00017878: Overwriting of memory during data acquisition allocation
  185         | 2007-01-30  1.14.00   Tri    ESCAN00018808: Support data paging on Star12X / Cosmic
  186         | 2007-04-03  1.15.00   Eta    ESCAN00018153: Overwriting of memory during data stimulation
  187         |                       Svh    ESCAN00020126: Commands SHORT_DOWNLOAD and MODIFY_BITS must be supported
  188         |                              ESCAN00012618: Support command MODIFY_BITS
  189         |                              ESCAN00020127: It has to be possible to en-/disable XCP globally
  190         |                              ESCAN00019094: Extend implementation for runtime deactivation of XCP (profe
             -ssional)
  191         |                              ESCAN00020128: Add AUTOSAR based API
  192         |                              ESCAN00018154: Support overwriting of XcpSendDto() in header
  193         |                              ESCAN00015859: Support memory read protection
  194         | 2007-05-25  1.16.00   Svh    ESCAN00020906: Compiler error due to incorrect pointer assignment
  195         | 2007-07-09  1.16.01   Hr     Support AUTOSAR Memory Mapping
  196         | 2007-12-07  1.16.02   Hr     ISS046 - Only CTOs are flushed by the Protocol Layer
  197         | 2007-09-14  1.17.00   Svh    ESCAN00022293: Support for SET_SEGMENT_MODE and GET_SEGMENT_MODE added
  198         | 2007-12-17  1.18.00   Svh    ESCAN00023759: Compile error for MCS12x
  199         | 2008-03-17  1.19.00   Svh    ESCAN00021035: XcpSendCallBack() always returns 1
  200         |                              ESCAN00024265: STIM with time stamp is not supported
  201         |                              ESCAN00024863: Missing error code in CC_TRANSPORT_LAYER_CMD
  202         |                              ESCAN00025020: Possible stack issues with big MAX_DTO values in case Send Q
             -ueue is not used
  203         |                              ESCAN00023570: Do not set default answer is last CRM is still pending
  204         | 2008-04-10  1.20.00   Svh    ESCAN00025979: tXcpDto wrong structure ordering causing erroneous one-time 
             -Stim trigger
  205         | 2008-04-30  1.21.00   Eta    ESCAN00026424: compiler error when using Cosmic with option -pck
  206         |                       Svh    ESCAN00026491: Data inconsistency of ODTs in case of Overrun + FlexRay
  207         | 2008-04-30  1.21.01   Svh    ESCAN00026541: compiler error due to unknown symbol
  208         | 2008-06-04  1.21.02   Svh    ESCAN00027343: Redefinition of ApplXcpSendFlush
  209         | 2008-07-21  1.22.00   Hr     ESCAN00022545: Memory Read Protection always returns Ok to CANape
  210         |                              ESCAN00020637: Support different Info Time Unit for DTO handling
  211         |                              ESCAN00017954: Support MIN_ST_PGM
  212         |                              ESCAN00017951: Add open interface for command processing
  213         |                              ESCAN00028579: CC_PROGRAM_START should support an application callback
  214         |                       Svh    ESCAN00028720: Support ADDRESS_GRANULARITY WORD
  215         | 2008-09-10  1.23.00   Svh    ESCAN00029890: Incorrect checksum calculation
  216         |                              ESCAN00029896: Command pending for several call backs added
  217         |                              ESCAN00029897: XcpStimEventStatus() returns 1 also if no STIM data is avail
             -able
  218         |                              ESCAN00029905: Configuration of parameter MIN_ST in response of GET_COMM_MO
             -DE_INFO command added
  219         | 2008-10-01  1.23.01   Hr     ESCAN00030382: Compiler error due to missing ;
  220         | 2008-10-10  1.23.02   Bwr    ESCAN00030037: Support for more than 255 ODT entries
  221         | 2008-12-01  1.24.00   Hr     ESCAN00031342: Version information of implementation inconsistent to releas
             -e version information
C166 COMPILER V7.57.0, XCPBASIC                                                            01/03/2020 16:20:10 PAGE 5   

  222         |                              ESCAN00031726: Add support for XcpOnTcpIpAsr
  223         |                              ESCAN00031948: Event gets lost, if a Response is still pending
  224         |                              ESCAN00031949: Add error check for ODT_SIZE_WORD with no DAQ_HDR_ODT_DAQ
  225         |                       Bwr    ESCAN00030566: SET_REQUEST with incorrect mode is ignored
  226         |                              ESCAN00030601: Support for more than 255 ODTs
  227         | 2009-02-05  1.24.01   Hr     ESCAN00032861: CC_SET_DAQ_PTR fails due to Diab Data Compiler bug
  228         | 2009-02-27  1.24.02   Hr     ESCAN00031794: Compiler warning: large type was implicitly cast to small ty
             -pe
  229         |                              ESCAN00033655: Canbedded compile error due to uint8
  230         | 2009-05-13  1.25.00   Hr     ESCAN00033909: New features implemented: Prog Write Protection, Timestamps,
             - Calibration activation
  231         | 2009-10-08  1.25.01   Hr     ESCAN00038283: After second measurement start with INCA no timestamps are g
             -enerated anymore.
  232         |                              ESCAN00039240: Compile error by uint8
  233         |                              ESCAN00039241: Variables not in NOINIT sections
  234         | 2009-11-26            Hr     ESCAN00039350: TMS320 Compile error: struct has no field "EightByteField"
  235         | 2010-03-24  1.26.00   Hr     ESCAN00041784: new API for better calibration support
  236         |                              ESCAN00041784: Queue size calculation incorrect under certain conditions
  237         | 2010-05-25  1.26.01   Hr     ESCAN00042660: Send queue variables to small
  238         |                              ESCAN00043113: Compiler error: identifier uint16 not declared
  239         | 2010-07-08  1.26.02   Hr     ESCAN00043335: Queue size calculation incorrect on 32Bit Platforms
  240         | 2010-10-12  1.26.03   Hr     ESCAN00045791: Send Queue limited to 255 Entries by typecasts
  241         | 2011-02-11  1.27.00   Hr     ESCAN00047153: 'XCP on LIN' and 'XCP on CAN' can not be used in the same co
             -nfiguration.
  242         |                              ESCAN00048613: CC_PROGRAM_CLEAR does not make use of programming write prot
             -ection
  243         |                              ESCAN00049091: Optimization to prevent a goto in the code
  244         |                              ESCAN00049090: Software might hang in endless software loop
  245         | 2011-06-06  1.27.01   Hr     ESCAN00051222: Customer can't compile XCP when disabling the DAQ feature
  246         | 2011-07-19  1.27.02   Ore    ESCAN00052011: Reading memory of the ECU via XCP is not possible. XCP Conne
             -ct aborts with error condition PAGE_MODE_NOT_VALID (=0x27)
  247         | 2011-08-29  1.27.03   Hr     ESCAN00052721: Compiler Error because MEMORY_ROM definition
  248         |                              ESCAN00053956: Check DAQ lists for validity before they are started
  249         | 2011-11-02  1.27.04   Hr     ESCAN00054318: Issue of memory read/write protection in DAQ measurement
  250         | 2012-02-20  1.27.05   Hr     ESCAN00055216: DAQ Lists can be extended after START_STOP_SYNCH
  251         | 2012-05-31  1.27.06   Hr     ESCAN00058916: Trap if WRITE_DAQ is used before a DAQ list is created.
  252         | 2012-08-13  1.28.00   Hr     ESCAN00038632: Support for address doubling in CANape for DSP micros
  253         | 2013-06-17  1.28.01   Hr     ESCAN00068052: Provide an API to detect XCP state and usage
  254         | 2013-09-17  1.28.02   Hr     ESCAN00069598: The PROGRAM_MAX command uses a wrong length
  255         |                              ESCAN00067667: Compiler warning: warning #177-D: label "negative_response1"
             - was declared but never referenced
  256         | 2013-12-09  1.29.00   Hr     ESCAN00072412: Provide an API to detect XCP state and usage
  257         |                              ESCAN00072503: Support custom CRC Cbk
  258         |                              ESCAN00072505: Support Generic GET_ID
  259         | 2015-03-26  1.30.00   Hr     ESCAN00082098: Time Check for DAQ lists
  260         | 2016-01-12  1.30.01   Hr     ESCAN00087368: Unexpected byte order used on word-addressed platforms (e.g.
             - TMS320)
  261         | 2016-06-24  1.30.02   Hr     ESCAN00090639: Compiler error: "truncating assignment" 
  262         |                              ESCAN00090685: Max PID not checked against 0x7C if Overload Indication is a
             -ctive
  263         |                              ESCAN00090687: Prescaler does not disable single DAQ list per event optimiz
             -ation
  264         |                              ESCAN00090699: MPU detects illegal access to variable dto
  265         | 2016-11-18  1.30.03   Hr     ESCAN00091645: Wrong memory size calculation during memory allocation
  266         |                              ESCAN00092933: XcpMemCpy does not fully utilize XCP_ENABLE_MEM_ACCESS_BY_AP
             -PL
  267         |                              ESCAN00092934: Max PID not checked against 0x7B if Overload Indication is a
             -ctive
  268         | 2017-09-01  1.30.04   Hr     ESCAN00095506: TMS320 wrong Endianess used during memory access.
  269         |                              ESCAN00096039: Compiler error: out of bounds array access optimized away
  270         |                              ESCAN00096161: Compiler warning: Unused variable qs
  271         |                              ESCAN00096627: Improve plausibility check of DAQ allocation
C166 COMPILER V7.57.0, XCPBASIC                                                            01/03/2020 16:20:10 PAGE 6   

  272         |***************************************************************************/
  273         
  274         
  275         /***************************************************************************/
  276         /* Include files                                                           */
  277         /***************************************************************************/
  278         
  279         #include "xcpBasic.h"
  280         
  281         /* Include AUTOSAR CRC module header file. */
  282         
  283         /* XCP DPRAM Client Mode */
  284         
  285         #if defined ( XCP_ENABLE_SERV_TEXT_PRINTF ) && defined ( XCP_ENABLE_TESTMODE )
              #include <stdio.h>
              #include <stdarg.h>
              #endif
  289         
  290         
  291         /***************************************************************************/
  292         /* Version check                                                           */
  293         /***************************************************************************/
  294         #if ( CP_XCP_VERSION != 0x0130u )
              #error "Source and Header file are inconsistent!"
              #endif
  297         #if ( CP_XCP_RELEASE_VERSION != 0x04u )
              #error "Source and Header file are inconsistent!"
              #endif
  300         
  301         #if defined ( VGEN_GENY )
              #if defined ( CP_XCPDLL_VERSION ) 
              #if ( CP_XCPDLL_VERSION >= 0x0211u )
              #else
              #error "XCP component version and generator version are not consistent!"
              #endif
              #else 
              #if defined ( VGEN_VERSION_CP_XCP_MAIN )
              #if ( ( VGEN_VERSION_CP_XCP_MAIN > 1 ) || ( VGEN_VERSION_CP_XCP_SUB > 5 ) )
              #else
              #error "XCP component version and generator version are not consistent!"
              #endif
              #else
              #error "XCP component version and generator version are not consistent!"
              #endif
              #endif
              #endif
  318         
  319         /* Check specifcation version of AUTOSAR CRC module. */
  320         
  321         
  322         /****************************************************************************/
  323         /* Definitions                                                              */
  324         /****************************************************************************/
  325         
  326         #if defined ( C_COMP_TASKING_ST10_CCAN ) || defined ( C_COMP_TASKING_C16X ) || defined ( C_COMP_TASKING_XC
             -16X )
              #if defined ( XCP_ENABLE_NO_P2INT_CAST ) || defined ( XCP_DISABLE_NO_P2INT_CAST )
              #else
              /* Some uCs use DPPs in the small memory model and encode the information in the most significant bits of 
             -pointers. 
              The DPP register information gets lost if these pointers are converted to integers.
              The following options disables casts from pointers to integer. */
C166 COMPILER V7.57.0, XCPBASIC                                                            01/03/2020 16:20:10 PAGE 7   

              #define XCP_ENABLE_NO_P2INT_CAST
              #endif
              #endif
  335         
  336         
  337         /****************************************************************************/
  338         /* Macros                                                                   */
  339         /****************************************************************************/
  340         
  341         /* Definition of macros that have to be used within the context of XcpCommand. */
  342         /* They have to be declared global Due to MISRA rule 91. */
  343         
  344         /* PRQA S 3458 5 */ /* MD_MSR_19.4 */
  345         #define error(e) { err=(e); goto negative_response; }
  346         #define check_error(e) { err=(e); if (err!=0) { goto negative_response; } }
  347         #define error1(e,b1) { err=(e); CRM_BYTE(2)=(b1); xcp.CrmLen=3; goto negative_response1; }
  348         #define error2(e,b1,b2) { err=(e); CRM_BYTE(2)=(b1); CRM_BYTE(3)=(b2); xcp.CrmLen=4; goto negative_respons
             -e1; }
  349         
  350         #if defined ( XCP_ENABLE_SEED_KEY )
  351         /* Return CRC_ACCESS_LOCKED if the resource is locked. */
  352         #define CheckResourceProtection(resource)   if ( (xcp.ProtectionStatus & (resource)) != 0 ) { error(CRC_AC
             -CESS_LOCKED) } /* PRQA S 3412 */ /* MD_MSR_19.4 */
  353         #else
              /* The resource protection is unavailable. */
              #define CheckResourceProtection(resource)
              #endif
  357         
  358         
  359         
  360         #if defined ( XCP_ENABLE_MEM_ACCESS_BY_APPL )
              #define XCP_WRITE_BYTE_2_ADDR(addr, data)           ApplXcpWrite( (vuint32)(addr), (vuint8)(data) ) /* PRQ
             -A S 3453 */ /* MD_MSR_19.7 */
              #define XCP_READ_BYTE_FROM_ADDR(addr)               ApplXcpRead ( (vuint32)(addr) ) /* PRQA S 3453 */ /* M
             -D_MSR_19.7 */
              #if defined ( XCP_ENABLE_CHECKSUM )
              #if ( kXcpChecksumMethod == XCP_CHECKSUM_TYPE_ADD22 ) || \
                ( kXcpChecksumMethod == XCP_CHECKSUM_TYPE_ADD24 ) || \
              ( kXcpChecksumMethod == XCP_CHECKSUM_TYPE_ADD44 )
              #define XCP_READ_CHECKSUMVALUE_FROM_ADDR(addr)  ApplXcpReadChecksumValue ( (vuint32)(addr) ) /* PRQA S 345
             -3 */ /* MD_MSR_19.7 */
              #else
              #define XCP_READ_CHECKSUMVALUE_FROM_ADDR(addr)  XCP_READ_BYTE_FROM_ADDR(addr) /* PRQA S 3453 */ /* MD_MSR_
             -19.7 */
              #endif
              #endif
              #else
  373         #define XCP_WRITE_BYTE_2_ADDR(addr, data)           *(addr) = (data) /* PRQA S 3453 */ /* MD_MSR_19.7 */
  374         #define XCP_READ_BYTE_FROM_ADDR(addr)               *(addr) /* PRQA S 3453 */ /* MD_MSR_19.7 */
  375         #if defined ( XCP_ENABLE_CHECKSUM )
  376         #if defined ( XCP_ENABLE_CALIBRATION_MEM_ACCESS_BY_APPL )
              #define XCP_READ_CHECKSUMVALUE_FROM_ADDR(addr)    ApplXcpReadChecksumValue ( (vuint32)(addr) ) /* PRQA S 3
             -453 */ /* MD_MSR_19.7 */
              #else
  379         #define XCP_READ_CHECKSUMVALUE_FROM_ADDR(addr)    *((tXcpChecksumAddType*)(addr)) /* PRQA S 3453 */ /* MD_
             -MSR_19.7 */
  380         #endif
  381         #endif
  382         #endif
  383         
  384         /* PRQA S 3458 7 */ /* MD_MSR_19.4 */
  385         #define XcpPlCheckControlState( )
C166 COMPILER V7.57.0, XCPBASIC                                                            01/03/2020 16:20:10 PAGE 8   

  386         #define XcpPlCheckControlStateRet( ret_value )
  387         
  388         /****************************************************************************/
  389         /* Constants                                                                */
  390         /****************************************************************************/
  391         
  392         /****************************************************************************/
  393         /* 8 Bit Constants for export                                               */
  394         /****************************************************************************/
  395         
  396         /* Global constants with XCP Protocol Layer main and subversion */
  397         V_MEMROM0 const vuint8 kXcpMainVersion    = (vuint8)(CP_XCP_VERSION >> 8);
  398         V_MEMROM0 const vuint8 kXcpSubVersion     = (vuint8)(CP_XCP_VERSION & 0x00ff);
  399         V_MEMROM0 const vuint8 kXcpReleaseVersion = (vuint8)(CP_XCP_RELEASE_VERSION);
  400         
  401         
  402         
  403         /****************************************************************************/
  404         /* Local data                                                               */
  405         /****************************************************************************/
  406         
  407         /* This section containes all RAM locations needed by the XCP driver */
  408         
  409         /******************************************************************************/
  410         /* Local Data definitions with unspecified size                               */
  411         /******************************************************************************/
  412         
  413         RAM tXcpData xcp; /* PRQA S 3408 */ /* MD_Xcp_3408 */
  414         
  415         #if defined ( XCP_ENABLE_SEND_QUEUE )
  416         #else
              static tXcpDto dto;
              #endif
  419         
  420         
  421         #if defined ( XCP_ENABLE_TESTMODE )
              vuint8 gDebugLevel;
              #endif
  424         
  425         /******************************************************************************/
  426         /* Local Data definitions with 8Bit size                                      */
  427         /******************************************************************************/
  428         
  429         
  430         
  431         
  432         /***************************************************************************/
  433         /* Prototypes for local functions                                          */
  434         /***************************************************************************/
  435         
  436         static vuint8 XcpWriteMta( vuint8 size, const BYTEPTR data );
  437         static vuint8 XcpReadMta( vuint8 size, BYTEPTR data );
  438         
  439         #if defined ( XcpMemClr )
              #else
  441         static void XcpMemClr( BYTEPTR p, vuint16 n );
  442         #endif
  443         
  444         #if defined ( XCP_ENABLE_SEND_EVENT ) || defined ( XCP_ENABLE_SERV_TEXT )
  445         static void XcpSendEv( void );
  446         #endif
  447         
C166 COMPILER V7.57.0, XCPBASIC                                                            01/03/2020 16:20:10 PAGE 9   

  448         #if defined ( XCP_ENABLE_SEND_QUEUE )
  449         static vuint8 XcpSendDtoFromQueue( void );
  450         static void XcpQueueInit( void );
  451         #endif
  452         
  453         #if defined ( XCP_ENABLE_DAQ )
  454         static void XcpFreeDaq( void );
  455         static vuint8 XcpAllocMemory( void );
  456         static vuint8 XcpAllocDaq( vuint8 daqCount );
  457         static vuint8 XcpAllocOdt( vuint8 daq, vuint8 odtCount );
  458         static vuint8 XcpAllocOdtEntry( vuint8 daq, vuint8 odt, vuint8 odtEntryCount );
  459         static void XcpStartDaq( vuint8 daq );
  460         static void XcpStartAllSelectedDaq( void );
  461         static void XcpStopDaq( vuint8 daq );
  462         static void XcpStopAllSelectedDaq( void );
  463         static void XcpStopAllDaq( void );
  464         
  465         
  466         #endif
  467         
  468         
  469         
  470         /******************************************************************************
  471         *
  472         *
  473         *           Code Part for Cp_Xcp
  474         *
  475         *
  476         *******************************************************************************/
  477         
  478         
  479         /*****************************************************************************
  480         | NAME:             XcpMemSet
  481         | CALLED BY:        XcpFreeDaq
  482         | PRECONDITIONS:    none
  483         | INPUT PARAMETERS: p : pointer to start address.
  484         |                   n : number of data bytes.
  485         |                   d : data byte to initialize with.
  486         | RETURN VALUES:    none 
  487         | DESCRIPTION:      Initialize n bytes starting from address p with b.
  488         ******************************************************************************/
  489         
  490         #if defined ( XcpMemSet )
              /* XcpMemSet is overwritten */
              #else
  493         void XcpMemSet( BYTEPTR p, vuint16 n, vuint8 b )
  494         {
  495  1        for ( ; n > 0; n-- )
  496  1        {
  497  2          *p = b;
  498  2          p++; /* PRQA S 0489 */ /* MD_Xcp_0489 */
  499  2        }
  500  1      }                
  501         #endif
  502         
  503         /*****************************************************************************
  504         | NAME:             XcpMemClr
  505         | CALLED BY:        XcpFreeDaq, XcpInit
  506         | PRECONDITIONS:    none
  507         | INPUT PARAMETERS: p : pointer to start address.
  508         |                   n : number of data bytes.
  509         | RETURN VALUES:    none 
C166 COMPILER V7.57.0, XCPBASIC                                                            01/03/2020 16:20:10 PAGE 10  

  510         | DESCRIPTION:      Initialize n bytes starting from address p 0.
  511         ******************************************************************************/
  512         
  513         #if defined ( XcpMemClr )
              /* XcpMemClr is overwritten */
              #else
  516         /* A macro would be more efficient. Due to MISRA rule 96 violations a function is implemented. */
  517         static void XcpMemClr( BYTEPTR p, vuint16 n )
  518         {
  519  1        XcpMemSet( p, n, (vuint8)0u);
  520  1      }
  521         #endif
  522         
  523         /*****************************************************************************
  524         | NAME:             XcpMemCpy
  525         | CALLED BY:        XcpEvent
  526         | PRECONDITIONS:    none
  527         | INPUT PARAMETERS: dest : pointer to destination address.
  528         |                   src  : pointer to source address.
  529         |                   n    : number of data bytes to copy.
  530         | RETURN VALUES:    none 
  531         | DESCRIPTION:      Copy n bytes from src to dest.
  532         |                   A maximum of 255 Bytes can be copied at once.
  533         ******************************************************************************/
  534         
  535         /* Optimize this function 
  536         It is used in the inner loop of XcpEvent for data acquisition sampling 
  537         */
  538         
  539         #if defined ( XcpMemCpy ) || defined ( C_COMP_COSMIC_MCS12X_MSCAN12 )
              /* XcpMemCpy is overwritten */
              #else
  542         void XcpMemCpy( DAQBYTEPTR dest, const DAQBYTEPTR src, vuint8 n )
  543         {
  544  1        for ( ; n > 0; n-- )
  545  1        {
  546  2          /* ESCAN00092933 */
  547  2          XCP_WRITE_BYTE_2_ADDR( dest, XCP_READ_BYTE_FROM_ADDR(src) );
  548  2          dest++; /* PRQA S 0489 */ /* MD_Xcp_0489 */
  549  2          src++; /* PRQA S 0489 */ /* MD_Xcp_0489 */
  550  2        }
  551  1      }
  552         #endif
  553         
  554         
  555         /*****************************************************************************
  556         | NAME:             XcpSetActiveTl
  557         | CALLED BY:        XcpInit, Tl
  558         | PRECONDITIONS:    none
  559         | INPUT PARAMETERS: MaxCto : Maximum CTO to be used
  560         |                   MaxDto : Maximum DTO to be used
  561         | RETURN VALUES:    none 
  562         | DESCRIPTION:      Set the maximum cto/dto to be used by the XCP.
  563         ******************************************************************************/
  564         void XcpSetActiveTl( vuint8 MaxCto, vuint8 MaxDto, vuint8 ActiveTl )
  565         {
  566  1        UNUSED_PARA(MaxCto);
  567  1        UNUSED_PARA(MaxDto);
  568  1      
  569  1        xcp.Daq.ActiveTl  = ActiveTl;
  570  1      }
  571         
C166 COMPILER V7.57.0, XCPBASIC                                                            01/03/2020 16:20:10 PAGE 11  

  572         /*****************************************************************************
  573         | NAME:             XcpGetActiveTl
  574         | CALLED BY:        Tl
  575         | PRECONDITIONS:    none
  576         | INPUT PARAMETERS: none
  577         | RETURN VALUES:    Active Tl 
  578         | DESCRIPTION:      Get the currently active TL.
  579         ******************************************************************************/
  580         vuint8 XcpGetActiveTl( void )
  581         {
  582  1        return( xcp.Daq.ActiveTl );
  583  1      }
  584         
  585         
  586         
  587         /****************************************************************************/
  588         /* Transmit                                                                 */
  589         /****************************************************************************/
  590         
  591         
  592         /*****************************************************************************
  593         | NAME:             XcpSendCrm
  594         | CALLED BY:        XcpBackground, XcpCommand, XcpSendCallBack, application
  595         | PRECONDITIONS:    XCP is initialized and in connected state and 
  596         |                   a command packet (CMD) has been received.
  597         | INPUT PARAMETERS: none
  598         | RETURN VALUES:    none 
  599         | DESCRIPTION:      Transmission of a command response packet (RES), 
  600         |                    or error packet (ERR) if no other packet is pending.
  601         ******************************************************************************/
  602         void XcpSendCrm( void )
  603         {
  604  1        /* Activation control */
  605  1        XcpPlCheckControlState()
  606  1          
  607  1      #if defined ( XCP_ENABLE_SEND_QUEUE )
  608  1          
  609  1          ApplXcpInterruptDisable();
  610  1        
  611  1        if ( (xcp.SendStatus & (vuint8)XCP_SEND_PENDING) != 0 )
  612  1        {
  613  2          if ( (xcp.SendStatus & (vuint8)XCP_CRM_REQUEST) != 0 )
  614  2          {
  615  3            XCP_ASSERT(0);
  616  3            xcp.SessionStatus |= (SessionStatusType)SS_ERROR; 
  617  3          }
  618  2          xcp.SendStatus |= (vuint8)XCP_CRM_REQUEST;
  619  2        } 
  620  1        else
  621  1        {
  622  2          xcp.SendStatus |= (vuint8)XCP_CRM_PENDING;
  623  2          ApplXcpSend(xcp.CrmLen,&xcp.Crm.b[0]);
  624  2        }
  625  1        
  626  1        ApplXcpInterruptEnable();
  627  1        
  628  1      #else
                
                ApplXcpSend(xcp.CrmLen,&xcp.Crm.b[0]);
                
              #endif
  633  1        
C166 COMPILER V7.57.0, XCPBASIC                                                            01/03/2020 16:20:10 PAGE 12  

  634  1        ApplXcpSendFlush();
  635  1        /* PRQA S 2006 1 */ /* MD_MSR_14.7 */
  636  1      }
  637         
  638         #if defined ( XCP_ENABLE_SEND_EVENT ) || defined ( XCP_ENABLE_SERV_TEXT )
  639         /*****************************************************************************
  640         | NAME:             XcpSendEv
  641         | CALLED BY:        XcpSendEvent, XcpSendCallBack, XcpPutchar
  642         | PRECONDITIONS:    none
  643         | INPUT PARAMETERS: none
  644         | RETURN VALUES:    none 
  645         | DESCRIPTION:      Send a EV or SERV message, if no other message is pending.
  646         ******************************************************************************/
  647         static void XcpSendEv( void )
  648         {      
  649  1      #if defined ( XCP_ENABLE_SEND_QUEUE )
  650  1        
  651  1        ApplXcpInterruptDisable();
  652  1        
  653  1        if ( (xcp.SendStatus & (vuint8)XCP_SEND_PENDING) != 0 )
  654  1        {
  655  2          if ( (xcp.SendStatus & (vuint8)XCP_EVT_REQUEST) != 0 )
  656  2          {
  657  3            XCP_ASSERT(0);
  658  3            xcp.SessionStatus |= (SessionStatusType)SS_ERROR; 
  659  3          }
  660  2          xcp.SendStatus |= (vuint8)XCP_EVT_REQUEST;
  661  2        }
  662  1        else
  663  1        {
  664  2          xcp.SendStatus |= (vuint8)XCP_EVT_PENDING;
  665  2          ApplXcpSend(xcp.EvLen,xcp.Ev.b);
  666  2          xcp.EvLen = 0;
  667  2        }
  668  1        
  669  1        ApplXcpInterruptEnable();
  670  1        
  671  1      #else
                
                ApplXcpSend(xcp.EvLen,xcp.Ev.b);
                xcp.EvLen = 0;
                  
              #endif
  677  1        
  678  1        ApplXcpSendFlush();
  679  1        
  680  1      }
  681         #endif /* XCP_ENABLE_SEND_EVENT || XCP_ENABLE_SERV_TEXT */
  682         
  683         
  684         #if defined ( XCP_ENABLE_DAQ )
  685         /*****************************************************************************
  686         | NAME:             XcpSendDto
  687         | CALLED BY:        XcpSendDtoFromQueue, XcpEvent, XcpSendCallBack
  688         | PRECONDITIONS:    none
  689         | INPUT PARAMETERS: dto : pointer to XCP packet type definition
  690         | RETURN VALUES:    none 
  691         | DESCRIPTION:      Send a DTO.
  692         ******************************************************************************/
  693         #if defined ( XcpSendDto )
              /* XcpSendDto is redefined */
              #else
C166 COMPILER V7.57.0, XCPBASIC                                                            01/03/2020 16:20:10 PAGE 13  

  696         void XcpSendDto( const tXcpDto *dto )
  697         {
  698  1        ApplXcpSend( dto->l, &dto->b[0] );
  699  1      }
  700         #endif
  701         #endif /* XCP_ENABLE_DAQ */
  702         
  703         
  704         #if defined ( XCP_ENABLE_SEND_QUEUE )
  705         /*****************************************************************************
  706         | NAME:             XcpSendDtoFromQueue
  707         | CALLED BY:        XcpEvent, XcpSendCallBack
  708         | PRECONDITIONS:    none
  709         | INPUT PARAMETERS: none
  710         | RETURN VALUES:    0 : DTO has NOT been transmitted from queue. 
  711         |                   1 : DTO has been transmitted from queue. 
  712         | DESCRIPTION:      Send a DTO from the queue.
  713         ******************************************************************************/
  714         static vuint8 XcpSendDtoFromQueue( void )
  715         {
  716  1        ApplXcpInterruptDisable();
  717  1        if ( ( (xcp.SendStatus & (vuint8)XCP_SEND_PENDING) == 0 ) && ( xcp.QueueLen != 0 ))
  718  1        {
  719  2          xcp.SendStatus |= (vuint8)XCP_DTO_PENDING;
  720  2          XcpSendDto(&xcp.pQueue[xcp.QueueRp]);
  721  2          xcp.QueueRp++;
  722  2          if ( xcp.QueueRp >= xcp.QueueSize )
  723  2          {
  724  3            xcp.QueueRp = (vuint16)0u;
  725  3          }
  726  2          xcp.QueueLen--;
  727  2          ApplXcpInterruptEnable();
  728  2          return (vuint8)1u;
  729  2        }
  730  1        ApplXcpInterruptEnable();
  731  1        return (vuint8)0u;
  732  1        /* PRQA S 2006 1 */ /* MD_MSR_14.7 */
  733  1      }
  734         #endif /* XCP_ENABLE_SEND_QUEUE */
  735         
  736         
  737         /****************************************************************************/
  738         /* Transmit Queue */
  739         /****************************************************************************/
  740         
  741         #if defined ( XCP_ENABLE_SEND_QUEUE )
  742         
  743         /*****************************************************************************
  744         | NAME:             XcpQueueInit
  745         | CALLED BY:        XcpFreeDaq, XcpStopDaq, XcpStopAllDaq
  746         | PRECONDITIONS:    none
  747         | INPUT PARAMETERS: none
  748         | RETURN VALUES:    none 
  749         | DESCRIPTION:      Initialize the transmit queue.
  750         ******************************************************************************/
  751         static void XcpQueueInit(void)
  752         {
  753  1        xcp.QueueLen = (vuint16)0u;
  754  1        xcp.QueueRp = (vuint16)0u;
  755  1      }
  756         
  757         #endif /* XCP_ENABLE_SEND_QUEUE */
C166 COMPILER V7.57.0, XCPBASIC                                                            01/03/2020 16:20:10 PAGE 14  

  758         
  759         
  760         /****************************************************************************/
  761         /* Handle Mta (Memory-Transfer-Address) */
  762         /****************************************************************************/
  763         
  764         /* Assign a pointer to a Mta */
  765         #if defined ( XcpSetMta )
              #else
  767         #define XcpSetMta(p,e) (xcp.Mta = (p)) /* PRQA S 3453 */ /* MD_MSR_19.7 */
  768         #endif
  769         
  770         /*****************************************************************************
  771         | NAME:             XcpWriteMta
  772         | CALLED BY:        XcpCommand
  773         | PRECONDITIONS:    none
  774         | INPUT PARAMETERS: size : number of data bytes.
  775         |                   data : address of data.
  776         | RETURN VALUES:    XCP_CMD_OK, XCP_CMD_DENIED
  777         | DESCRIPTION:      Write n bytes.
  778         |                   Copying of size bytes from data to xcp.Mta
  779         ******************************************************************************/
  780         static vuint8 XcpWriteMta( vuint8 size, const BYTEPTR data )
  781         {
  782  1      #if defined ( XCP_ENABLE_CALIBRATION_MEM_ACCESS_BY_APPL )
                vuint8 r;
              #endif
  785  1        
  786  1        /* DPRAM Client */
  787  1        
  788  1        /* Checked ram memory write access */
  789  1        
  790  1        /* EEPROM write access */
  791  1        
  792  1        /* Standard RAM memory write access */
  793  1      #if defined ( XCP_ENABLE_CALIBRATION_MEM_ACCESS_BY_APPL ) && !defined ( XCP_ENABLE_MEM_ACCESS_BY_APPL )
                r = ApplXcpCalibrationWrite(xcp.Mta, size, data);
                xcp.Mta += size; /* PRQA S 0488 */ /* MD_Xcp_0488 */
                return r;
              #else
  798  1        while ( size > (vuint8)0u ) 
  799  1        {
  800  2          XCP_WRITE_BYTE_2_ADDR( xcp.Mta, *data );
  801  2          xcp.Mta++; /* PRQA S 0489 */ /* MD_Xcp_0489 */
  802  2          data++; /* PRQA S 0489 */ /* MD_Xcp_0489 */
  803  2          size--;
  804  2        }
  805  1        return (vuint8)XCP_CMD_OK;
  806  1      #endif
  807  1        /* PRQA S 2006 1 */ /* MD_MSR_14.7 */
  808  1      }
  809         
  810         /*****************************************************************************
  811         | NAME:             XcpReadMta
  812         | CALLED BY:        XcpCommand
  813         | PRECONDITIONS:    none
  814         | INPUT PARAMETERS: size :
  815         |                   data : address of data
  816         | RETURN VALUES:    XCP_CMD_OK
  817         | DESCRIPTION:      Read n bytes.
  818         |                   Copying of size bytes from data to xcp.Mta
  819         ******************************************************************************/
C166 COMPILER V7.57.0, XCPBASIC                                                            01/03/2020 16:20:10 PAGE 15  

  820         static vuint8 XcpReadMta( vuint8 size, BYTEPTR data )
  821         {
  822  1      #if defined ( XCP_ENABLE_CALIBRATION_MEM_ACCESS_BY_APPL )
                vuint8 r;
              #endif
  825  1        
  826  1        /* DPRAM Client */
  827  1        
  828  1        /* Checked ram memory read access */
  829  1        
  830  1        /* EEPROM read access */
  831  1        
  832  1      #if defined ( XCP_ENABLE_CALIBRATION_MEM_ACCESS_BY_APPL ) && !defined ( XCP_ENABLE_MEM_ACCESS_BY_APPL )
                r = ApplXcpCalibrationRead(xcp.Mta, size, data);
                xcp.Mta += size; /* PRQA S 0488 */ /* MD_Xcp_0488 */
                return r;
              #else
  837  1        /* Standard RAM memory read access */
  838  1        while (size > 0)
  839  1        {
  840  2          /* 
  841  2        Compiler bug Tasking
  842  2        *(data++) = *(xcp.Mta++);
  843  2          */
  844  2          *(data) = XCP_READ_BYTE_FROM_ADDR( xcp.Mta );
  845  2          data++; /* PRQA S 0489 */ /* MD_Xcp_0489 */
  846  2          xcp.Mta++; /* PRQA S 0489 */ /* MD_Xcp_0489 */
  847  2          size--;
  848  2        }
  849  1        return (vuint8)XCP_CMD_OK;
  850  1      #endif
  851  1        /* PRQA S 2006 1 */ /* MD_MSR_14.7 */
  852  1      }
  853         
  854         
  855         /****************************************************************************/
  856         /* Data Aquisition Setup                                                    */
  857         /****************************************************************************/
  858         
  859         
  860         #if defined ( XCP_ENABLE_DAQ )
  861         
  862         /*****************************************************************************
  863         | NAME:             XcpFreeDaq
  864         | CALLED BY:        XcpCommand
  865         | PRECONDITIONS:    none
  866         | INPUT PARAMETERS: none
  867         | RETURN VALUES:    none
  868         | DESCRIPTION:      Free all dynamic DAQ lists
  869         ******************************************************************************/
  870         static void XcpFreeDaq( void )
  871         {
  872  1        xcp.SessionStatus &= (SessionStatusType)((~SS_DAQ) & 0xFFu);
  873  1        
  874  1        xcp.Daq.DaqCount = 0;
  875  1        xcp.Daq.OdtCount = 0;
  876  1        xcp.Daq.OdtEntryCount = 0;
  877  1        
  878  1        xcp.pOdt = (tXcpOdt*)0;
  879  1        xcp.pOdtEntryAddr = 0;
  880  1        xcp.pOdtEntrySize = 0;
  881  1        
C166 COMPILER V7.57.0, XCPBASIC                                                            01/03/2020 16:20:10 PAGE 16  

  882  1        XcpMemClr((BYTEPTR)&xcp.Daq.u.b[0], (vuint16)kXcpDaqMemSize);  /* Deviation of MISRA rule 44. */
  883  1      #if defined ( kXcpMaxEvent ) && ! defined ( XCP_ENABLE_DAQ_PRESCALER )
                  XcpMemSet( (BYTEPTR)&xcp.Daq.EventDaq[0], (vuint16)sizeof(xcp.Daq.EventDaq), (vuint8)0xFFu);  /* Devia
             -tion of MISRA rule 44. */
              #endif
  886  1        
  887  1      #if defined ( XCP_ENABLE_SEND_QUEUE )
  888  1        XcpQueueInit();
  889  1      #endif
  890  1      }
  891         
  892         /*****************************************************************************
  893         | NAME:             XcpAllocMemory
  894         | CALLED BY:        XcpAllocDaq, XcpAllocOdt, XcpAllocOdtEntry, XcpInit
  895         | PRECONDITIONS:    none
  896         | INPUT PARAMETERS: none
  897         | RETURN VALUES:    0, CRC_MEMORY_OVERFLOW
  898         | DESCRIPTION:      Allocate Memory for daq,odt,odtEntries and Queue
  899         |                   according to DaqCount, OdtCount and OdtEntryCount
  900         ******************************************************************************/
  901         static vuint8 XcpAllocMemory( void )
  902         {
  903  1        vuint16 s;
  904  1      #if defined ( XCP_ENABLE_NO_P2INT_CAST  )
                vuint8* p;
                vuint8  i;
              #endif
  908  1        
  909  1        /* Check memory overflow */
  910  1        s = (vuint16)( ( xcp.Daq.DaqCount      *   (vuint8)sizeof(tXcpDaqList)                           ) + 
  911  1          ( xcp.Daq.OdtCount      *  (vuint16)sizeof(tXcpOdt)                               ) + 
  912  1          ( xcp.Daq.OdtEntryCount * ( (vuint8)sizeof(DAQBYTEPTR) + (vuint8)sizeof(vuint8) ) )
  913  1          );
  914  1      #if defined ( XCP_DISABLE_UNALIGNED_MEM_ACCESS )
  915  1      #if defined ( C_CPUTYPE_8BIT ) || defined ( C_CPUTYPE_16BIT )
                s += 5; /* Worst case 5 bytes needed for alignment */ /* ESCAN00091645 */
              #else
  918  1        s += 9; /* Worst case 9 bytes needed for alignment */
  919  1      #endif
  920  1      #endif
  921  1        
  922  1        if (s>=(vuint16)kXcpDaqMemSize) 
  923  1        {
  924  2          return (vuint8)CRC_MEMORY_OVERFLOW;
  925  2        }
  926  1        
  927  1        /* Force WORD alignment for ODTs */
  928  1      #if defined ( XCP_DISABLE_UNALIGNED_MEM_ACCESS )
  929  1      #if defined ( XCP_ENABLE_NO_P2INT_CAST  )
                p = (vuint8*)&xcp.Daq.u.DaqList[xcp.Daq.DaqCount];
                i = ((vuint8)p) & (vuint8)0x01u;
                p += i;
                xcp.pOdt = (tXcpOdt*)p;
              #else
  935  1      #if defined ( C_CPUTYPE_8BIT ) || defined ( C_CPUTYPE_16BIT )
                /* Align to words */
                xcp.pOdt = (tXcpOdt*)((((vuint32)(&xcp.Daq.u.DaqList[xcp.Daq.DaqCount])) + (vuint32)1u) & (vuint32)0xFFFF
             -FFFEu ); /* PRQA S 0306 */ /* MD_Xcp_0306 */
              #else
  939  1        /* Align to dwords */
  940  1        xcp.pOdt = (tXcpOdt*)((((vuint32)(&xcp.Daq.u.DaqList[xcp.Daq.DaqCount])) + (vuint32)3u) & (vuint32)0xFFFF
             -FFFCu ); /* PRQA S 0306 */ /* MD_Xcp_0306 */
C166 COMPILER V7.57.0, XCPBASIC                                                            01/03/2020 16:20:10 PAGE 17  

  941  1      #endif
  942  1      #endif
  943  1      #else
                xcp.pOdt = (tXcpOdt*)&xcp.Daq.u.DaqList[xcp.Daq.DaqCount];
              #endif
  946  1        
  947  1        /* Force DWORD alignment for ODT entries */
  948  1      #if defined ( XCP_DISABLE_UNALIGNED_MEM_ACCESS )
  949  1      #if defined ( XCP_ENABLE_NO_P2INT_CAST  )
                p = (vuint8*)&xcp.pOdt[xcp.Daq.OdtCount];
                i = ((vuint8)p) & (vuint8)0x03u;
                i = (vuint8)4u - i;
                i &= 0x03;
                p += i;
                xcp.pOdtEntryAddr = (DAQBYTEPTR*)p;
              #else
  957  1        xcp.pOdtEntryAddr = (DAQBYTEPTR*) ((((vuint32)&xcp.pOdt[xcp.Daq.OdtCount]) + (vuint32)3u) & (vuint32)0xFF
             -FFFFFCu ); /* PRQA S 0306 */ /* MD_Xcp_0306 */
  958  1      #endif
  959  1      #else
                xcp.pOdtEntryAddr = (DAQBYTEPTR*)&xcp.pOdt[xcp.Daq.OdtCount];
              #endif
  962  1        xcp.pOdtEntrySize = (vuint8*)&xcp.pOdtEntryAddr[xcp.Daq.OdtEntryCount]; /* PRQA S 0310 */ /* MD_Xcp_0310 
             -*/
  963  1        
  964  1      #if defined ( XCP_ENABLE_SEND_QUEUE )
  965  1        /* Force WORD alignment for the queue */
  966  1      #if defined ( XCP_DISABLE_UNALIGNED_MEM_ACCESS )
  967  1      #if defined ( XCP_ENABLE_NO_P2INT_CAST )
                p = (vuint8*)&xcp.pOdtEntrySize[xcp.Daq.OdtEntryCount];
                i = ((vuint8)p) & (vuint8)0x01u;
                p += i;
                xcp.pQueue = (tXcpDto*)p;
              #else
  973  1      #if defined ( C_CPUTYPE_8BIT ) || defined ( C_CPUTYPE_16BIT )
                /* Allign to words */
                xcp.pQueue = (tXcpDto*)((((vuint32)(&xcp.pOdtEntrySize[xcp.Daq.OdtEntryCount])) + (vuint32)1u) & (vuint32
             -)0xFFFFFFFEu ); /* PRQA S 0306 */ /* MD_Xcp_0306 */
              #else
  977  1        /* Allign to dwords */
  978  1        xcp.pQueue = (tXcpDto*)((((vuint32)(&xcp.pOdtEntrySize[xcp.Daq.OdtEntryCount])) + (vuint32)3u) & (vuint32
             -)0xFFFFFFFCu ); /* PRQA S 0306 */ /* MD_Xcp_0306 */
  979  1      #endif
  980  1      #endif
  981  1      #else
                xcp.pQueue = (tXcpDto*)&xcp.pOdtEntrySize[xcp.Daq.OdtEntryCount];
              #endif
  984  1        
  985  1        xcp.QueueSize = ((vuint16)kXcpDaqMemSize - s) / sizeof(tXcpDto);
  986  1        
  987  1      #if defined ( kXcpSendQueueMinSize )
                if (xcp.QueueSize<(vuint16)kXcpSendQueueMinSize)
                {
                  return (vuint8)CRC_MEMORY_OVERFLOW;
                }
              #else
  993  1        /* At least one queue entry per odt */
  994  1        if (xcp.QueueSize<xcp.Daq.OdtCount)
  995  1        {
  996  2          return (vuint8)CRC_MEMORY_OVERFLOW;
  997  2        }
  998  1      #endif
C166 COMPILER V7.57.0, XCPBASIC                                                            01/03/2020 16:20:10 PAGE 18  

  999  1      #endif /* XCP_ENABLE_SEND_QUEUE */
 1000  1        
 1001  1      #if defined ( XCP_ENABLE_TESTMODE )
                if ( gDebugLevel != 0)
                {
                  ApplXcpPrint("[XcpAllocMemory] %u/%u Bytes used\n",s,kXcpDaqMemSize );
              #if defined ( XCP_ENABLE_SEND_QUEUE )
                  ApplXcpPrint("[XcpAllocMemory] Queuesize=%u\n",xcp.QueueSize );
              #endif
                }
              #endif
 1010  1        
 1011  1        return (vuint8)0u;
 1012  1        /* PRQA S 2006 1 */ /* MD_MSR_14.7 */
 1013  1      }
 1014         
 1015         
 1016         
 1017         /*****************************************************************************
 1018         | NAME:             XcpAllocDaq
 1019         | CALLED BY:        XcpCommand
 1020         | PRECONDITIONS:    none
 1021         | INPUT PARAMETERS: daqCount : 
 1022         | RETURN VALUES:    return value of XcpAllocMemory, CRC_SEQUENCE
 1023         | DESCRIPTION:      Allocate DAQ list
 1024         ******************************************************************************/
 1025         static vuint8 XcpAllocDaq( vuint8 daqCount )
 1026         {
 1027  1      #if defined ( XCP_ENABLE_PARAMETER_CHECK )
                if ( (xcp.Daq.OdtCount!=0) || (xcp.Daq.OdtEntryCount!=0) )
                {
                  return (vuint8)CRC_SEQUENCE;
                }
                if( daqCount == 0 )
                {
                  return (vuint8)CRC_OUT_OF_RANGE;
                }
              #endif
 1037  1        
 1038  1        xcp.Daq.DaqCount = daqCount;
 1039  1        
 1040  1        return XcpAllocMemory();
 1041  1        /* PRQA S 2006 1 */ /* MD_MSR_14.7 */
 1042  1      }
 1043         
 1044         /*****************************************************************************
 1045         | NAME:             XcpAllocOdt
 1046         | CALLED BY:        XcpCommand
 1047         | PRECONDITIONS:    none
 1048         | INPUT PARAMETERS: daq      : 
 1049         |                   odtCount :
 1050         | RETURN VALUES:    return value of XcpAllocMemory,
 1051         |                   CRC_SEQUENCE, CRC_MEMORY_OVERFLOW
 1052         | DESCRIPTION:      Allocate all ODTs in a DAQ list
 1053         ******************************************************************************/
 1054         static vuint8 XcpAllocOdt( vuint8 daq, vuint8 odtCount )
 1055         {
 1056  1      #if defined ( XCP_ENABLE_PARAMETER_CHECK )
                if ( (xcp.Daq.DaqCount==0) || (xcp.Daq.OdtEntryCount!=0) )
                {
                  return (vuint8)CRC_SEQUENCE;
                }
C166 COMPILER V7.57.0, XCPBASIC                                                            01/03/2020 16:20:10 PAGE 19  

                if( odtCount == 0 )
                {
                  return (vuint8)CRC_OUT_OF_RANGE;
                }
              #endif
 1066  1        
 1067  1        /* Absolute ODT count must fit in a BYTE */
 1068  1      #if !defined ( XCP_ENABLE_DAQ_HDR_ODT_DAQ )
 1069  1      #if defined XCP_ENABLE_DAQ_OVERRUN_INDICATION
 1070  1          if (((vuint16)xcp.Daq.OdtCount+(vuint16)odtCount) > (vuint16)0x7Bu) /* ESCAN00090685 */ /* ESCAN000929
             -34 */
 1071  1      #else
                  if (((vuint16)xcp.Daq.OdtCount+(vuint16)odtCount) > (vuint16)0xFBu)
              #endif
 1074  1          {
 1075  2            return (vuint8)CRC_MEMORY_OVERFLOW;
 1076  2          }
 1077  1      #endif
 1078  1          
 1079  1          xcp.Daq.u.DaqList[daq].firstOdt = xcp.Daq.OdtCount;
 1080  1          xcp.Daq.OdtCount += odtCount;
 1081  1          xcp.Daq.u.DaqList[daq].lastOdt = (tXcpOdtIdx)(xcp.Daq.OdtCount-1);
 1082  1          
 1083  1          return XcpAllocMemory();
 1084  1          /* PRQA S 2006 1 */ /* MD_MSR_14.7 */
 1085  1      }
 1086         
 1087         /*****************************************************************************
 1088         | NAME:             XcpAllocOdtEntry
 1089         | CALLED BY:        XcpCommand
 1090         | PRECONDITIONS:    none
 1091         | INPUT PARAMETERS: daq :
 1092         |                   odt :
 1093         |                   odtEntryCount :
 1094         | RETURN VALUES:    return value of XcpAllocMemory
 1095         | DESCRIPTION:      Allocate all ODT entries
 1096         |                   Parameter odt is relative odt number
 1097         ******************************************************************************/
 1098         static vuint8 XcpAllocOdtEntry( vuint8 daq, vuint8 odt, vuint8 odtEntryCount )
 1099         {
 1100  1        tXcpOdtIdx xcpFirstOdt;
 1101  1        
 1102  1      #if defined ( XCP_ENABLE_PARAMETER_CHECK )
                if ( (xcp.Daq.DaqCount==0) || (xcp.Daq.OdtCount==0) )
                {
                  return (vuint8)CRC_SEQUENCE;
                }
                if (odtEntryCount==0)
                {
                  return (vuint8)CRC_OUT_OF_RANGE;
                }
              #endif
 1112  1        
 1113  1        /* Absolute ODT entry count count must fit in a WORD */
 1114  1        if (xcp.Daq.OdtEntryCount > (0xFFFFu - odtEntryCount))
 1115  1        {
 1116  2          return (vuint8)CRC_MEMORY_OVERFLOW;
 1117  2        }
 1118  1        xcpFirstOdt = xcp.Daq.u.DaqList[daq].firstOdt;
 1119  1        xcp.pOdt[xcpFirstOdt+odt].firstOdtEntry = xcp.Daq.OdtEntryCount;
 1120  1        xcp.Daq.OdtEntryCount += (vuint16)odtEntryCount;
 1121  1        xcp.pOdt[xcpFirstOdt+odt].lastOdtEntry = (vuint16)(xcp.Daq.OdtEntryCount-1);
C166 COMPILER V7.57.0, XCPBASIC                                                            01/03/2020 16:20:10 PAGE 20  

 1122  1        
 1123  1        return XcpAllocMemory();
 1124  1        /* PRQA S 2006 1 */ /* MD_MSR_14.7 */
 1125  1      }
 1126         
 1127         /*****************************************************************************
 1128         | NAME:             XcpStartDaq
 1129         | CALLED BY:        XcpCommand, XcpStartAllSelectedDaq
 1130         | PRECONDITIONS:    none
 1131         | INPUT PARAMETERS: daq :
 1132         | RETURN VALUES:    none
 1133         | DESCRIPTION:      Start DAQ
 1134         ******************************************************************************/
 1135         static void XcpStartDaq( vuint8 daq )
 1136         {
 1137  1        /* Initialize the DAQ list */
 1138  1        DaqListFlags(daq) |= (vuint8)DAQ_FLAG_RUNNING;
 1139  1      #if defined ( XCP_ENABLE_DAQ_PRESCALER )
 1140  1        DaqListCycle(daq) = 1;
 1141  1      #endif
 1142  1        
 1143  1        xcp.SessionStatus |= (SessionStatusType)SS_DAQ;
 1144  1      }
 1145         
 1146         /*****************************************************************************
 1147         | NAME:             XcpStartAllSelectedDaq
 1148         | CALLED BY:        XcpCommand, XcpInit
 1149         | PRECONDITIONS:    none
 1150         | INPUT PARAMETERS: none
 1151         | RETURN VALUES:    none
 1152         | DESCRIPTION:      Start all selected DAQs
 1153         ******************************************************************************/
 1154         static void XcpStartAllSelectedDaq(void)
 1155         {
 1156  1        vuint8 daq;
 1157  1        
 1158  1        /* Start all selected DAQs */
 1159  1        for (daq=0;daq<xcp.Daq.DaqCount;daq++)
 1160  1        {
 1161  2          if ( (DaqListFlags(daq) & (vuint8)DAQ_FLAG_SELECTED) != 0 )
 1162  2          {
 1163  3            XcpStartDaq(daq);
 1164  3            DaqListFlags(daq) &= (vuint8)(~DAQ_FLAG_SELECTED & 0x00FFu);
 1165  3          }
 1166  2        }
 1167  1      }
 1168         
 1169         /*****************************************************************************
 1170         | NAME:             XcpStopDaq
 1171         | CALLED BY:        XcpCommand, XcpStopAllSelectedDaq
 1172         | PRECONDITIONS:    none
 1173         | INPUT PARAMETERS: daq : 
 1174         | RETURN VALUES:    none
 1175         | DESCRIPTION:      Stop DAQ
 1176         ******************************************************************************/
 1177         static void XcpStopDaq( vuint8 daq )
 1178         {
 1179  1        vuint8 i;
 1180  1        
 1181  1        DaqListFlags(daq) &= (vuint8)(DAQ_FLAG_DIRECTION|DAQ_FLAG_TIMESTAMP|DAQ_FLAG_NO_PID);
 1182  1        
 1183  1        /* Check if all DAQ lists are stopped */
C166 COMPILER V7.57.0, XCPBASIC                                                            01/03/2020 16:20:10 PAGE 21  

 1184  1        for (i=0;i<xcp.Daq.DaqCount;i++)
 1185  1        {
 1186  2          if ( (DaqListFlags(i) & (vuint8)DAQ_FLAG_RUNNING) != 0 )
 1187  2          {
 1188  3            return;
 1189  3          }
 1190  2        }
 1191  1        
 1192  1        xcp.SessionStatus &= (SessionStatusType)(~SS_DAQ & 0x00FFu);
 1193  1        
 1194  1      #if defined ( XCP_ENABLE_SEND_QUEUE )
 1195  1        XcpQueueInit();
 1196  1      #endif
 1197  1        /* PRQA S 2006 1 */ /* MD_MSR_14.7 */
 1198  1      }
 1199         
 1200         /*****************************************************************************
 1201         | NAME:             XcpStopAllSelectedDaq
 1202         | CALLED BY:        XcpCommand
 1203         | PRECONDITIONS:    none
 1204         | INPUT PARAMETERS: none 
 1205         | RETURN VALUES:    none
 1206         | DESCRIPTION:      Stop all selected DAQs
 1207         ******************************************************************************/
 1208         static void XcpStopAllSelectedDaq(void)
 1209         {
 1210  1        vuint8 daq;
 1211  1        
 1212  1        for (daq=0;daq<xcp.Daq.DaqCount;daq++)
 1213  1        {
 1214  2          if ( (DaqListFlags(daq) & (vuint8)DAQ_FLAG_SELECTED) != 0 )
 1215  2          {
 1216  3            XcpStopDaq(daq);
 1217  3            DaqListFlags(daq) &= (vuint8)(~DAQ_FLAG_SELECTED & 0x00FFu);
 1218  3          }
 1219  2        }
 1220  1      }
 1221         
 1222         /*****************************************************************************
 1223         | NAME:             XcpStopAllDaq
 1224         | CALLED BY:        XcpCommand, XcpDisconnect
 1225         | PRECONDITIONS:    none
 1226         | INPUT PARAMETERS: none 
 1227         | RETURN VALUES:    none
 1228         | DESCRIPTION:      Stop all DAQs
 1229         ******************************************************************************/
 1230         static void XcpStopAllDaq( void )
 1231         {
 1232  1        vuint8 daq;
 1233  1        
 1234  1        for (daq=0; daq<xcp.Daq.DaqCount; daq++)
 1235  1        {
 1236  2          DaqListFlags(daq) &= (vuint8)(DAQ_FLAG_DIRECTION|DAQ_FLAG_TIMESTAMP|DAQ_FLAG_NO_PID);
 1237  2        }
 1238  1        
 1239  1        xcp.SessionStatus &= (SessionStatusType)(~SS_DAQ & 0x00FFu);
 1240  1        
 1241  1      #if defined ( XCP_ENABLE_SEND_QUEUE )
 1242  1        XcpQueueInit();
 1243  1      #endif
 1244  1      }
 1245         
C166 COMPILER V7.57.0, XCPBASIC                                                            01/03/2020 16:20:10 PAGE 22  

 1246         
 1247         /****************************************************************************/
 1248         /* Data Aquisition Processor                                                */
 1249         /****************************************************************************/
 1250         
 1251         /*****************************************************************************
 1252         | NAME:             XcpStimEventStatus
 1253         | CALLED BY:        application
 1254         | PRECONDITIONS:    The XCP is initialized and in connected state.
 1255         | INPUT PARAMETERS: event : event channel number to process
 1256         |                   action : 
 1257         | RETURN VALUES:    1 (TRUE) if STIM data is available and XcpEvent() can be called
 1258         | DESCRIPTION:      Handling of data acquisition event channel.
 1259         ******************************************************************************/
 1260         
 1261         /*****************************************************************************
 1262         | NAME:             XcpEvent
 1263         | CALLED BY:        application
 1264         | PRECONDITIONS:    The XCP is initialized and in connected state.
 1265         | INPUT PARAMETERS: event : event channel number to process
 1266         | RETURN VALUES:    status code (XCP_EVENT_...)
 1267         | DESCRIPTION:      Handling of data acquisition or stimulation event channel.
 1268         ******************************************************************************/
 1269         vuint8 XcpEvent( vuint8 event )
 1270         {
 1271  1        tXcpDto *dtop;
 1272  1        BYTEPTR d;
 1273  1        vuint8  status;
 1274  1        vuint16 e,el;
 1275  1        vuint8  n;
 1276  1        vuint8  daq;
 1277  1        tXcpOdtIdx odt;
 1278  1        vuint8  i;
 1279  1      #if defined ( XCP_ENABLE_DAQ_TIMESTAMP ) && defined ( XCP_DISABLE_UNALIGNED_MEM_ACCESS )
 1280  1        XcpDaqTimestampType t;
 1281  1      #endif
 1282  1      #if defined ( C_COMP_COSMIC_MCS12X_MSCAN12 )
                DAQBYTEPTR src;
              #endif
 1285  1        
 1286  1        
 1287  1        status = (vuint8)0u;
 1288  1        
 1289  1        if ( (xcp.SessionStatus & (SessionStatusType)SS_DAQ) == 0 )
 1290  1        {
 1291  2          return (vuint8)XCP_EVENT_NOP;
 1292  2        }
 1293  1        
 1294  1        /* Activation control */
 1295  1        XcpPlCheckControlStateRet((vuint8)XCP_EVENT_NOP)
 1296  1          
 1297  1      #if defined ( kXcpMaxEvent ) && ! defined ( XCP_ENABLE_DAQ_PRESCALER )
                  
              #if defined ( XCP_ENABLE_PARAMETER_CHECK )
                  if (event >= (vuint8)kXcpMaxEvent)
                  {
                    return (vuint8)XCP_EVENT_NOP;
                  }
              #endif
                  
                  BEGIN_PROFILE(4); /* Timingtest */
                  daq = xcp.Daq.EventDaq[event];
C166 COMPILER V7.57.0, XCPBASIC                                                            01/03/2020 16:20:10 PAGE 23  

                  if ( ((daq<xcp.Daq.DaqCount) && ( (DaqListFlags(daq) & (vuint8)DAQ_FLAG_RUNNING) != 0 )) != 0 )
                  {
                    
              #else
 1312  1            
 1313  1            BEGIN_PROFILE(4); /* Timingtest */
 1314  1            for (daq=0; daq<xcp.Daq.DaqCount; daq++)
 1315  1            {
 1316  2              if ( (DaqListFlags(daq)& (vuint8)DAQ_FLAG_RUNNING) == 0 )
 1317  2              {
 1318  3                continue; /* PRQA S 0770 */ /* MD_Xcp_0770 */
 1319  3              }
 1320  2              if ( DaqListEventChannel(daq) != event )
 1321  2              {
 1322  3                continue; /* PRQA S 0770 */ /* MD_Xcp_0770 */
 1323  3              }
 1324  2              
 1325  2      #endif
 1326  2              
 1327  2      #if defined ( XCP_ENABLE_DAQ_PRESCALER )
 1328  2              DaqListCycle(daq)--;
 1329  2              if ( DaqListCycle(daq) == (vuint8)0 )
 1330  2              {
 1331  3                DaqListCycle(daq) = DaqListPrescaler(daq);
 1332  3      #endif
 1333  3                
 1334  3                /* Data Stimulation (STIM) */
 1335  3                
 1336  3                for (odt=DaqListFirstOdt(daq);odt<=DaqListLastOdt(daq);odt++)
 1337  3                {
 1338  4      #if defined ( XCP_ENABLE_SEND_QUEUE )
 1339  4                  vuint16 qs;
 1340  4      #endif
 1341  4                  status |= (vuint8)XCP_EVENT_DAQ;
 1342  4                  
 1343  4                  
 1344  4                  ApplXcpInterruptDisable(); /* The following code is not reentrant */
 1345  4                  
 1346  4      #if defined ( XCP_ENABLE_SEND_QUEUE )
 1347  4                  /* Check if there is space in the queue for this ODT */
 1348  4                  if (xcp.QueueLen>=xcp.QueueSize)
 1349  4                  {
 1350  5                    status |= (vuint8)XCP_EVENT_DAQ_OVERRUN; /* Queue overflow */
 1351  5                    DaqListFlags(daq) |= (vuint8)DAQ_FLAG_OVERRUN;
 1352  5                    goto next_odt; /* PRQA S 2001 */ /* MD_Xcp_2001 */
 1353  5                  }
 1354  4                  
 1355  4                  qs = (xcp.QueueRp + xcp.QueueLen);
 1356  4                  if(qs >= xcp.QueueSize)
 1357  4                  {
 1358  5                    qs -= xcp.QueueSize;
 1359  5                  }
 1360  4                  
 1361  4                  dtop = &xcp.pQueue[qs];
 1362  4      #if defined ( XCP_SEND_QUEUE_SAMPLE_ODT )
                          xcp.QueueLen++;
              #endif
 1365  4      #else
                          dtop = &dto;
              #endif /* XCP_ENABLE_SEND_QUEUE */
 1368  4                  
 1369  4      #if defined ( XCP_ENABLE_DAQ_HDR_ODT_DAQ )
C166 COMPILER V7.57.0, XCPBASIC                                                            01/03/2020 16:20:10 PAGE 24  

                          
                          /* ODT,DAQ */
                          dtop->b[0] = odt-DaqListFirstOdt(daq); /* Relative odt number */
                          dtop->b[1] = daq;
                          i = 2;
                          
              #else
 1377  4                  
 1378  4                  /* PID */
 1379  4                  dtop->b[0] = odt;
 1380  4                  i = 1;
 1381  4                  
 1382  4      #endif
 1383  4                  
 1384  4                  /* Use BIT7 of PID or ODT to indicate overruns */
 1385  4      #if defined ( XCP_ENABLE_SEND_QUEUE )
 1386  4      #if defined ( XCP_ENABLE_DAQ_OVERRUN_INDICATION )
 1387  4                  if ( (DaqListFlags(daq) & (vuint8)DAQ_FLAG_OVERRUN) != 0 )
 1388  4                  {
 1389  5                    dtop->b[0] |= (vuint8)0x80;
 1390  5                    DaqListFlags(daq) &= (vuint8)(~DAQ_FLAG_OVERRUN & 0xFFu);
 1391  5                  }
 1392  4      #endif
 1393  4      #endif
 1394  4                  
 1395  4                  /* Timestamps */
 1396  4      #if defined ( XCP_ENABLE_DAQ_TIMESTAMP )
 1397  4                  
 1398  4      #if !defined ( XCP_ENABLE_DAQ_TIMESTAMP_FIXED )
 1399  4                  if ( (DaqListFlags(daq) & (vuint8)DAQ_FLAG_TIMESTAMP) != 0 )
 1400  4                  {
 1401  5      #endif
 1402  5                    
 1403  5                    if (odt==DaqListFirstOdt(daq))
 1404  5                    {
 1405  6      #if defined ( XCP_DISABLE_UNALIGNED_MEM_ACCESS )
 1406  6                      t = ApplXcpGetTimestamp();
 1407  6      #endif
 1408  6                      
 1409  6      #if defined ( XCP_ENABLE_DAQ_HDR_ODT_DAQ )
                              
                              *(XcpDaqTimestampType*)&dtop->b[2] = ApplXcpGetTimestamp();
                              i = 2 + XcpDaqTimestampSize;
                              
              #else /* XCP_ENABLE_DAQ_HDR_ODT_DAQ */
 1415  6                      
 1416  6      #if defined ( XCP_DISABLE_UNALIGNED_MEM_ACCESS )
 1417  6      #if defined ( XCP_CPUTYPE_BIGENDIAN )  /* Avoid WORD access */
              #if( kXcpDaqTimestampSize == DAQ_TIMESTAMP_BYTE )
                              dtop->b[i+0u] = (vuint8)t;
              #elif( kXcpDaqTimestampSize == DAQ_TIMESTAMP_WORD )
                              dtop->b[i+1u] = (vuint8)t;
                              dtop->b[i+0u] = (vuint8)(t>>8);
              #elif( kXcpDaqTimestampSize == DAQ_TIMESTAMP_DWORD )
                              dtop->b[i+3u] = (vuint8)t;
                              dtop->b[i+2u] = (vuint8)(t>>8);
                              dtop->b[i+1u] = (vuint8)(t>>16);
                              dtop->b[i+0u] = (vuint8)(t>>24);
              #endif
              #else
 1430  6                      dtop->b[i+0u] = (vuint8)t;
 1431  6      #if( kXcpDaqTimestampSize > DAQ_TIMESTAMP_BYTE )
C166 COMPILER V7.57.0, XCPBASIC                                                            01/03/2020 16:20:10 PAGE 25  

 1432  6                      dtop->b[i+1u] = (vuint8)(t>>8);
 1433  6      #endif
 1434  6      #if( kXcpDaqTimestampSize > DAQ_TIMESTAMP_WORD )
                              dtop->b[i+2u] = (vuint8)(t>>16);
                              dtop->b[i+3u] = (vuint8)(t>>24);
              #endif
 1438  6      #endif
 1439  6      #else
                              *(XcpDaqTimestampType*)&dtop->b[i] = ApplXcpGetTimestamp();
              #endif /* XCP_DISABLE_UNALIGNED_MEM_ACCESS */
 1442  6                      i += XcpDaqTimestampSize;
 1443  6                      
 1444  6      #endif /* XCP_ENABLE_DAQ_HDR_ODT_DAQ */
 1445  6                    }
 1446  5                    
 1447  5      #if !defined ( XCP_ENABLE_DAQ_TIMESTAMP_FIXED )
 1448  5                  }
 1449  4      #endif
 1450  4                  
 1451  4      #endif /* XCP_ENABLE_DAQ_TIMESTAMP */
 1452  4                  
 1453  4                  /* Sample data */
 1454  4                  /* This is the inner loop, optimize here */
 1455  4                  e = DaqListOdtFirstEntry(odt);
 1456  4                  if (OdtEntrySize(e)==0)
 1457  4                  {
 1458  5                    goto next_odt; /* PRQA S 2001 */ /* MD_Xcp_2001 */
 1459  5                  }
 1460  4                  el = DaqListOdtLastEntry(odt);
 1461  4                  d = (vuint8*)&dtop->b[i];
 1462  4                  
 1463  4                  while (e<=el)
 1464  4                  {
 1465  5                    n = OdtEntrySize(e);
 1466  5                    if (n == 0)
 1467  5                    {
 1468  6                      break;
 1469  6                    }
 1470  5      #if defined ( C_COMP_COSMIC_MCS12X_MSCAN12 )
                            src = (vuint32)OdtEntryAddr(e);
                            for ( ; n > 0; n-- )
                            {
                              *d = XCP_READ_BYTE_FROM_ADDR( src );
                              d++;
                              src++;
                            }
              #else
 1479  5                    XcpMemCpy((DAQBYTEPTR)d, OdtEntryAddr(e), n);
 1480  5                    d = &d[n]; /* d += n; Suppress warning for MISRA rule 101 (pointer arithmetic) */
 1481  5      #endif
 1482  5                    e++;
 1483  5                  }
 1484  4                  dtop->l = (vuint8)(d-(&dtop->b[0]) ); /* PRQA S 0488 */ /* MD_Xcp_0488 */
 1485  4                  XCP_ASSERT(dtop->l<=kXcpMaxDTO);
 1486  4                  
 1487  4                  /* Queue or transmit the DTO */
 1488  4      #if defined ( XCP_ENABLE_SEND_QUEUE )
 1489  4      #if defined ( XCP_SEND_QUEUE_SAMPLE_ODT )
                          /* No action yet */
              #else
 1492  4                  if ( (xcp.SendStatus & (vuint8)XCP_SEND_PENDING) != 0 )
 1493  4                  {
C166 COMPILER V7.57.0, XCPBASIC                                                            01/03/2020 16:20:10 PAGE 26  

 1494  5                    xcp.QueueLen++;
 1495  5                  }
 1496  4                  else
 1497  4                  {
 1498  5                    xcp.SendStatus |= (vuint8)XCP_DTO_PENDING;
 1499  5                    XcpSendDto(dtop);
 1500  5                  }
 1501  4      #endif
 1502  4      #else
                          XcpSendDto(&dto);
              #endif /* XCP_ENABLE_SEND_QUEUE */
 1505  4      next_odt:
 1506  4                  
 1507  4                  ApplXcpInterruptEnable();
 1508  4                  
 1509  4            } /* odt */
 1510  3          
 1511  3      #if defined ( XCP_ENABLE_SEND_QUEUE ) && defined ( XCP_SEND_QUEUE_SAMPLE_ODT )
                    (void)XcpSendDtoFromQueue();
              #endif
 1514  3          
 1515  3          
 1516  3      #if defined ( XCP_ENABLE_DAQ_PRESCALER )
 1517  3          }
 1518  2      #endif
 1519  2        
 1520  2        } /* daq */
 1521  1        
 1522  1        END_PROFILE(4); /* Timingtest */
 1523  1        return status; 
 1524  1        /* PRQA S 2006 4 */ /* MD_MSR_14.7 */
 1525  1        /* PRQA S 6010 3 */ /* MD_MSR_STPTH */
 1526  1        /* PRQA S 6030 2 */ /* MD_MSR_STCYC */
 1527  1        /* PRQA S 6080 1 */ /* MD_MSR_STMIF */
 1528  1      }
 1529         
 1530         #endif /* XCP_ENABLE_DAQ */
 1531         
 1532         
 1533         /****************************************************************************/
 1534         /* Background Processing                                                    */
 1535         /* Used for Checksum Calculation                                            */
 1536         /****************************************************************************/
 1537         
 1538         #if defined ( XCP_ENABLE_CHECKSUM )
 1539         /* Table for CCITT checksum calculation */
 1540         #if ( kXcpChecksumMethod == XCP_CHECKSUM_TYPE_CRC16CCITT )
              
              
              
              V_MEMROM0 const vuint16 CRC16CCITTtab[256] = { /* PRQA S 3408 */ /* MD_Xcp_3408 */
              #if defined ( XCP_ENABLE_CRC16CCITT_REFLECTED )
                  0x0000,0x1189,0x2312,0x329B,0x4624,0x57AD,0x6536,0x74BF,
                  0x8C48,0x9DC1,0xAF5A,0xBED3,0xCA6C,0xDBE5,0xE97E,0xF8F7,
                  0x1081,0x0108,0x3393,0x221A,0x56A5,0x472C,0x75B7,0x643E,
                  0x9CC9,0x8D40,0xBFDB,0xAE52,0xDAED,0xCB64,0xF9FF,0xE876,
                  0x2102,0x308B,0x0210,0x1399,0x6726,0x76AF,0x4434,0x55BD,
                  0xAD4A,0xBCC3,0x8E58,0x9FD1,0xEB6E,0xFAE7,0xC87C,0xD9F5,
                  0x3183,0x200A,0x1291,0x0318,0x77A7,0x662E,0x54B5,0x453C,
                  0xBDCB,0xAC42,0x9ED9,0x8F50,0xFBEF,0xEA66,0xD8FD,0xC974,
                  0x4204,0x538D,0x6116,0x709F,0x0420,0x15A9,0x2732,0x36BB,
                  0xCE4C,0xDFC5,0xED5E,0xFCD7,0x8868,0x99E1,0xAB7A,0xBAF3,
C166 COMPILER V7.57.0, XCPBASIC                                                            01/03/2020 16:20:10 PAGE 27  

                  0x5285,0x430C,0x7197,0x601E,0x14A1,0x0528,0x37B3,0x263A,
                  0xDECD,0xCF44,0xFDDF,0xEC56,0x98E9,0x8960,0xBBFB,0xAA72,
                  0x6306,0x728F,0x4014,0x519D,0x2522,0x34AB,0x0630,0x17B9,
                  0xEF4E,0xFEC7,0xCC5C,0xDDD5,0xA96A,0xB8E3,0x8A78,0x9BF1,
                  0x7387,0x620E,0x5095,0x411C,0x35A3,0x242A,0x16B1,0x0738,
                  0xFFCF,0xEE46,0xDCDD,0xCD54,0xB9EB,0xA862,0x9AF9,0x8B70,
                  0x8408,0x9581,0xA71A,0xB693,0xC22C,0xD3A5,0xE13E,0xF0B7,
                  0x0840,0x19C9,0x2B52,0x3ADB,0x4E64,0x5FED,0x6D76,0x7CFF,
                  0x9489,0x8500,0xB79B,0xA612,0xD2AD,0xC324,0xF1BF,0xE036,
                  0x18C1,0x0948,0x3BD3,0x2A5A,0x5EE5,0x4F6C,0x7DF7,0x6C7E,
                  0xA50A,0xB483,0x8618,0x9791,0xE32E,0xF2A7,0xC03C,0xD1B5,
                  0x2942,0x38CB,0x0A50,0x1BD9,0x6F66,0x7EEF,0x4C74,0x5DFD,
                  0xB58B,0xA402,0x9699,0x8710,0xF3AF,0xE226,0xD0BD,0xC134,
                  0x39C3,0x284A,0x1AD1,0x0B58,0x7FE7,0x6E6E,0x5CF5,0x4D7C,
                  0xC60C,0xD785,0xE51E,0xF497,0x8028,0x91A1,0xA33A,0xB2B3,
                  0x4A44,0x5BCD,0x6956,0x78DF,0x0C60,0x1DE9,0x2F72,0x3EFB,
                  0xD68D,0xC704,0xF59F,0xE416,0x90A9,0x8120,0xB3BB,0xA232,
                  0x5AC5,0x4B4C,0x79D7,0x685E,0x1CE1,0x0D68,0x3FF3,0x2E7A,
                  0xE70E,0xF687,0xC41C,0xD595,0xA12A,0xB0A3,0x8238,0x93B1,
                  0x6B46,0x7ACF,0x4854,0x59DD,0x2D62,0x3CEB,0x0E70,0x1FF9,
                  0xF78F,0xE606,0xD49D,0xC514,0xB1AB,0xA022,0x92B9,0x8330,
                  0x7BC7,0x6A4E,0x58D5,0x495C,0x3DE3,0x2C6A,0x1EF1,0x0F78
              #else
                  0x0000,0x1021,0x2042,0x3063,0x4084,0x50a5,0x60c6,0x70e7u,
                  0x8108,0x9129,0xa14a,0xb16b,0xc18c,0xd1ad,0xe1ce,0xf1efu,
                  0x1231,0x0210,0x3273,0x2252,0x52b5,0x4294,0x72f7,0x62d6u,
                  0x9339,0x8318,0xb37b,0xa35a,0xd3bd,0xc39c,0xf3ff,0xe3deu,
                  0x2462,0x3443,0x0420,0x1401,0x64e6,0x74c7,0x44a4,0x5485u,
                  0xa56a,0xb54b,0x8528,0x9509,0xe5ee,0xf5cf,0xc5ac,0xd58du,
                  0x3653,0x2672,0x1611,0x0630,0x76d7,0x66f6,0x5695,0x46b4u,
                  0xb75b,0xa77a,0x9719,0x8738,0xf7df,0xe7fe,0xd79d,0xc7bcu,
                  0x48c4,0x58e5,0x6886,0x78a7,0x0840,0x1861,0x2802,0x3823u,
                  0xc9cc,0xd9ed,0xe98e,0xf9af,0x8948,0x9969,0xa90a,0xb92bu,
                  0x5af5,0x4ad4,0x7ab7,0x6a96,0x1a71,0x0a50,0x3a33,0x2a12u,
                  0xdbfd,0xcbdc,0xfbbf,0xeb9e,0x9b79,0x8b58,0xbb3b,0xab1au,
                  0x6ca6,0x7c87,0x4ce4,0x5cc5,0x2c22,0x3c03,0x0c60,0x1c41u,
                  0xedae,0xfd8f,0xcdec,0xddcd,0xad2a,0xbd0b,0x8d68,0x9d49u,
                  0x7e97,0x6eb6,0x5ed5,0x4ef4,0x3e13,0x2e32,0x1e51,0x0e70u,
                  0xff9f,0xefbe,0xdfdd,0xcffc,0xbf1b,0xaf3a,0x9f59,0x8f78u,
                  0x9188,0x81a9,0xb1ca,0xa1eb,0xd10c,0xc12d,0xf14e,0xe16fu,
                  0x1080,0x00a1,0x30c2,0x20e3,0x5004,0x4025,0x7046,0x6067u,
                  0x83b9,0x9398,0xa3fb,0xb3da,0xc33d,0xd31c,0xe37f,0xf35eu,
                  0x02b1,0x1290,0x22f3,0x32d2,0x4235,0x5214,0x6277,0x7256u,
                  0xb5ea,0xa5cb,0x95a8,0x8589,0xf56e,0xe54f,0xd52c,0xc50du,
                  0x34e2,0x24c3,0x14a0,0x0481,0x7466,0x6447,0x5424,0x4405u,
                  0xa7db,0xb7fa,0x8799,0x97b8,0xe75f,0xf77e,0xc71d,0xd73cu,
                  0x26d3,0x36f2,0x0691,0x16b0,0x6657,0x7676,0x4615,0x5634u,
                  0xd94c,0xc96d,0xf90e,0xe92f,0x99c8,0x89e9,0xb98a,0xa9abu,
                  0x5844,0x4865,0x7806,0x6827,0x18c0,0x08e1,0x3882,0x28a3u,
                  0xcb7d,0xdb5c,0xeb3f,0xfb1e,0x8bf9,0x9bd8,0xabbb,0xbb9au,
                  0x4a75,0x5a54,0x6a37,0x7a16,0x0af1,0x1ad0,0x2ab3,0x3a92u,
                  0xfd2e,0xed0f,0xdd6c,0xcd4d,0xbdaa,0xad8b,0x9de8,0x8dc9u,
                  0x7c26,0x6c07,0x5c64,0x4c45,0x3ca2,0x2c83,0x1ce0,0x0cc1u,
                  0xef1f,0xff3e,0xcf5d,0xdf7c,0xaf9b,0xbfba,0x8fd9,0x9ff8u,
                  0x6e17,0x7e36,0x4e55,0x5e74,0x2e93,0x3eb2,0x0ed1,0x1ef0u
              #endif /* defined ( XCP_ENABLE_CRC16CCITT_REFLECTED ) */
              };
              
              
              
              #endif /* ( kXcpChecksumMethod == XCP_CHECKSUM_TYPE_CRC16CCITT ) */
 1617         
C166 COMPILER V7.57.0, XCPBASIC                                                            01/03/2020 16:20:10 PAGE 28  

 1618         
 1619         #if !defined ( kXcpChecksumBlockSize )
 1620         #define kXcpChecksumBlockSize 256
 1621         #endif
 1622         
 1623         #endif /* defined ( XCP_ENABLE_CHECKSUM ) */
 1624         
 1625         
 1626         /*****************************************************************************
 1627         | NAME:             XcpBackground
 1628         | CALLED BY:        application
 1629         | PRECONDITIONS:    none
 1630         | INPUT PARAMETERS: none 
 1631         | RETURN VALUES:    0 : background calculation finished
 1632         |                   1 : background calculation still pending
 1633         | DESCRIPTION:      perform background calculation of checksum
 1634         ******************************************************************************/
 1635         vuint8 XcpBackground( void )
 1636         {
 1637  1        
 1638  1        BEGIN_PROFILE(3); /* Timingtest */
 1639  1        
 1640  1        /* Activation control */
 1641  1        XcpPlCheckControlStateRet((vuint8)0u)
 1642  1          
 1643  1          /* STORE_DAQ_REQ or CLEAR_DAQ_REQ pending */
 1644  1      #if defined ( XCP_ENABLE_DAQ )
 1645  1      #endif /* XCP_ENABLE_DAQ */
 1646  1          
 1647  1          /* XCP checksum calculation */
 1648  1      #if defined ( XCP_ENABLE_CHECKSUM ) && !defined ( XCP_ENABLE_CUSTOM_CRC )
 1649  1          
 1650  1          /*
 1651  1          Checksum algorithm is not defined by the standard
 1652  1          Type is defined by tXcpChecksumSumType, the maximum blocksize is 64K
 1653  1          */
 1654  1          
 1655  1          /* Checksum calculation in progress */
 1656  1          if ( (xcp.CheckSumSize) != (tXcpChecksumSumType)0u )
 1657  1          {
 1658  2            
 1659  2            vuint16 n;
 1660  2            
 1661  2            if (xcp.CheckSumSize<=(kXcpChecksumBlockSize-1))
 1662  2            {
 1663  3              n = xcp.CheckSumSize;
 1664  3              xcp.CheckSumSize = 0;
 1665  3            }
 1666  2            else
 1667  2            {
 1668  3              n = (vuint16)kXcpChecksumBlockSize;
 1669  3              xcp.CheckSumSize -= kXcpChecksumBlockSize;
 1670  3            }
 1671  2            
 1672  2            
 1673  2            do
 1674  2            {
 1675  3              tXcpChecksumAddType data;
 1676  3              data = XCP_READ_CHECKSUMVALUE_FROM_ADDR( xcp.Mta );
 1677  3              
 1678  3      #if ( kXcpChecksumMethod == XCP_CHECKSUM_TYPE_CRC16CCITT )
                      
C166 COMPILER V7.57.0, XCPBASIC                                                            01/03/2020 16:20:10 PAGE 29  

              #if defined ( XCP_ENABLE_CRC16CCITT_REFLECTED )
                      /* CRC16 CCITT Reflected: Refin = true and refout = true. */
                      xcp.CheckSum = CRC16CCITTtab[((vuint8)(xcp.CheckSum&0xFF)) ^ data] ^ ((vuint8)((xcp.CheckSum>>8)&0xFF)
             -);
              #else
                      /* CRC16 CCITT */
                      xcp.CheckSum = CRC16CCITTtab[((vuint8)((xcp.CheckSum >> 8)&0xFF)) ^ data] ^ (xcp.CheckSum << 8);
              #endif
                      
                      xcp.Mta++; /* PRQA S 0489 */ /* MD_Xcp_0489 */
                      n--;
                      
              #else
 1692  3              
 1693  3              /* Checksum calculation method: XCP_ADD_xx */
 1694  3              xcp.CheckSum += (tXcpChecksumSumType)(data);
 1695  3      #if ( kXcpChecksumMethod == XCP_CHECKSUM_TYPE_ADD11 )
                      xcp.CheckSum &= 0xFF;
              #endif
 1698  3              xcp.Mta      += (vuint8)tXcpChecksumAddSize; /* PRQA S 0488 */ /* MD_Xcp_0488 */
 1699  3              n            -= (vuint8)tXcpChecksumAddSize;
 1700  3              
 1701  3      #endif
 1702  3            } 
 1703  2            while (n!=0);
 1704  2            
 1705  2            
 1706  2            /* Checksum calculation finished ? */
 1707  2            if ( (xcp.CheckSumSize) != 0 )
 1708  2            {
 1709  3              END_PROFILE(3); /* Timingtest */
 1710  3              return (vuint8)1u; /* Still pending */
 1711  3            }
 1712  2            
 1713  2            CRM_BUILD_CHECKSUM_TYPE = kXcpChecksumMethod;
 1714  2            /* PRQA S 3757 1 */ /* MD_Xcp_3757 */
 1715  2            CRM_BUILD_CHECKSUM_RESULT_WRITE(xcp.CheckSum); /* PRQA S 3109 */ /* MD_MSR_14.3 */
 1716  2            xcp.CrmLen = CRM_BUILD_CHECKSUM_LEN;
 1717  2            
 1718  2      #if defined ( XCP_ENABLE_TESTMODE )
                    if ( gDebugLevel != 0) 
                    {
                      ApplXcpPrint("<- 0xFF checksum=%08Xh, type=%02Xh\n",CRM_BUILD_CHECKSUM_RESULT,CRM_BUILD_CHECKSUM_TYPE)
             -;
                    }
              #endif
 1724  2            
 1725  2            XcpSendCrm();
 1726  2            
 1727  2          } /* xcp.CheckSumSize */
 1728  1      #endif /* XCP_ENABLE_CHECKSUM && !XCP_ENABLE_CUSTOM_CRC */
 1729  1          
 1730  1          /* Application specific background ground loop. */ 
 1731  1          ApplXcpBackground();
 1732  1          
 1733  1          END_PROFILE(3); /* Timingtest */
 1734  1          
 1735  1          return (vuint8)0u;
 1736  1          /* PRQA S 2006 2 */ /* MD_MSR_14.7 */
 1737  1          /* PRQA S 6010 1 */ /* MD_MSR_STPTH */
 1738  1      }
 1739         
C166 COMPILER V7.57.0, XCPBASIC                                                            01/03/2020 16:20:10 PAGE 30  

 1740         
 1741         /****************************************************************************/
 1742         /* Command Processor                                                        */
 1743         /****************************************************************************/
 1744         
 1745         
 1746         /*****************************************************************************
 1747         | NAME:             XcpDisconnect
 1748         | CALLED BY:        XcpCommand
 1749         | PRECONDITIONS:    XCP is initialized and in connected state.
 1750         | INPUT PARAMETERS: none 
 1751         | RETURN VALUES:    none
 1752         | DESCRIPTION:      If the XCP slave is connected to a XCP master a call of this
 1753         |                   function discontinues the connection (transition to disconnected state).
 1754         |                   If the XCP slave is not connected this function performs no action.
 1755         ******************************************************************************/
 1756         void XcpDisconnect( void )
 1757         {
 1758  1        /* Activation control */
 1759  1        XcpPlCheckControlState()
 1760  1          
 1761  1          xcp.SessionStatus &= (SessionStatusType)(~SS_CONNECTED & 0xFFu);
 1762  1        
 1763  1      #if defined ( XCP_ENABLE_DAQ )
 1764  1        XcpStopAllDaq();
 1765  1      #endif
 1766  1      #if defined ( XCP_ENABLE_SEED_KEY )
 1767  1        /* Lock all resources */
 1768  1        xcp.ProtectionStatus = (vuint8)RM_CAL_PAG|RM_DAQ|RM_PGM|RM_STIM;
 1769  1      #endif
 1770  1        
 1771  1        /* PRQA S 2006 1 */ /* MD_MSR_14.7 */
 1772  1      }
 1773         
 1774         
 1775         /*****************************************************************************
 1776         | NAME:             XcpCommand
 1777         | CALLED BY:        XcpSendCallBack, XCP Transport Layer
 1778         | PRECONDITIONS:    none
 1779         | INPUT PARAMETERS: pCmd : data of received CTO message.
 1780         | RETURN VALUES:    none
 1781         | DESCRIPTION:      
 1782         ******************************************************************************/
 1783         void XcpCommand( const vuint32* pCommand )
 1784         {
 1785  1        const tXcpCto* pCmd = (const tXcpCto*) pCommand; /* PRQA S 0310 */ /* MD_Xcp_0310 */
 1786  1        vuint8 err;
 1787  1        
 1788  1        /* Activation control */
 1789  1        XcpPlCheckControlState()
 1790  1          
 1791  1          /* XCP Data Stimulation Handler */
 1792  1          
 1793  1          
 1794  1          
 1795  1          /* XCP Command Handler */
 1796  1          
 1797  1          BEGIN_PROFILE(1); /* Timingtest */
 1798  1        
 1799  1        /* CONNECT */
 1800  1        if (CRO_CMD==CC_CONNECT)
 1801  1        {
C166 COMPILER V7.57.0, XCPBASIC                                                            01/03/2020 16:20:10 PAGE 31  

 1802  2          
 1803  2          /* Prepare the default response */
 1804  2          /* ESCAN00023570 */
 1805  2          CRM_CMD = 0xFF; /* No Error */
 1806  2          xcp.CrmLen = 1; /* Length = 1 */
 1807  2          
 1808  2      #if defined ( XCP_ENABLE_TESTMODE )
                  if ( gDebugLevel != 0) 
                  {
                    ApplXcpPrint("\n-> CONNECT mode=%u\n",CRO_CONNECT_MODE);
                  }
              #endif
 1814  2          
 1815  2          /* DPRAM */
 1816  2          /* DPRAM Client */
 1817  2          
 1818  2          /* Reset DAQ */
 1819  2          /* Do not reset DAQ if in resume mode */ 
 1820  2      #if defined ( XCP_ENABLE_DAQ )
 1821  2          if ( (xcp.SessionStatus & (SessionStatusType)SS_RESUME) == 0 )
 1822  2          {
 1823  3            XcpFreeDaq();
 1824  3      #if defined ( XCP_ENABLE_SEND_QUEUE )
 1825  3            xcp.SendStatus = 0; /* Clear all transmission flags */
 1826  3      #endif
 1827  3          }
 1828  2      #endif /* XCP_ENABLE_DAQ */
 1829  2          
 1830  2      #if defined ( XCP_ENABLE_SEED_KEY )
 1831  2          /* Lock all resources. */
 1832  2          xcp.ProtectionStatus = (vuint8)RM_CAL_PAG|RM_DAQ|RM_PGM|RM_STIM;
 1833  2      #endif
 1834  2          
 1835  2          /* Reset Session Status */
 1836  2          xcp.SessionStatus = (SessionStatusType)SS_CONNECTED;
 1837  2          
 1838  2          xcp.CrmLen = CRM_CONNECT_LEN;
 1839  2          
 1840  2          /* Versions of the XCP Protocol Layer and Transport Layer Specifications. */
 1841  2          CRM_CONNECT_TRANSPORT_VERSION = (vuint8)( (vuint16)XCP_TRANSPORT_LAYER_VERSION >> 8 );
 1842  2          CRM_CONNECT_PROTOCOL_VERSION =  (vuint8)( (vuint16)XCP_VERSION >> 8 );
 1843  2          
 1844  2          CRM_CONNECT_MAX_CTO_SIZE = kXcpMaxCTO;
 1845  2          CRM_CONNECT_MAX_DTO_SIZE_WRITE(kXcpMaxDTO); /* PRQA S 3109 */ /* MD_MSR_14.3 */
 1846  2          
 1847  2      #if defined ( XCP_ENABLE_CALIBRATION_PAGE )
 1848  2          CRM_CONNECT_RESOURCE = RM_CAL_PAG;            /* Calibration */
 1849  2      #else
                  CRM_CONNECT_RESOURCE = 0x00;                  /* Reset resource mask */
              #endif
 1852  2      #if defined ( XCP_ENABLE_DAQ )
 1853  2          CRM_CONNECT_RESOURCE |= (vuint8)RM_DAQ;       /* Data Acquisition */
 1854  2      #endif
 1855  2          
 1856  2          CRM_CONNECT_COMM_BASIC = 0;
 1857  2      #if defined ( XCP_ENABLE_COMM_MODE_INFO )
 1858  2          CRM_CONNECT_COMM_BASIC |= (vuint8)CMB_OPTIONAL;
 1859  2      #endif
 1860  2      #if defined ( XCP_CPUTYPE_BIGENDIAN )
                  CRM_CONNECT_COMM_BASIC |= (vuint8)PI_MOTOROLA;
              #endif
 1863  2          
C166 COMPILER V7.57.0, XCPBASIC                                                            01/03/2020 16:20:10 PAGE 32  

 1864  2          XCP_PRINT(("<- 0xFF version=%02Xh/%02Xh, maxcro=%02Xh, maxdto=%02Xh, resource=%02X, mode=%02X\n",
 1870  2            CRM_CONNECT_PROTOCOL_VERSION,
 1870  2            CRM_CONNECT_TRANSPORT_VERSION,
 1870  2            CRM_CONNECT_MAX_CTO_SIZE,
 1870  2            CRM_CONNECT_MAX_DTO_SIZE,
 1870  2            CRM_CONNECT_RESOURCE,
 1870  2            CRM_CONNECT_COMM_BASIC));
 1871  2          
 1872  2          goto positive_response; /* PRQA S 2001 */ /* MD_Xcp_2001 */
 1873  2          
 1874  2        }
 1875  1        
 1876  1        /* Handle other commands only if connected */
 1877  1        else /* CC_CONNECT */
 1878  1        {
 1879  2          if ( (xcp.SessionStatus & (SessionStatusType)SS_CONNECTED) != 0 )
 1880  2          {
 1881  3            /* Ignore commands if the previous command sequence has not been completed */
 1882  3      #if defined ( XCP_ENABLE_SEND_QUEUE )
 1883  3            if ( (xcp.SendStatus & (vuint8)(XCP_CRM_PENDING|XCP_CRM_REQUEST)) != 0 )
 1884  3            {
 1885  4              xcp.SessionStatus |= (SessionStatusType)SS_ERROR; 
 1886  4              END_PROFILE(1); /* Timingtest */
 1887  4              
 1888  4              /* No response */
 1889  4              return;
 1890  4            }
 1891  3      #endif
 1892  3            
 1893  3      #if defined ( XCP_ENABLE_GET_SESSION_STATUS_API )
                    xcp.SessionStatus |= (SessionStatusType)SS_POLLING;
              #endif
 1896  3            
 1897  3            /* Prepare the default response */
 1898  3            /* ESCAN00023570 */
 1899  3            CRM_CMD = 0xFF; /* No Error */
 1900  3            xcp.CrmLen = 1; /* Length = 1 */
 1901  3            
 1902  3            switch (CRO_CMD)
 1903  3            {
 1904  4              
 1905  4            case CC_SYNC:
 1906  4              {
 1907  5                /* Always return a negative response with the error code ERR_CMD_SYNCH. */
 1908  5                xcp.CrmLen = CRM_SYNCH_LEN;
 1909  5                CRM_CMD    = PID_ERR;
 1910  5                CRM_ERR    = CRC_CMD_SYNCH;
 1911  5                
 1912  5      #if defined ( XCP_ENABLE_TESTMODE )
                        if ( gDebugLevel != 0) 
                        {
                          ApplXcpPrint("-> SYNC\n");
                          ApplXcpPrint("<- 0xFE 0x00\n");
                        }
              #endif
 1919  5              }
 1920  4              break;
 1921  4              
 1922  4              
 1923  4      #if defined ( XCP_ENABLE_COMM_MODE_INFO )
 1924  4            case CC_GET_COMM_MODE_INFO:
 1925  4              {
C166 COMPILER V7.57.0, XCPBASIC                                                            01/03/2020 16:20:10 PAGE 33  

 1926  5                xcp.CrmLen = CRM_GET_COMM_MODE_INFO_LEN;
 1927  5                /* Transmit the version of the XCP Protocol Layer implementation.    */
 1928  5                /* The higher nibble is the main version, the lower the sub version. */
 1929  5                /* The lower nibble overflows, if the sub version is greater than 15.*/
 1930  5                CRM_GET_COMM_MODE_INFO_DRIVER_VERSION = (vuint8)( ((CP_XCP_VERSION & 0x0F00) >> 4) |
 1931  5                  (CP_XCP_VERSION & 0x000F)         );
 1932  5                CRM_GET_COMM_MODE_INFO_COMM_OPTIONAL = 0;
 1933  5                CRM_GET_COMM_MODE_INFO_QUEUE_SIZE = 0;
 1934  5                CRM_GET_COMM_MODE_INFO_MAX_BS = 0;
 1935  5                CRM_GET_COMM_MODE_INFO_MIN_ST = 0;
 1936  5                
 1937  5      #if defined ( XCP_ENABLE_TESTMODE )
                        if ( gDebugLevel != 0)
                        {
                          ApplXcpPrint("-> GET_COMM_MODE_INFO\n");
                          ApplXcpPrint("<- 0xFF \n");
                        }
              #endif
 1944  5                
 1945  5              }
 1946  4              break;
 1947  4      #endif /* XCP_ENABLE_COMM_MODE_INFO */
 1948  4              
 1949  4              
 1950  4            case CC_DISCONNECT:
 1951  4              {
 1952  5                xcp.CrmLen = CRM_DISCONNECT_LEN;
 1953  5                XcpDisconnect();
 1954  5                
 1955  5      #if defined ( XCP_ENABLE_TESTMODE )
                        if ( gDebugLevel != 0)
                        {
                          ApplXcpPrint("-> DISCONNECT\n");
                          ApplXcpPrint("<- 0xFF\n");
                        }
              #endif
 1962  5              }
 1963  4              break;
 1964  4              
 1965  4              
 1966  4      #if defined ( kXcpStationIdLength ) || defined ( XCP_ENABLE_GET_ID_GENERIC )
 1967  4            case CC_GET_ID:
 1968  4              {
 1969  5                xcp.CrmLen = CRM_GET_ID_LEN;
 1970  5                CRM_GET_ID_MODE = 0;
 1971  5                CRM_GET_ID_LENGTH_WRITE(0x00); /* PRQA S 3109 */ /* MD_MSR_14.3 */
 1972  5                
 1973  5      #if defined ( kXcpStationIdLength )
 1974  5                if ( CRO_GET_ID_TYPE == IDT_ASAM_NAME )   /* Type = ASAM MC2 */
 1975  5                {
 1976  6                  CRM_GET_ID_LENGTH_WRITE((vuint32)kXcpStationIdLength); /* PRQA S 3109 */ /* MD_MSR_14.3 */
 1977  6                  XcpSetMta( ApplXcpGetPointer(0xFF, (vuint32)(&kXcpStationId[0])), 0xFF); /* PRQA S 0306 */ /* MD_Xcp
             -_0306 */
 1978  6                } else
 1979  5      #endif
 1980  5                {
 1981  6      #if defined ( XCP_ENABLE_GET_ID_GENERIC )
                          MTABYTEPTR pData;
                          /* PRQA S 3757 1 */ /* MD_Xcp_3757 */
                          CRM_GET_ID_LENGTH_WRITE(ApplXcpGetIdData(&pData, CRO_GET_ID_TYPE)); /* PRQA S 3109 */ /* MD_MSR_14.3
             - */
                          XcpSetMta(ApplXcpGetPointer(0x00, (vuint32)pData), 0xFF); /* PRQA S 0306 */ /* MD_Xcp_0306 */
C166 COMPILER V7.57.0, XCPBASIC                                                            01/03/2020 16:20:10 PAGE 34  

              #endif
 1987  6                }
 1988  5                
 1989  5      #if defined ( XCP_ENABLE_TESTMODE )
                        if ( gDebugLevel != 0)
                        {
                          ApplXcpPrint("-> GET_ID type=%u\n",CRO_GET_ID_TYPE);
                          ApplXcpPrint("<- 0xFF mode=%u,len=%u\n",CRM_GET_ID_MODE,CRM_GET_ID_LENGTH);
                        }
              #endif
 1996  5              }
 1997  4              break;                    
 1998  4      #endif
 1999  4              
 2000  4              
 2001  4            case CC_GET_STATUS: 
 2002  4              {
 2003  5                xcp.CrmLen = CRM_GET_STATUS_LEN;
 2004  5                CRM_GET_STATUS_STATUS = (vuint8)xcp.SessionStatus;
 2005  5      #if defined ( XCP_ENABLE_SEED_KEY )
 2006  5                /* Return current resource protection status. If a bit is one, the associated resource is locked. */
 2007  5                CRM_GET_STATUS_PROTECTION = xcp.ProtectionStatus;
 2008  5      #else
                        CRM_GET_STATUS_PROTECTION = 0;
              #endif
 2011  5                
 2012  5                /* Session configuration ID not available. */
 2013  5                CRM_GET_STATUS_CONFIG_ID_WRITE(0x00);
 2014  5                
 2015  5      #if defined ( XCP_ENABLE_TESTMODE )
                        if ( gDebugLevel != 0)
                        {
                          ApplXcpPrint("-> GET_STATUS\n");
                          ApplXcpPrint("<- 0xFF sessionstatus=%02Xh, protectionstatus=%02X\n",CRM_GET_STATUS_STATUS,CRM_GET_ST
             -ATUS_PROTECTION);
                        }
              #endif
 2022  5              }
 2023  4              break;
 2024  4              
 2025  4              
 2026  4      #if defined ( XCP_ENABLE_SEED_KEY )
 2027  4              
 2028  4            case CC_GET_SEED:
 2029  4              {
 2030  5                /* Only seeds with a maximum length of MAX_CTO-2 are supported so far. */
 2031  5                
 2032  5                /* Check whether the first part or a remaining part of the seed is requested. */
 2033  5                if (CRO_GET_SEED_MODE == 0x01)
 2034  5                {
 2035  6                  /* Remaining parts of seeds are not supported so far. */
 2036  6                  error(CRC_OUT_OF_RANGE) /* PRQA S 2001 */ /* MD_Xcp_2001 */
 2037  6                }
 2038  5                else
 2039  5                {
 2040  6      #if defined ( XCP_ENABLE_PARAMETER_CHECK )
                          /* Only one resource may be requested at one time. */
                          switch (CRO_GET_SEED_RESOURCE)
                          {
                          case RM_CAL_PAG: 
                            break;
                          case RM_PGM:
C166 COMPILER V7.57.0, XCPBASIC                                                            01/03/2020 16:20:10 PAGE 35  

                            break;
                          case RM_DAQ:
                            break;
                          case RM_STIM:
                            break;
                          default:
                            error(CRC_OUT_OF_RANGE) /* PRQA S 2001 */ /* MD_Xcp_2001 */
                          }
                          
              #endif                
 2057  6                  if ((xcp.ProtectionStatus & CRO_GET_SEED_RESOURCE) != 0)   /* locked */
 2058  6                  {
 2059  7                    vuint8 seedLength;
 2060  7                    seedLength = ApplXcpGetSeed(CRO_GET_SEED_RESOURCE, CRM_GET_SEED_DATA); 
 2061  7                    if (seedLength > (vuint8)(kXcpMaxCTO-2))
 2062  7                    {
 2063  8                      /* A maximum seed length of MAX_CTO-2 is supported. */
 2064  8                      error(CRC_OUT_OF_RANGE) /* PRQA S 2001 */ /* MD_Xcp_2001 */
 2065  8                    }
 2066  7                    CRM_GET_SEED_LENGTH = seedLength;
 2067  7                  }
 2068  6                  else                       /* Unlocked */
 2069  6                  {
 2070  7                    /* return 0 if the resource is unprotected. */
 2071  7                    CRM_GET_SEED_LENGTH = 0;
 2072  7                  }
 2073  6                  xcp.CrmLen = (vuint8)CRM_GET_SEED_LEN;
 2074  6                }
 2075  5                
 2076  5      #if defined ( XCP_ENABLE_TESTMODE )
                        if ( gDebugLevel != 0)
                        {
                          ApplXcpPrint("-> GET_SEED resource=%02Xh\n",CRO_GET_SEED_RESOURCE);
                          ApplXcpPrint("<- 0xFF length=%02Xh, seed=%02X%02X%02X%02X%02X%02X\n",CRM_GET_SEED_LENGTH,CRM_GET_SEE
             -D_DATA[0],CRM_GET_SEED_DATA[1],CRM_GET_SEED_DATA[2],CRM_GET_SEED_DATA[3],CRM_GET_SEED_DATA[4],CRM_GET_SEED_DATA[5]);
                        }
              #endif
 2083  5              }
 2084  4              break;
 2085  4              
 2086  4            case CC_UNLOCK:
 2087  4              {
 2088  5                vuint8 resource;
 2089  5                
 2090  5      #if defined ( XCP_ENABLE_TESTMODE )
                        if ( gDebugLevel != 0)
                        {
                          ApplXcpPrint("-> UNLOCK key=%02X%02X%02X%02X%02X%02X\n",CRO_UNLOCK_KEY[0],CRO_UNLOCK_KEY[1],CRO_UNLO
             -CK_KEY[2],CRO_UNLOCK_KEY[3],CRO_UNLOCK_KEY[4],CRO_UNLOCK_KEY[5]);
                        }
              #endif
 2096  5                
 2097  5                /* Only keys with a maximum length of MAX_CTO-2 are supported so far. */
 2098  5                if (CRO_UNLOCK_LENGTH > (vuint8)(kXcpMaxCTO-2))
 2099  5                {
 2100  6                  error(CRC_SEQUENCE) /* PRQA S 2001 */ /* MD_Xcp_2001 */
 2101  6                }
 2102  5                else
 2103  5                {
 2104  6                  resource = ApplXcpUnlock(CRO_UNLOCK_KEY, CRO_UNLOCK_LENGTH);
 2105  6                  if ( resource == (vuint8)0x00u )
 2106  6                  {
C166 COMPILER V7.57.0, XCPBASIC                                                            01/03/2020 16:20:10 PAGE 36  

 2107  7                    /* Key wrong ! */
 2108  7                    /* Send ERR_ACCESS_LOCKED and go to disconnected state. */
 2109  7                    XcpDisconnect();
 2110  7                    error(CRC_ACCESS_LOCKED) /* PRQA S 2001 */ /* MD_Xcp_2001 */
 2111  7                  }
 2112  6                  else
 2113  6                  {
 2114  7                    /* unlock (reset) the appropriate resource protection mask bit.. */
 2115  7                    xcp.ProtectionStatus &= (vuint8)~resource;
 2116  7                    
 2117  7                    /* ..and return the current resource protection status. */
 2118  7                    CRM_UNLOCK_PROTECTION = xcp.ProtectionStatus;
 2119  7                    xcp.CrmLen = CRM_UNLOCK_LEN;
 2120  7                  }
 2121  6                }
 2122  5                
 2123  5      #if defined ( XCP_ENABLE_TESTMODE )
                        if ( gDebugLevel != 0)
                        {
                          ApplXcpPrint("<- 0xFF\n");
                        }
              #endif
 2129  5              }
 2130  4              break;
 2131  4              
 2132  4      #endif /* XCP_ENABLE_SEED_KEY */
 2133  4              
 2134  4              
 2135  4      #if defined ( XCP_ENABLE_CALIBRATION_PAGE )
 2136  4              
 2137  4            case CC_SET_CAL_PAGE:
 2138  4              {
 2139  5      #if defined ( XCP_ENABLE_TESTMODE )
                        if ( gDebugLevel != 0)
                        {
                          ApplXcpPrint("-> SET_CAL_PAGE segment=%u,page =%u,mode=%02Xh\n",CRO_SET_CAL_PAGE_SEGMENT,CRO_SET_CAL
             -_PAGE_PAGE,CRO_SET_CAL_PAGE_MODE);
                        }
              #endif
 2145  5                
 2146  5                check_error( ApplXcpSetCalPage(CRO_SET_CAL_PAGE_SEGMENT,CRO_SET_CAL_PAGE_PAGE,CRO_SET_CAL_PAGE_MODE) 
             -) /* PRQA S 2001 */ /* MD_Xcp_2001 */
 2147  5                  
 2148  5      #if defined ( XCP_ENABLE_TESTMODE )
                          if ( gDebugLevel != 0)
                          {
                            ApplXcpPrint("<- 0xFF\n");
                          }
              #endif
 2154  5              }
 2155  4              break;
 2156  4              
 2157  4            case CC_GET_CAL_PAGE:
 2158  4              {
 2159  5                
 2160  5      #if defined ( XCP_ENABLE_TESTMODE )
                        if ( gDebugLevel != 0)
                        {
                          ApplXcpPrint("-> GET_CAL_PAGE Segment=%u, Mode=%u\n",CRO_GET_CAL_PAGE_SEGMENT,CRO_GET_CAL_PAGE_MODE)
             -;
                        }
              #endif
C166 COMPILER V7.57.0, XCPBASIC                                                            01/03/2020 16:20:10 PAGE 37  

 2166  5                
 2167  5                xcp.CrmLen = CRM_GET_CAL_PAGE_LEN;
 2168  5                CRM_GET_CAL_PAGE_PAGE = ApplXcpGetCalPage(CRO_GET_CAL_PAGE_SEGMENT,CRO_GET_CAL_PAGE_MODE);
 2169  5                
 2170  5      #if defined ( XCP_ENABLE_TESTMODE )
                        if ( gDebugLevel != 0)
                        {
                          ApplXcpPrint("<- 0xFF page=%u\n",CRM_GET_CAL_PAGE_PAGE);
                        }
              #endif
 2176  5              }
 2177  4              break;
 2178  4              
 2179  4      #endif /* XCP_ENABLE_CALIBRATION_PAGE */
 2180  4              
 2181  4              
 2182  4      #if defined ( XCP_ENABLE_PAGE_INFO )
                      /* Paging Information optional */
                    case CC_GET_PAG_PROCESSOR_INFO:
                      {
              #if defined ( XCP_ENABLE_TESTMODE )
                        if ( gDebugLevel != 0)
                        {
                          ApplXcpPrint("-> CC_GET_PAG_PROCESSOR_INFO");
                        }
              #endif
                        
                        xcp.CrmLen = CRM_GET_PAG_PROCESSOR_INFO_LEN;
                        
                        CRM_GET_PAG_PROCESSOR_INFO_MAX_SEGMENT = (vuint8)kXcpMaxSegment;
              #if defined ( XCP_ENABLE_PAGE_FREEZE )
                        CRM_GET_PAG_PROCESSOR_INFO_PROPERTIES  = 1; /* FREEZE_SUPPORTED = 1 */
              #else
                        CRM_GET_PAG_PROCESSOR_INFO_PROPERTIES  = 0; /* FREEZE_SUPPORTED = 0 */
              #endif
                        
              #if defined ( XCP_ENABLE_TESTMODE )
                        if ( gDebugLevel != 0)
                        {
                          ApplXcpPrint("<- 0xFF maxsegment=%u\n",(vuint8)kXcpMaxSegment);
                        }
              #endif
                        
                      }
                      break;  
                      
                      
                    case CC_GET_SEGMENT_INFO:
                      {
              #if defined ( XCP_ENABLE_TESTMODE )
                        if ( gDebugLevel != 0)
                        {
                          ApplXcpPrint("-> CC_GET_SEGMENT_INFO");
                        }
              #endif
                        
                        if (CRO_GET_SEGMENT_INFO_NUMBER >= (vuint8)kXcpMaxSegment)
                        {
                          error(CRC_OUT_OF_RANGE) /* PRQA S 2001 */ /* MD_Xcp_2001 */
                        }
                        
                        xcp.CrmLen = CRM_GET_SEGMENT_INFO_LEN;
C166 COMPILER V7.57.0, XCPBASIC                                                            01/03/2020 16:20:10 PAGE 38  

                        /* Get standard info for a segment.
                        SEGMENT_INFO and MAPPING_INDEX are don't care
                        */
                        if (CRO_GET_SEGMENT_INFO_MODE == 1)
                        { 
                          CRM_GET_SEGMENT_INFO_MAX_PAGES         = 2;
                          CRM_GET_SEGMENT_INFO_ADDRESS_EXTENSION = 0;
                          CRM_GET_SEGMENT_INFO_MAX_MAPPING       = 0;
                          CRM_GET_SEGMENT_INFO_COMPRESSION       = 0;
                          CRM_GET_SEGMENT_INFO_ENCRYPTION        = 0;
                          
                        }
                        /* Get basic address info for a segment:
                        SEGMENT_INFO contains address range information and 
                        MAPPING_INDEX is don't care
                        Get address mapping for a segment:
                        SEGMENT_INFO contains address range information and 
                        MAPPING_INDEX indicates the range MAPPING_INFO belongs to
                        */
                        if ( (CRO_GET_SEGMENT_INFO_MODE == 0) || (CRO_GET_SEGMENT_INFO_MODE == 2) )
                        {
                          CRM_GET_SEGMENT_INFO_MAPPING_INFO = 0;
                        }
                        
              #if defined ( XCP_ENABLE_TESTMODE )
                        if (gDebugLevel && CRO_GET_SEGMENT_INFO_MODE == 1)
                        {
                          ApplXcpPrint("<- 0xFF Mode=%u, Maxpages=%u, AddrExt=%u, Mappingmax=%u, Compression=%u, Encryption=%u
             -\n",CRO_GET_SEGMENT_INFO_MODE,CRM_GET_SEGMENT_INFO_MAX_PAGES,CRM_GET_SEGMENT_INFO_ADDRESS_EXTENSION,CRM_GET_SEGMENT_INFO
             -_MAX_MAPPING,CRM_GET_SEGMENT_INFO_COMPRESSION,CRM_GET_SEGMENT_INFO_ENCRYPTION);
                        }
                        if (gDebugLevel && CRO_GET_SEGMENT_INFO_MODE == 0 || CRO_GET_SEGMENT_INFO_MODE == 2) 
                        {
                          ApplXcpPrint("<- 0xFF Mode=%u, MappingInfo=%u\n",CRO_GET_SEGMENT_INFO_MODE,CRM_GET_SEGMENT_INFO_MAPP
             -ING_INFO);
                        }
              #endif
                      }
                      break;
                      
                    case CC_GET_PAGE_INFO:
                      {
              #if defined ( XCP_ENABLE_TESTMODE )
                        if ( gDebugLevel != 0)
                        {
                          ApplXcpPrint("-> CC_GET_PAGE_INFO");
                        }
              #endif
                        
                        if ( ( CRO_GET_PAGE_INFO_SEGMENT_NUMBER > ((vuint8)(kXcpMaxSegment-1)&0xFFu) ) || 
                          ( CRO_GET_PAGE_INFO_PAGE_NUMBER >((vuint8)(kXcpMaxPages-1)&0xFFu) ) )
                        {
                          error(CRC_OUT_OF_RANGE) /* PRQA S 2001 */ /* MD_Xcp_2001 */
                        }
                        
                        xcp.CrmLen = CRM_GET_PAGE_INFO_LEN;
                        CRM_GET_PAGE_INFO_PROPERTIES = 0;
                        
              #if defined ( XCP_ENABLE_TESTMODE )
                        if ( gDebugLevel != 0)
                        {
                          ApplXcpPrint("<- 0xFF properties=%u\n",CRM_GET_PAGE_INFO_PROPERTIES);
C166 COMPILER V7.57.0, XCPBASIC                                                            01/03/2020 16:20:10 PAGE 39  

                        }
              #endif
                      }
                      break;
              #endif /* defined ( XCP_BASIC_VERSION_COMMENT ) */
 2292  4              
 2293  4              /* Paging freeze mode support */
 2294  4      #if defined ( XCP_ENABLE_PAGE_FREEZE )
                    case CC_SET_SEGMENT_MODE:
                      {
              #if defined ( XCP_ENABLE_TESTMODE )
                        if ( gDebugLevel != 0)
                        {
                          ApplXcpPrint("-> CC_SET_SEGMENT_MODE segment=%u, mode=%u\n",CRO_SET_SEGMENT_MODE_SEGMENT,CRO_SET_SEG
             -MENT_MODE_MODE);
                        }
              #endif
                        
                        if (CRO_SET_SEGMENT_MODE_SEGMENT > ((vuint8)(kXcpMaxSegment-1)&0xFFu))
                        {
                          error(CRC_OUT_OF_RANGE) /* PRQA S 2001 */ /* MD_Xcp_2001 */
                        }
                        
                        /* inform application about Set Segment Mode command */
                        ApplXcpSetFreezeMode(CRO_SET_SEGMENT_MODE_SEGMENT, CRO_SET_SEGMENT_MODE_MODE);
                        /* CRO_SET_SEGMENT_MODE_MODE;*/
                        xcp.CrmLen = CRM_SET_SEGMENT_MODE_LEN;
                        
              #if defined ( XCP_ENABLE_TESTMODE )
                        if ( gDebugLevel != 0)
                        {
                          ApplXcpPrint("<- 0xFF\n");
                        }
              #endif
                      }
                      break;
                      
                    case CC_GET_SEGMENT_MODE:
                      {
              #if defined ( XCP_ENABLE_TESTMODE )
                        if ( gDebugLevel != 0)
                        {
                          ApplXcpPrint("-> CC_GET_SEGMENT_MODE");
                        }
              #endif
                        
                        if (CRO_GET_SEGMENT_MODE_SEGMENT > ((vuint8)(kXcpMaxSegment-1)&0xFFu))
                        {
                          error(CRC_OUT_OF_RANGE) /* PRQA S 2001 */ /* MD_Xcp_2001 */
                        }
                        
                        /* request current freeze mode information from application */
                        CRM_GET_SEGMENT_MODE_MODE = ApplXcpGetFreezeMode(CRO_GET_SEGMENT_MODE_SEGMENT);
                        
                        xcp.CrmLen = CRM_GET_SEGMENT_MODE_LEN;
                        
              #if defined ( XCP_ENABLE_TESTMODE )
                        if ( gDebugLevel != 0)
                        {
                          ApplXcpPrint("<- 0xFF mode=%u\n",CRM_GET_SEGMENT_MODE_MODE);
                        }
              #endif
C166 COMPILER V7.57.0, XCPBASIC                                                            01/03/2020 16:20:10 PAGE 40  

                      }
                      break;
              #endif /* XCP_ENABLE_PAGE_FREEZE */
 2351  4              
 2352  4              /* Copy cal page support */
 2353  4      #if defined ( XCP_ENABLE_PAGE_COPY )
                    case CC_COPY_CAL_PAGE:
                      {
              #if defined ( XCP_ENABLE_TESTMODE )
                        if ( gDebugLevel != 0)
                        {
                          ApplXcpPrint("-> CC_COPY_CAL_PAGE");
                        }
              #endif
                        
                        xcp.CrmLen = CRM_COPY_CAL_PAGE_LEN;
                        
                        err = ApplXcpCopyCalPage(CRO_COPY_CAL_PAGE_SRC_SEGMENT,CRO_COPY_CAL_PAGE_SRC_PAGE,CRO_COPY_CAL_PAGE_D
             -EST_SEGMENT,CRO_COPY_CAL_PAGE_DEST_PAGE);
                        
                        if (err==(vuint8)XCP_CMD_PENDING) 
                        {
                          goto no_response; /* PRQA S 2001 */ /* MD_Xcp_2001 */
                        }
                        
                        check_error( err ) /* PRQA S 2001 */ /* MD_Xcp_2001 */
                          
              #if defined ( XCP_ENABLE_TESTMODE )
                          if ( gDebugLevel != 0)
                          {
                            ApplXcpPrint("<- 0xFF\n");
                          }
              #endif
                      }
                      break;
              #endif /* XCP_ENABLE_PAGE_COPY */
 2383  4              
 2384  4              
 2385  4            case CC_SET_MTA:
 2386  4              {
 2387  5      #if defined ( XCP_ENABLE_TESTMODE )
                        if ( gDebugLevel != 0)
                        {
                          ApplXcpPrint("-> SET_MTA addr=%08Xh, addrext=%02Xh\n",CRO_SET_MTA_ADDR,CRO_SET_MTA_EXT);
                        }
              #endif
 2393  5                XcpSetMta(ApplXcpGetPointer(CRO_SET_MTA_EXT,CRO_SET_MTA_ADDR),CRO_SET_MTA_EXT);
 2394  5                
 2395  5                
 2396  5      #if defined ( XCP_ENABLE_TESTMODE )
                        if ( gDebugLevel != 0)
                        {
                          ApplXcpPrint("<- 0xFF\n");
                        }
              #endif
 2402  5              }
 2403  4              break;
 2404  4              
 2405  4              
 2406  4            case CC_DOWNLOAD: /* PRQA S 2003 */ /* MD_Xcp_2003 */
 2407  4              {
 2408  5      #if defined ( XCP_ENABLE_CALIBRATION )
C166 COMPILER V7.57.0, XCPBASIC                                                            01/03/2020 16:20:10 PAGE 41  

 2409  5                vuint8 size;
 2410  5                
 2411  5      #if defined ( XCP_ENABLE_TESTMODE )
                        if (gDebugLevel && (CRO_CMD != CC_DOWNLOAD_NEXT))
                        {
                          vuint16 i;
                          ApplXcpPrint("-> DOWNLOAD size=%u, data=",CRO_DOWNLOAD_SIZE);
                          for (i=0;(i<CRO_DOWNLOAD_SIZE) && (i<CRO_DOWNLOAD_MAX_SIZE);i++)
                          {
                            ApplXcpPrint("%02X ",CRO_DOWNLOAD_DATA[i]);
                          }
                          ApplXcpPrint("\n");
                        }
              #endif
 2423  5                
 2424  5                CheckResourceProtection( RM_CAL_PAG ) /* PRQA S 2001 */ /* MD_Xcp_2001 */
 2425  5                  
 2426  5                  size = CRO_DOWNLOAD_SIZE;
 2427  5                if (size>CRO_DOWNLOAD_MAX_SIZE)
 2428  5                {
 2429  6                  error(CRC_OUT_OF_RANGE) /* PRQA S 2001 */ /* MD_Xcp_2001 */
 2430  6                }
 2431  5                
 2432  5                err = XcpWriteMta(size,CRO_DOWNLOAD_DATA);
 2433  5                if (err==(vuint8)XCP_CMD_PENDING) 
 2434  5                {
 2435  6                  goto no_response; /* PRQA S 2001 */ /* MD_Xcp_2001 */
 2436  6                }
 2437  5                if (err==(vuint8)XCP_CMD_DENIED)
 2438  5                {
 2439  6                  error(CRC_WRITE_PROTECTED) /* PRQA S 2001 */ /* MD_Xcp_2001 */
 2440  6                }
 2441  5                if (err==(vuint8)XCP_CMD_SYNTAX)
 2442  5                {
 2443  6                  error(CRC_CMD_SYNTAX) /* PRQA S 2001 */ /* MD_Xcp_2001 */
 2444  6                }
 2445  5                
 2446  5                          
 2447  5      #if defined ( XCP_ENABLE_TESTMODE )
                        if ( gDebugLevel != 0)
                        {
                          ApplXcpPrint("<- 0xFF\n");
                        }
              #endif
 2453  5      #else
                        error(CRC_CMD_UNKNOWN) /* PRQA S 2001 */ /* MD_Xcp_2001 */
              #endif /* !defined ( XCP_ENABLE_CALIBRATION ) */
 2456  5                  
 2457  5              }
 2458  4              break;
 2459  4              
 2460  4            case CC_DOWNLOAD_MAX:
 2461  4              {
 2462  5      #if defined ( XCP_ENABLE_CALIBRATION )
 2463  5      #if defined ( XCP_ENABLE_TESTMODE )
                        if ( gDebugLevel != 0)
                        {
                          vuint16 i;
                          ApplXcpPrint("DOWNLOAD_MAX data=");
                          for (i=0;i<CRO_DOWNLOAD_MAX_MAX_SIZE;i++)
                          {
                            ApplXcpPrint("%02X ",CRO_DOWNLOAD_MAX_DATA[i]);
C166 COMPILER V7.57.0, XCPBASIC                                                            01/03/2020 16:20:10 PAGE 42  

                          }
                          ApplXcpPrint("\n");
                        }
              #endif
 2475  5                
 2476  5                CheckResourceProtection( RM_CAL_PAG ) /* PRQA S 2001 */ /* MD_Xcp_2001 */
 2477  5                  
 2478  5                  err = XcpWriteMta(CRO_DOWNLOAD_MAX_MAX_SIZE,CRO_DOWNLOAD_MAX_DATA);
 2479  5                if (err==(vuint8)XCP_CMD_PENDING)
 2480  5                {
 2481  6                  return;
 2482  6                }
 2483  5                if (err==(vuint8)XCP_CMD_DENIED)
 2484  5                {
 2485  6                  error(CRC_WRITE_PROTECTED) /* PRQA S 2001 */ /* MD_Xcp_2001 */
 2486  6                }
 2487  5                if (err==(vuint8)XCP_CMD_SYNTAX)
 2488  5                {
 2489  6                  error(CRC_CMD_SYNTAX) /* PRQA S 2001 */ /* MD_Xcp_2001 */
 2490  6                }
 2491  5                
 2492  5      #if defined ( XCP_ENABLE_TESTMODE )
                        if ( gDebugLevel != 0)
                        {
                          ApplXcpPrint("<- 0xFF\n");
                        }
              #endif
 2498  5      #else
                        error(CRC_ACCESS_DENIED) /* PRQA S 2001 */ /* MD_Xcp_2001 */
              #endif /* !defined ( XCP_ENABLE_CALIBRATION ) */
 2501  5              }
 2502  4              break;
 2503  4              
 2504  4              
 2505  4              
 2506  4            case CC_UPLOAD:
 2507  4              {
 2508  5                vuint8 size = CRO_UPLOAD_SIZE;
 2509  5                
 2510  5      #if defined ( XCP_ENABLE_TESTMODE )
                        if ( gDebugLevel != 0)
                        {
                          ApplXcpPrint("-> UPLOAD size=%u\n",size);
                        }
              #endif
 2516  5                
 2517  5                if ( size > (vuint8)CRM_UPLOAD_MAX_SIZE )
 2518  5                {
 2519  6                  error(CRC_OUT_OF_RANGE) /* PRQA S 2001 */ /* MD_Xcp_2001 */
 2520  6                }
 2521  5                err = XcpReadMta(size,CRM_UPLOAD_DATA);
 2522  5                xcp.CrmLen = (vuint8)((CRM_UPLOAD_LEN+size)&0xFFu);
 2523  5                if (err==(vuint8)XCP_CMD_PENDING)
 2524  5                {
 2525  6                  goto no_response; /* PRQA S 2001 */ /* MD_Xcp_2001 */
 2526  6                }
 2527  5                if (err==(vuint8)XCP_CMD_DENIED)
 2528  5                {
 2529  6                  error(CRC_ACCESS_DENIED) /* PRQA S 2001 */ /* MD_Xcp_2001 */
 2530  6                }
 2531  5                
 2532  5      #if defined ( XCP_ENABLE_TESTMODE )
C166 COMPILER V7.57.0, XCPBASIC                                                            01/03/2020 16:20:10 PAGE 43  

                        if ( gDebugLevel != 0)
                        {
                          vuint16 i;
                          ApplXcpPrint("<- 0xFF data=");
                          for (i=0;i<size;i++) 
                          {
                            ApplXcpPrint("%02X ",CRM_UPLOAD_DATA[i]);
                          }
                          ApplXcpPrint("\n");
                        }
              #endif
 2544  5              }
 2545  4              break;
 2546  4              
 2547  4            case CC_SHORT_UPLOAD:
 2548  4              {
 2549  5      #if defined ( XCP_ENABLE_TESTMODE )
                        if ( gDebugLevel != 0)
                        {
                          ApplXcpPrint("-> SHORT_UPLOAD addr=%08Xh, addrext=%02Xh, size=%u\n",CRO_SHORT_UPLOAD_ADDR,CRO_SHORT_
             -UPLOAD_EXT,CRO_SHORT_UPLOAD_SIZE);
                        }
              #endif
 2555  5                
 2556  5      #if defined ( XCP_ENABLE_PARAMETER_CHECK )
                        if (CRO_SHORT_UPLOAD_SIZE > (vuint8)CRM_SHORT_UPLOAD_MAX_SIZE)
                        {
                          error(CRC_OUT_OF_RANGE) /* PRQA S 2001 */ /* MD_Xcp_2001 */
                        }
              #endif
 2562  5                XcpSetMta(ApplXcpGetPointer(CRO_SHORT_UPLOAD_EXT,CRO_SHORT_UPLOAD_ADDR),CRO_SHORT_UPLOAD_EXT);
 2563  5                err = XcpReadMta(CRO_SHORT_UPLOAD_SIZE,CRM_SHORT_UPLOAD_DATA);
 2564  5                xcp.CrmLen = (vuint8)((CRM_SHORT_UPLOAD_LEN+CRO_SHORT_UPLOAD_SIZE)&0xFFu);
 2565  5                if (err==(vuint8)XCP_CMD_PENDING)
 2566  5                {
 2567  6                  goto no_response; /* ESCAN00014775 */ /* PRQA S 2001 */ /* MD_Xcp_2001 */
 2568  6                }
 2569  5                if (err==(vuint8)XCP_CMD_DENIED)
 2570  5                {
 2571  6                  error(CRC_ACCESS_DENIED) /* PRQA S 2001 */ /* MD_Xcp_2001 */
 2572  6                }
 2573  5                
 2574  5      #if defined ( XCP_ENABLE_TESTMODE )
                        if ( gDebugLevel != 0)
                        {
                          vuint16 i;
                          ApplXcpPrint("<- 0xFF data=");
                          for (i=0; i < (vuint16)CRO_SHORT_UPLOAD_SIZE; i++)
                          {
                            ApplXcpPrint("%02X ",CRM_SHORT_UPLOAD_DATA[i]);
                          }
                          ApplXcpPrint("\n");
                        }
              #endif
 2586  5              }
 2587  4              break;
 2588  4              
 2589  4              
 2590  4      #if defined ( XCP_ENABLE_CHECKSUM )
 2591  4              
 2592  4            case CC_BUILD_CHECKSUM: /* Build Checksum */
 2593  4              {
C166 COMPILER V7.57.0, XCPBASIC                                                            01/03/2020 16:20:10 PAGE 44  

 2594  5                vuint32 s;
 2595  5                
 2596  5      #if defined ( XCP_ENABLE_TESTMODE )
                        if ( gDebugLevel != 0)
                        {
                          ApplXcpPrint("-> BUILD_CHECKSUM size=%u\n",CRO_BUILD_CHECKSUM_SIZE);
                        }
              #endif
 2602  5                s = CRO_BUILD_CHECKSUM_SIZE;
 2603  5                
 2604  5      #if !defined ( XCP_ENABLE_CUSTOM_CRC )
 2605  5                /* Initialization of checksum calculation. */
 2606  5      #if ( kXcpChecksumMethod == XCP_CHECKSUM_TYPE_CRC16CCITT ) || \
 2607  5                ( kXcpChecksumMethod == XCP_CHECKSUM_TYPE_CRC32 )
                        xcp.CheckSum = (tXcpChecksumSumType)0xFFFFFFFFu;
              #else
 2610  5                xcp.CheckSum = (tXcpChecksumSumType)0u;
 2611  5      #endif
 2612  5                /* The blocksize is limited to WORD length. */
 2613  5                /* If the blocksize exceeds the allowed maximum transmit negative response. */
 2614  5                if ( (s & (vuint32)0xffff0000u) != (vuint32)0u )
 2615  5                {
 2616  6                  CRM_BUILD_CHECKSUM_RESULT_WRITE(0xFFFFu); /* Range, max. 64K-1 */ /* PRQA S 3109 */ /* MD_MSR_14.3 *
             -/
 2617  6                  err = CRC_OUT_OF_RANGE;
 2618  6                  xcp.CrmLen = CRM_BUILD_CHECKSUM_LEN;
 2619  6                  /* Response length is arbitrary */
 2620  6                  goto negative_response1; /* PRQA S 2001 */ /* MD_Xcp_2001 */
 2621  6                } 
 2622  5                else
 2623  5      #endif
 2624  5                {
 2625  6                  
 2626  6      #if defined ( XCP_ENABLE_PARAMETER_CHECK )
                          /* Parameter check whether the block size is modulo 2 for ADD_22, ADD_24 */
                          /* and ADD_44 (modulo 4).                                                */  
              #if ( kXcpChecksumMethod == XCP_CHECKSUM_TYPE_ADD22 ) || \
                ( kXcpChecksumMethod == XCP_CHECKSUM_TYPE_ADD24 ) || \
                          ( kXcpChecksumMethod == XCP_CHECKSUM_TYPE_ADD44 )        
                          if ( (s % (vuint32)sizeof(tXcpChecksumAddType)) != (vuint32)0u )
                          {
                            error(CRC_OUT_OF_RANGE) /* PRQA S 2001 */ /* MD_Xcp_2001 */
                          }
                          else
              #endif    
              #endif
 2639  6                  {
 2640  7                    
 2641  7      #if defined ( XCP_ENABLE_CUSTOM_CRC )
                            err = ApplXcpCalculateChecksum( xcp.Mta, xcp.Crm.b, s );
                            xcp.Mta += s;
                            if (err==(vuint8)XCP_CMD_PENDING)
                            {
                              goto no_response; /* PRQA S 2001 */ /* MD_Xcp_2001 */
                            }
                            if (err!=(vuint8)XCP_CMD_OK)
                            {
                              error(CRC_CMD_UNKNOWN) /* PRQA S 2001 */ /* MD_Xcp_2001 */
                            }
              #else
 2653  7                    xcp.CheckSumSize = (vuint16)s;
 2654  7                    /* Checksum calculation will be performed by XcpBackground() */
C166 COMPILER V7.57.0, XCPBASIC                                                            01/03/2020 16:20:10 PAGE 45  

 2655  7                    goto no_response; /* PRQA S 2001 */ /* MD_Xcp_2001 */
 2656  7      #endif
 2657  7                  }
 2658  6                }
 2659  5              }
 2660  4      #if defined ( XCP_ENABLE_CUSTOM_CRC )
                      break;
              #endif
 2663  4              
 2664  4      #endif /* XCP_ENABLE_CHECKSUM */
 2665  4              
 2666  4              
 2667  4      #if defined ( XCP_ENABLE_DAQ )
 2668  4              
 2669  4      #if defined ( XCP_ENABLE_DAQ_PROCESSOR_INFO )
 2670  4              
 2671  4            case CC_GET_DAQ_PROCESSOR_INFO: /* PRQA S 2003 */ /* MD_Xcp_2003 */
 2672  4              {
 2673  5      #if defined ( XCP_ENABLE_TESTMODE )
                        if ( gDebugLevel != 0)
                        {
                          ApplXcpPrint("-> GET_DAQ_PROCESSOR_INFO\n");
                        }
              #endif
 2679  5                
 2680  5                xcp.CrmLen = CRM_GET_DAQ_PROCESSOR_INFO_LEN;
 2681  5                CRM_GET_DAQ_PROCESSOR_INFO_MIN_DAQ = 0;          
 2682  5                /* PRQA S 3757 1 */ /* MD_Xcp_3757 */
 2683  5                CRM_GET_DAQ_PROCESSOR_INFO_MAX_DAQ_WRITE(xcp.Daq.DaqCount); /* dynamic or static */ /* PRQA S 3109 */
             - /* MD_MSR_14.3 */
 2684  5      #if defined ( kXcpMaxEvent )
                        CRM_GET_DAQ_PROCESSOR_INFO_MAX_EVENT_WRITE(kXcpMaxEvent); /* PRQA S 3109 */ /* MD_MSR_14.3 */
              #else
 2687  5                CRM_GET_DAQ_PROCESSOR_INFO_MAX_EVENT_WRITE(0x00); /* Unknown */    
 2688  5      #endif
 2689  5      #if defined ( XCP_ENABLE_DAQ_HDR_ODT_DAQ )
                        /* DTO identification field type: Relative ODT number, absolute list number (BYTE) */
                        CRM_GET_DAQ_PROCESSOR_INFO_DAQ_KEY_BYTE = (vuint8)DAQ_HDR_ODT_DAQB;
              #else
 2693  5                /* DTO identification field type: Absolute ODT number */
 2694  5                CRM_GET_DAQ_PROCESSOR_INFO_DAQ_KEY_BYTE = (vuint8)DAQ_HDR_PID;
 2695  5      #endif
 2696  5                CRM_GET_DAQ_PROCESSOR_INFO_PROPERTIES = (vuint8)( DAQ_PROPERTY_CONFIG_TYPE
 2697  5      #if defined ( XCP_ENABLE_DAQ_TIMESTAMP )
 2698  5                  | DAQ_PROPERTY_TIMESTAMP
 2699  5      #endif
 2700  5      #if defined ( XCP_ENABLE_DAQ_PRESCALER )
 2701  5                  | DAQ_PROPERTY_PRESCALER
 2702  5      #endif
 2703  5      #if defined ( XCP_ENABLE_DAQ_OVERRUN_INDICATION ) /* DAQ_PROPERTY_OVERLOAD_INDICATION */
 2704  5                  | DAQ_OVERLOAD_INDICATION_PID
 2705  5      #endif
 2706  5                  );
 2707  5                
 2708  5      #if defined ( XCP_ENABLE_TESTMODE )
                        if ( gDebugLevel != 0)
                        {
                          ApplXcpPrint("<- 0xFF\n");
                        }
              #endif
 2714  5              }
 2715  4              break;
C166 COMPILER V7.57.0, XCPBASIC                                                            01/03/2020 16:20:10 PAGE 46  

 2716  4              
 2717  4      #endif /* XCP_ENABLE_DAQ_PROCESSOR_INFO */
 2718  4              
 2719  4      #if defined ( XCP_ENABLE_DAQ_RESOLUTION_INFO )
 2720  4              
 2721  4                  case CC_GET_DAQ_RESOLUTION_INFO: /* PRQA S 2003 */ /* MD_Xcp_2003 */
 2722  4              {
 2723  5      #if defined ( XCP_ENABLE_TESTMODE )
                        if ( gDebugLevel != 0) 
                        {
                          ApplXcpPrint("-> GET_DAQ_RESOLUTION_INFO\n");
                        }
              #endif
 2729  5                
 2730  5                xcp.CrmLen = CRM_GET_DAQ_RESOLUTION_INFO_LEN;
 2731  5                CRM_GET_DAQ_RESOLUTION_INFO_GRANULARITY_DAQ = 1;
 2732  5                CRM_GET_DAQ_RESOLUTION_INFO_GRANULARITY_STIM = 1;
 2733  5                CRM_GET_DAQ_RESOLUTION_INFO_MAX_SIZE_DAQ  = (vuint8)XCP_MAX_ODT_ENTRY_SIZE;
 2734  5                CRM_GET_DAQ_RESOLUTION_INFO_MAX_SIZE_STIM = (vuint8)XCP_MAX_ODT_ENTRY_SIZE;
 2735  5      #if defined ( XCP_ENABLE_DAQ_TIMESTAMP )
 2736  5                CRM_GET_DAQ_RESOLUTION_INFO_TIMESTAMP_MODE = kXcpDaqTimestampUnit | (vuint8)kXcpDaqTimestampSize
 2737  5      #if defined ( XCP_ENABLE_DAQ_TIMESTAMP_FIXED )
                          | DAQ_TIMESTAMP_FIXED
              #endif
 2740  5                  ;
 2741  5                CRM_GET_DAQ_RESOLUTION_INFO_TIMESTAMP_TICKS_WRITE(kXcpDaqTimestampTicksPerUnit);  /* BCD coded */ /* 
             -PRQA S 3109 */ /* MD_MSR_14.3 */
 2742  5      #else
                        CRM_GET_DAQ_RESOLUTION_INFO_TIMESTAMP_MODE = 0;
                        CRM_GET_DAQ_RESOLUTION_INFO_TIMESTAMP_TICKS_WRITE(0x00);
              #endif /* XCP_ENABLE_DAQ_TIMESTAMP */
 2746  5                
 2747  5      #if defined ( XCP_ENABLE_TESTMODE )
                        if ( gDebugLevel != 0)
                        {
                          ApplXcpPrint("<- 0xFF , mode=%02Xh, , ticks=%02Xh\n",CRM_GET_DAQ_RESOLUTION_INFO_TIMESTAMP_MODE,CRM_
             -GET_DAQ_RESOLUTION_INFO_TIMESTAMP_TICKS);
                        }
              #endif
 2753  5              }
 2754  4              break;
 2755  4      #endif /* XCP_ENABLE_DAQ_RESOLUTION_INFO */
 2756  4              
 2757  4      #if defined ( XCP_ENABLE_DAQ_EVENT_INFO ) && defined ( kXcpMaxEvent )
                          case CC_GET_DAQ_EVENT_INFO: /* PRQA S 2003 */ /* MD_Xcp_2003 */
                      {
                        vuint8 event = (vuint8)CRO_GET_DAQ_EVENT_INFO_EVENT;
                        
              #if defined ( XCP_ENABLE_TESTMODE )
                        if ( gDebugLevel != 0)
                        {
                          ApplXcpPrint("-> GET_DAQ_EVENT_INFO event=%u\n",event);
                        }
              #endif
                        
              #if defined ( XCP_ENABLE_PARAMETER_CHECK )
                        if (event >= (vuint8)kXcpMaxEvent )
                        {
                          error(CRC_OUT_OF_RANGE) /* PRQA S 2001 */ /* MD_Xcp_2001 */
                        } 
              #endif
                        
C166 COMPILER V7.57.0, XCPBASIC                                                            01/03/2020 16:20:10 PAGE 47  

                        xcp.CrmLen = CRM_GET_DAQ_EVENT_INFO_LEN;
                        CRM_GET_DAQ_EVENT_INFO_PROPERTIES = kXcpEventDirection[event];
                        CRM_GET_DAQ_EVENT_INFO_MAX_DAQ_LIST = 1; /* Only one DAQ-List available per event channel */
                        CRM_GET_DAQ_EVENT_INFO_NAME_LENGTH = kXcpEventNameLength[event];
                        CRM_GET_DAQ_EVENT_INFO_TIME_CYCLE = kXcpEventCycle[event];
              #if defined ( XCP_ENABLE_CANAPE_5_5_X_SUPPORT )
                        CRM_GET_DAQ_EVENT_INFO_TIME_UNIT = kXcpEventUnit[event];
              #else
                        CRM_GET_DAQ_EVENT_INFO_TIME_UNIT = (vuint8)(kXcpEventUnit[event]>>4); /* ESCAN00090639 */
              #endif
                        CRM_GET_DAQ_EVENT_INFO_PRIORITY = 0;     /* Event channel prioritization is not supported. */
                        XcpSetMta( ApplXcpGetPointer( 0xFF, (vuint32)kXcpEventName[event]), 0xFF ); /* PRQA S 0306 */ /* MD_X
             -cp_0306 */
                        
              #if defined ( XCP_ENABLE_TESTMODE )
                        if ( gDebugLevel != 0)
                        {
                          ApplXcpPrint("<- 0xFF name=%s, unit=%u, cycle=%u\n",kXcpEventName[event],CRM_GET_DAQ_EVENT_INFO_TIME
             -_UNIT,CRM_GET_DAQ_EVENT_INFO_TIME_CYCLE);
                        }
              #endif
                      }
                      break;
              #endif /* XCP_ENABLE_DAQ_EVENT_INFO && kXcpMaxEvent */
 2798  4              
 2799  4              
 2800  4            case CC_FREE_DAQ:
 2801  4              {
 2802  5      #if defined ( XCP_ENABLE_TESTMODE )
                        if ( gDebugLevel != 0)
                        {
                          ApplXcpPrint("-> FREE_DAQ\n");
                        }
              #endif
 2808  5                
 2809  5                CheckResourceProtection( RM_DAQ ) /* PRQA S 2001 */ /* MD_Xcp_2001 */
 2810  5                  
 2811  5                  XcpFreeDaq();
 2812  5                
 2813  5      #if defined ( XCP_ENABLE_TESTMODE )
                        if ( gDebugLevel != 0)
                        {
                          ApplXcpPrint("<- 0xFF\n");
                        }
              #endif
 2819  5              }
 2820  4              break;
 2821  4              
 2822  4            case CC_ALLOC_DAQ:
 2823  4              {
 2824  5                vuint8 count = (vuint8)CRO_ALLOC_DAQ_COUNT;
 2825  5                
 2826  5      #if defined ( XCP_ENABLE_TESTMODE )
                        if ( gDebugLevel != 0)
                        {
                          ApplXcpPrint("-> ALLOC_DAQ count=%u\n",count);
                        }
              #endif
 2832  5                
 2833  5                check_error( XcpAllocDaq(count) ) /* PRQA S 2001 */ /* MD_Xcp_2001 */
 2834  5                  
 2835  5      #if defined ( XCP_ENABLE_TESTMODE )
C166 COMPILER V7.57.0, XCPBASIC                                                            01/03/2020 16:20:10 PAGE 48  

                          if ( gDebugLevel != 0)
                          {
                            ApplXcpPrint("<- 0xFF\n");
                          }
              #endif
 2841  5              }
 2842  4              break;
 2843  4              
 2844  4            case CC_ALLOC_ODT:
 2845  4              {
 2846  5                vuint8 daq = (vuint8)CRO_ALLOC_ODT_DAQ;
 2847  5                vuint8 count = CRO_ALLOC_ODT_COUNT;
 2848  5                
 2849  5      #if defined ( XCP_ENABLE_TESTMODE )
                        if ( gDebugLevel != 0)
                        {
                          ApplXcpPrint("-> ALLOC_ODT daq=%u, count=%u\n",daq,count);
                        }
              #endif
 2855  5                
 2856  5      #if defined ( XCP_ENABLE_PARAMETER_CHECK )
                        if (daq>=xcp.Daq.DaqCount)
                        {
                          error(CRC_OUT_OF_RANGE) /* PRQA S 2001 */ /* MD_Xcp_2001 */
                        }
              #endif
 2862  5                
 2863  5                check_error( XcpAllocOdt(daq, count) ) /* PRQA S 2001 */ /* MD_Xcp_2001 */
 2864  5                  
 2865  5      #if defined ( XCP_ENABLE_TESTMODE )
                          if ( gDebugLevel != 0)
                          {
                            ApplXcpPrint("<- 0xFF\n");
                          }
              #endif
 2871  5              }
 2872  4              break;
 2873  4              
 2874  4            case CC_ALLOC_ODT_ENTRY:
 2875  4              {
 2876  5                vuint8 daq = (vuint8)CRO_ALLOC_ODT_ENTRY_DAQ;
 2877  5                vuint8 odt = CRO_ALLOC_ODT_ENTRY_ODT;
 2878  5                vuint8 count = CRO_ALLOC_ODT_ENTRY_COUNT;
 2879  5                
 2880  5      #if defined ( XCP_ENABLE_TESTMODE )
                        if ( gDebugLevel != 0)
                        {
                          ApplXcpPrint("-> ALLOC_ODT_ENTRY daq=%u, odt=%u, count=%u\n",daq,odt,count);
                        }
              #endif
 2886  5                
 2887  5      #if defined ( XCP_ENABLE_PARAMETER_CHECK )
                        if ( (daq>=xcp.Daq.DaqCount) || (odt>=(vuint8)DaqListOdtCount(daq)) )
                        {
                          error(CRC_OUT_OF_RANGE) /* PRQA S 2001 */ /* MD_Xcp_2001 */
                        }
              #endif
 2893  5                
 2894  5                check_error( XcpAllocOdtEntry(daq, odt, count) ) /* PRQA S 2001 */ /* MD_Xcp_2001 */
 2895  5                  
 2896  5      #if defined ( XCP_ENABLE_TESTMODE )
                          if ( gDebugLevel != 0)
C166 COMPILER V7.57.0, XCPBASIC                                                            01/03/2020 16:20:10 PAGE 49  

                          {
                            ApplXcpPrint("<- 0xFF\n");
                          }
              #endif
 2902  5              }
 2903  4              break;
 2904  4              
 2905  4            case CC_GET_DAQ_LIST_MODE:
 2906  4              {
 2907  5                vuint8 daq = (vuint8)CRO_GET_DAQ_LIST_MODE_DAQ;
 2908  5                
 2909  5      #if defined ( XCP_ENABLE_TESTMODE )
                        if ( gDebugLevel != 0)
                        {
                          ApplXcpPrint("-> GET_DAQ_LIST_MODE daq=%u\n",daq);
                        }
              #endif
 2915  5                
 2916  5      #if defined ( XCP_ENABLE_PARAMETER_CHECK )
                        if (daq>=xcp.Daq.DaqCount)
                        {
                          error(CRC_OUT_OF_RANGE) /* PRQA S 2001 */ /* MD_Xcp_2001 */
                        }
              #endif
 2922  5                
 2923  5                xcp.CrmLen = CRM_GET_DAQ_LIST_MODE_LEN;
 2924  5                CRM_GET_DAQ_LIST_MODE_MODE = DaqListFlags(daq);
 2925  5      #if defined ( XCP_ENABLE_DAQ_PRESCALER )
 2926  5                CRM_GET_DAQ_LIST_MODE_PRESCALER = DaqListPrescaler(daq);
 2927  5      #else
                        CRM_GET_DAQ_LIST_MODE_PRESCALER = 1;
              #endif
 2930  5      #if defined ( kXcpMaxEvent )
                        CRM_GET_DAQ_LIST_MODE_EVENTCHANNEL_WRITE(0); /* #### Lookup in EventDaq[] */ /* PRQA S 3109 */ /* MD_
             -MSR_14.3 */
              #else
 2933  5                CRM_GET_DAQ_LIST_MODE_EVENTCHANNEL_WRITE(DaqListEventChannel(daq));
 2934  5      #endif
 2935  5                CRM_GET_DAQ_LIST_MODE_PRIORITY = 0;  /* DAQ-list prioritization is not supported. */
 2936  5                
 2937  5      #if defined ( XCP_ENABLE_TESTMODE )
                        if ( gDebugLevel != 0)
                        {
                          ApplXcpPrint("<- 0xFF mode=%02X, prescaler=%u, eventChannel=%u, priority=%u, /*maxOdtEntrySize=%u*/ 
             - \n",
                            CRM_GET_DAQ_LIST_MODE_MODE,CRM_GET_DAQ_LIST_MODE_PRESCALER,CRM_GET_DAQ_LIST_MODE_EVENTCHANNEL,CRM_G
             -ET_DAQ_LIST_MODE_PRIORITY);
                        }
              #endif
 2944  5              }
 2945  4              break;
 2946  4              
 2947  4            case CC_SET_DAQ_LIST_MODE:
 2948  4              {
 2949  5                vuint8 daq = (vuint8)CRO_SET_DAQ_LIST_MODE_DAQ;
 2950  5      #if defined ( XCP_ENABLE_TESTMODE ) || defined ( XCP_ENABLE_DAQ_PRESCALER ) || ( !defined ( XCP_ENABLE_DAQ
             -_PRESCALER ) && defined ( XCP_ENABLE_PARAMETER_CHECK ) )
 2951  5                vuint8 xcpPrescaler = CRO_SET_DAQ_LIST_MODE_PRESCALER;
 2952  5      #endif
 2953  5                vuint8 event = (vuint8)(CRO_SET_DAQ_LIST_MODE_EVENTCHANNEL&0xFFu);
 2954  5                
 2955  5      #if defined ( XCP_ENABLE_TESTMODE )
C166 COMPILER V7.57.0, XCPBASIC                                                            01/03/2020 16:20:10 PAGE 50  

                        if ( gDebugLevel != 0)
                        {
                          ApplXcpPrint("-> SET_DAQ_LIST_MODE daq=%u, mode=%02Xh, prescaler=%u, eventchannel=%u\n",
                            daq,CRO_SET_DAQ_LIST_MODE_MODE,xcpPrescaler,event);
                        }
              #endif
 2962  5                
 2963  5      #if defined ( XCP_ENABLE_PARAMETER_CHECK )
                        if (daq>=xcp.Daq.DaqCount)
                        {
                          error(CRC_OUT_OF_RANGE) /* PRQA S 2001 */ /* MD_Xcp_2001 */
                        } 
              #if defined ( kXcpMaxEvent )
                        if (event >= (vuint8)kXcpMaxEvent)
                        {
                          error(CRC_OUT_OF_RANGE) /* PRQA S 2001 */ /* MD_Xcp_2001 */
                        } 
              #endif
              #if !defined ( XCP_ENABLE_DAQ_PRESCALER )
                        if (xcpPrescaler!=1)
                        {
                          error(CRC_OUT_OF_RANGE) /* PRQA S 2001 */ /* MD_Xcp_2001 */
                        }
              #endif
                        if (CRO_SET_DAQ_LIST_MODE_PRIORITY!=0)   /* Priorization is not supported */
                        {
                          error(CRC_OUT_OF_RANGE) /* PRQA S 2001 */ /* MD_Xcp_2001 */
                        } 
              #endif
 2985  5                
 2986  5      #if defined ( XCP_ENABLE_DAQ_PRESCALER )
 2987  5                if (xcpPrescaler==0)
 2988  5                {
 2989  6                  xcpPrescaler = 1;
 2990  6                }
 2991  5                DaqListPrescaler(daq) = xcpPrescaler;
 2992  5      #endif
 2993  5      #if defined ( kXcpMaxEvent ) && ! defined ( XCP_ENABLE_DAQ_PRESCALER )
                        xcp.Daq.EventDaq[event] = daq;
              #else
 2996  5                DaqListEventChannel(daq) = event;
 2997  5      #endif
 2998  5                DaqListFlags(daq) = CRO_SET_DAQ_LIST_MODE_MODE;
 2999  5                
 3000  5                
 3001  5      #if defined ( XCP_ENABLE_TESTMODE )
                        if ( gDebugLevel != 0)
                        {
                          ApplXcpPrint("<- 0xFF\n");
                        }
              #endif
 3007  5                break;
 3008  5              }
 3009  4              
 3010  4              
 3011  4            case CC_SET_DAQ_PTR:
 3012  4              {
 3013  5                vuint8 daq = (vuint8) (CRO_SET_DAQ_PTR_DAQ&0xFFu);
 3014  5                vuint8 odt = CRO_SET_DAQ_PTR_ODT;
 3015  5                vuint8 idx = CRO_SET_DAQ_PTR_IDX;
 3016  5                tXcpOdtIdx odt0 = (tXcpOdtIdx)(DaqListFirstOdt(daq)+odt); /* Absolute odt number */
 3017  5                
C166 COMPILER V7.57.0, XCPBASIC                                                            01/03/2020 16:20:10 PAGE 51  

 3018  5      #if defined ( XCP_ENABLE_TESTMODE )
                        if ( gDebugLevel != 0)
                        {
                          ApplXcpPrint("-> SET_DAQ_PTR daq=%u,odt=%u,idx=%u\n",daq,odt,idx);
                        }
              #endif
 3024  5                
 3025  5      #if defined ( XCP_ENABLE_PARAMETER_CHECK )
                        if ( (daq>=xcp.Daq.DaqCount) || (odt>=(vuint8)DaqListOdtCount(daq)) || (idx>=(vuint8)DaqListOdtEntryC
             -ount(odt0)) )
                        {
                          error(CRC_OUT_OF_RANGE) /* PRQA S 2001 */ /* MD_Xcp_2001 */
                        } 
              #endif
 3031  5                
 3032  5                xcp.CrmLen = CRM_SET_DAQ_PTR_LEN;
 3033  5                xcp.DaqListPtr = DaqListOdtFirstEntry(odt0)+idx;
 3034  5      #if defined ( XCP_ENABLE_TESTMODE )
                        if ( gDebugLevel != 0)
                        {
                          ApplXcpPrint("<- 0xFF \n");
                        }
              #endif
 3040  5              }
 3041  4              break;
 3042  4              
 3043  4            case CC_WRITE_DAQ: /* Write DAQ entry */
 3044  4              {
 3045  5                DAQBYTEPTR addr;
 3046  5      #if defined ( XCP_ENABLE_TESTMODE )
                        if ( gDebugLevel != 0)
                        {
                          ApplXcpPrint("-> WRITE_DAQ size=%u,addr=%08Xh,%02Xh\n",CRO_WRITE_DAQ_SIZE,CRO_WRITE_DAQ_ADDR,CRO_WRI
             -TE_DAQ_EXT);
                        }
              #endif
 3052  5                
 3053  5                CheckResourceProtection( RM_DAQ ) /* PRQA S 2001 */ /* MD_Xcp_2001 */
 3054  5                  
 3055  5      #if defined ( XCP_ENABLE_PARAMETER_CHECK )
                          if ( ((vuint8)CRO_WRITE_DAQ_SIZE==(vuint8)0u ) || (CRO_WRITE_DAQ_SIZE > (vuint8)XCP_MAX_ODT_ENTRY_SI
             -ZE) )
                          {
                            error(CRC_OUT_OF_RANGE) /* PRQA S 2001 */ /* MD_Xcp_2001 */
                          }
                          if ( (0u == xcp.Daq.DaqCount) || (0u == xcp.Daq.OdtCount) || (0u == xcp.Daq.OdtEntryCount) )
                          {
                            error(CRC_DAQ_CONDIF) /* PRQA S 2001 */ /* MD_Xcp_2001 */
                          } 
              #endif
 3065  5                  addr = (DAQBYTEPTR)ApplXcpGetPointer(CRO_WRITE_DAQ_EXT,CRO_WRITE_DAQ_ADDR);
 3066  5                  
 3067  5                  xcp.CrmLen = CRM_WRITE_DAQ_LEN;
 3068  5                  OdtEntrySize(xcp.DaqListPtr) = CRO_WRITE_DAQ_SIZE;
 3069  5                  OdtEntryAddr(xcp.DaqListPtr) = addr;
 3070  5                  
 3071  5                  xcp.DaqListPtr++; /* Autoincrement */
 3072  5                  
 3073  5      #if defined ( XCP_ENABLE_TESTMODE )
                          if ( gDebugLevel != 0)
                          {
                            ApplXcpPrint("<- 0xFF\n");
C166 COMPILER V7.57.0, XCPBASIC                                                            01/03/2020 16:20:10 PAGE 52  

                          }
              #endif
 3079  5              }
 3080  4              break;
 3081  4              
 3082  4            case CC_START_STOP_DAQ_LIST:
 3083  4              {
 3084  5                vuint8 daq = (vuint8)(CRO_START_STOP_DAQ&0xFFu);
 3085  5                
 3086  5                CheckResourceProtection( RM_DAQ ) /* PRQA S 2001 */ /* MD_Xcp_2001 */
 3087  5                  
 3088  5      #if defined ( XCP_ENABLE_PARAMETER_CHECK )
                          if (daq>=xcp.Daq.DaqCount)
                          {
                            error(CRC_OUT_OF_RANGE) /* PRQA S 2001 */ /* MD_Xcp_2001 */
                          } 
              #endif
 3094  5                  
 3095  5                  if ( (CRO_START_STOP_MODE==1 ) || (CRO_START_STOP_MODE==2) )
 3096  5                  {
 3097  6                    DaqListFlags(daq) |= (vuint8)DAQ_FLAG_SELECTED;
 3098  6      #if defined ( XCP_ENABLE_TESTMODE )
                            if ( gDebugLevel != 0)
                            {
                              XcpPrintDaqList((vuint8)(CRO_START_STOP_DAQ)&0xFFu);
                              ApplXcpPrint("-> START_STOP mode=%02Xh, daq=%u\n",CRO_START_STOP_MODE,CRO_START_STOP_DAQ);
                            }
              #endif
 3105  6                    if ( CRO_START_STOP_MODE == (vuint8)1u )
 3106  6                    {
 3107  7                      XcpStartDaq(daq);
 3108  7                    }
 3109  6                    xcp.CrmLen = CRM_START_STOP_LEN;
 3110  6                    CRM_START_STOP_FIRST_PID = DaqListFirstPid(daq);
 3111  6                  } 
 3112  5                  else
 3113  5                  {
 3114  6                    XcpStopDaq(daq);
 3115  6      #if defined ( XCP_ENABLE_TESTMODE )
                            if ( gDebugLevel != 0)
                            {
                              ApplXcpPrint("-> START_STOP mode=%02Xh\n",CRO_START_STOP_MODE);
                            }
              #endif
 3121  6                  }
 3122  5                  
 3123  5      #if defined ( XCP_ENABLE_TESTMODE )
                          if ( gDebugLevel != 0)
                          {
                            ApplXcpPrint("<- 0xFF\n");
                          }
              #endif
 3129  5              }
 3130  4              break;
 3131  4              
 3132  4            case CC_START_STOP_SYNCH:
 3133  4              {
 3134  5      #if defined ( XCP_ENABLE_TESTMODE )
                        if ( gDebugLevel != 0)
                        {
                          ApplXcpPrint("-> CC_START_STOP_SYNCH mode=%02Xh\n",CRO_START_STOP_MODE);
                        }
C166 COMPILER V7.57.0, XCPBASIC                                                            01/03/2020 16:20:10 PAGE 53  

              #endif
 3140  5                
 3141  5                CheckResourceProtection( RM_DAQ ) /* PRQA S 2001 */ /* MD_Xcp_2001 */
 3142  5                  
 3143  5                  if( (0 == xcp.Daq.DaqCount) || (0 == xcp.Daq.OdtCount) || (0 == xcp.Daq.OdtEntryCount) )
 3144  5                  {
 3145  6                    error(CRC_DAQ_CONDIF) /* PRQA S 2001 */ /* MD_Xcp_2001 */
 3146  6                  }
 3147  5                  
 3148  5                  if (CRO_START_STOP_MODE==2) /* stop selected */
 3149  5                  {
 3150  6                    XcpStopAllSelectedDaq();
 3151  6                  } 
 3152  5                  else
 3153  5                  {
 3154  6                    if (CRO_START_STOP_MODE==1) /* start selected */
 3155  6                    {
 3156  7                      XcpStartAllSelectedDaq();
 3157  7                    }
 3158  6                    else
 3159  6                    {
 3160  7                      /* CRO_START_STOP_MODE==0 : stop all */
 3161  7                      XcpStopAllDaq();
 3162  7                    }
 3163  6                  }
 3164  5      #if defined ( XCP_ENABLE_TESTMODE )
                          if ( gDebugLevel != 0)
                          {
                            ApplXcpPrint("<- 0xFF\n");
                          }
              #endif
 3170  5              }
 3171  4              break;
 3172  4              
 3173  4      #if defined ( XCP_ENABLE_DAQ_TIMESTAMP )
 3174  4            case CC_GET_DAQ_CLOCK:
 3175  4              {
 3176  5                xcp.CrmLen = CRM_GET_DAQ_CLOCK_LEN;
 3177  5                /* PRQA S 3757 1 */ /* MD_Xcp_3757 */
 3178  5                CRM_GET_DAQ_CLOCK_TIME_WRITE((vuint32)ApplXcpGetTimestamp()); /* PRQA S 3109 */ /* MD_MSR_14.3 */
 3179  5                
 3180  5      #if defined ( XCP_ENABLE_TESTMODE )
                        if ( gDebugLevel != 0)
                        {
                          ApplXcpPrint("-> GET_DAQ_CLOCK\n");
                          ApplXcpPrint("<- 0xFF time=%04Xh\n",CRM_GET_DAQ_CLOCK_TIME);
                        }
              #endif
 3187  5              }
 3188  4              break;
 3189  4      #endif
 3190  4              
 3191  4      #endif /* XCP_ENABLE_DAQ */
 3192  4              
 3193  4              
 3194  4              /* Flash Programming Kernel Download */
 3195  4              
 3196  4              
 3197  4              /* Flash Programming direct and Kernel */
 3198  4              
 3199  4              /* Flash Programming  */
 3200  4              
C166 COMPILER V7.57.0, XCPBASIC                                                            01/03/2020 16:20:10 PAGE 54  

 3201  4              
 3202  4      #if defined ( XCP_ENABLE_USER_COMMAND ) 
                    case CC_USER_CMD:
                      {
                        
              #if defined ( XCP_ENABLE_TESTMODE )
                        if ( gDebugLevel != 0)
                        {
                          ApplXcpPrint("-> CC_USER_CMD cmd=%u\n", CRO_BYTE(1));
                        }
              #endif
                        
                        {
                          
              #if defined ( XCP_ENABLE_USER_COMMAND )
                          err = ApplXcpUserService( (const BYTEPTR) &CRO_BYTE(0) );
                          
                          if (err==(vuint8)XCP_CMD_PENDING)
                          {
                            goto no_response;  /* PRQA S 2001 */ /* MD_Xcp_2001 */
                          }
                          if (err==(vuint8)XCP_CMD_SYNTAX)
                          {
                            error(CRC_CMD_SYNTAX) /* PRQA S 2001 */ /* MD_Xcp_2001 */
                          }
              #endif
                        }
                        
              #if defined ( XCP_ENABLE_TESTMODE )
                        if ( gDebugLevel != 0)
                        {
                          ApplXcpPrint("<- 0xFF\n");
                        }
              #endif
                        
                      }
                      break;
              #endif
 3239  4              
 3240  4              
 3241  4              
 3242  4              
 3243  4            default: /* unknown */
 3244  4              {
 3245  5      #if defined ( XCP_ENABLE_TESTMODE )
                        if ( gDebugLevel != 0)
                        {
                          ApplXcpPrint("-> UNKNOWN COMMAND %02X\n", CRO_CMD);
                        }
              #endif
 3251  5                error(CRC_CMD_UNKNOWN) /* PRQA S 2001 */ /* MD_Xcp_2001 */
 3252  5              }
 3253  4              
 3254  4            } /* switch */
 3255  3          
 3256  3            goto positive_response; /* PRQA S 2001 */ /* MD_Xcp_2001 */
 3257  3          }
 3258  2        
 3259  2          /* Not connected */
 3260  2          else
 3261  2          {
 3262  3          goto no_response; /* PRQA S 2001 */ /* MD_Xcp_2001 */
C166 COMPILER V7.57.0, XCPBASIC                                                            01/03/2020 16:20:10 PAGE 55  

 3263  3          }
 3264  2        } /* CC_CONNECT */
 3265  1        
 3266  1      negative_response:
 3267  1        xcp.CrmLen = 2;
 3268  1        
 3269  1      #if defined ( XCP_ENABLE_CHECKSUM ) 
 3270  1      negative_response1:
 3271  1      #endif
 3272  1        CRM_CMD = (vuint8)PID_ERR;
 3273  1        CRM_ERR = (vuint8)err;
 3274  1      #if defined ( XCP_ENABLE_TESTMODE )
                if ( gDebugLevel != 0) 
                {
                  ApplXcpPrint("<- 0xFE error=%02Xh\n",err);
                }
              #endif
 3280  1        
 3281  1      positive_response:
 3282  1        XcpSendCrm();
 3283  1        
 3284  1      no_response:
 3285  1        END_PROFILE(1); /* Timingtest */
 3286  1        return;
 3287  1        /* PRQA S 2006 5 */ /* MD_MSR_14.7 */
 3288  1        /* PRQA S 6010 4 */ /* MD_MSR_STPTH */
 3289  1        /* PRQA S 6030 3 */ /* MD_MSR_STCYC */
 3290  1        /* PRQA S 6050 2 */ /* MD_MSR_STCAL */
 3291  1        /* PRQA S 6080 1 */ /* MD_MSR_STMIF */
 3292  1      }
 3293         
 3294         
 3295         /****************************************************************************/
 3296         /* Send notification callback                                               */
 3297         /****************************************************************************/
 3298         
 3299         
 3300         /*****************************************************************************
 3301         | NAME:             XcpSendCallBack
 3302         | CALLED BY:        XCP Transport Layer
 3303         | PRECONDITIONS:    none
 3304         | INPUT PARAMETERS: none
 3305         | RETURN VALUES:    0 : if the XCP Protocol Layer is idle (no transmit messages are pending)
 3306         | DESCRIPTION:      Notifies the XCP Protocol Layer about the successful
 3307         |                   transmission of a XCP packet.
 3308         ******************************************************************************/
 3309         vuint8 XcpSendCallBack( void )
 3310         {
 3311  1        BEGIN_PROFILE(2); /* Timingtest */
 3312  1        
 3313  1        /* Activation control */
 3314  1        XcpPlCheckControlStateRet((vuint8)1u)
 3315  1          
 3316  1      #if defined ( XCP_ENABLE_DAQ ) && defined ( XCP_ENABLE_SEND_QUEUE )
 3317  1          
 3318  1          /* Clear all pending flags */
 3319  1          /* A pending flag indicates that ApplXcpSend() is in progress */
 3320  1          xcp.SendStatus &= (vuint8)(~XCP_SEND_PENDING & 0xFFu);
 3321  1        
 3322  1        /* Now check if there is another transmit request */
 3323  1        
 3324  1        /* Send a RES or ERR (CRM) message */
C166 COMPILER V7.57.0, XCPBASIC                                                            01/03/2020 16:20:10 PAGE 56  

 3325  1        if ( (xcp.SendStatus & (vuint8)XCP_CRM_REQUEST) != 0 )
 3326  1        {
 3327  2          xcp.SendStatus &= (vuint8)(~XCP_CRM_REQUEST & 0xFFu);
 3328  2          XcpSendCrm();
 3329  2          END_PROFILE(2); /* Timingtest */
 3330  2          return (vuint8)0x01u;
 3331  2        }
 3332  1        
 3333  1        /* Send a EV or SERV message */
 3334  1      #if defined ( XCP_ENABLE_SEND_EVENT ) || defined ( XCP_ENABLE_SERV_TEXT )
 3335  1        if ( (xcp.SendStatus & (vuint8)XCP_EVT_REQUEST) != 0 )
 3336  1        {
 3337  2          xcp.SendStatus &= (vuint8)(~XCP_EVT_REQUEST & 0xFFu);
 3338  2          XcpSendEv();
 3339  2          END_PROFILE(2); /* Timingtest */
 3340  2          return (vuint8)0x01u;
 3341  2        }
 3342  1      #endif
 3343  1        
 3344  1        /* Send a DAQ message from the queue or from the buffer */
 3345  1        if ( (xcp.SessionStatus & (SessionStatusType)SS_DAQ) != 0 )
 3346  1        {
 3347  2          if ( XcpSendDtoFromQueue() != 0 )
 3348  2          {
 3349  3            END_PROFILE(2); /* Timingtest */
 3350  3            return (vuint8)0x01u;
 3351  3          }
 3352  2        }
 3353  1      #endif /* XCP_ENABLE_DAQ && XCP_ENABLE_SEND_QUEUE */
 3354  1        
 3355  1        /* Continue a pending block upload command */
 3356  1        
 3357  1        END_PROFILE(2); /* Timingtest */
 3358  1        return (vuint8)0x00u;
 3359  1        /* PRQA S 2006 1 */ /* MD_MSR_14.7 */
 3360  1      }
 3361         
 3362         
 3363         /****************************************************************************/
 3364         /* Initialization / de-initialization                                       */
 3365         /****************************************************************************/
 3366         
 3367         
 3368         /*****************************************************************************
 3369         | NAME:             XcpInit
 3370         | CALLED BY:        application
 3371         | PRECONDITIONS:    the data link layer has to be initialized.
 3372         | INPUT PARAMETERS: none
 3373         | RETURN VALUES:    none
 3374         | DESCRIPTION:      Initialization of the XCP Protocol Layer
 3375         |                   Application specific initialization
 3376         |                    ( e.g. Vector XCP on CAN Transport Layer )
 3377         ******************************************************************************/
 3378         void XcpInit( void )
 3379         {
 3380  1      #if defined ( XCP_ENABLE_TESTMODE )
                gDebugLevel = 1;
              #endif
 3383  1        
 3384  1        /* Application specific initialization function. */
 3385  1        ApplXcpInit();
 3386  1        
C166 COMPILER V7.57.0, XCPBASIC                                                            01/03/2020 16:20:10 PAGE 57  

 3387  1        /* Initialize all XCP variables to zero */
 3388  1        XcpMemClr((BYTEPTR)&xcp,(vuint16)sizeof(xcp)); /* PRQA S 0310 */ /* MD_Xcp_0310_ByteCopy */
 3389  1        
 3390  1        /* We set 8 bytes as default for CAN */
 3391  1        XcpSetActiveTl(8, 8, 0);
 3392  1        
 3393  1        /* Initialize the RAM interface */
 3394  1        
 3395  1        /* Initialize the session status (ESCAN00013899) */
 3396  1        xcp.SessionStatus = (SessionStatusType)0u;
 3397  1        
 3398  1      #if defined ( XCP_ENABLE_SEND_QUEUE)
 3399  1        /* Initialize the transmit queue (ESCAN00013899) */
 3400  1        xcp.SendStatus = (vuint8)0u;
 3401  1      #endif
 3402  1        
 3403  1        /* Resume DAQ */
 3404  1      #if defined ( XCP_ENABLE_DAQ )
 3405  1      #endif /* XCP_ENABLE_DAQ */
 3406  1      }
 3407         
 3408         /*****************************************************************************
 3409         | NAME:             XcpExit
 3410         | CALLED BY:        application
 3411         | PRECONDITIONS:    The XCP Protocol Layer has to be initialized.
 3412         | INPUT PARAMETERS: none
 3413         | RETURN VALUES:    none
 3414         | DESCRIPTION:      De-initialization of the XCP Protocol Layer.
 3415         ******************************************************************************/
 3416         void XcpExit( void )
 3417         {
 3418  1        /* Activation control */
 3419  1        XcpPlCheckControlState()
 3420  1          
 3421  1          /* Deinitialize the RAM interface */
 3422  1          /* PRQA S 2006 1 */ /* MD_MSR_14.7 */
 3423  1      }
 3424         
 3425         
 3426         /****************************************************************************/
 3427         /* Print via SERV/SERV_TEXT                                                */
 3428         /****************************************************************************/
 3429         
 3430         
 3431         #if defined ( XCP_ENABLE_SERV_TEXT )
              #if defined ( XCP_ENABLE_SERV_TEXT_PUTCHAR )
              
              /*****************************************************************************
              | NAME:             XcpPutChar
              | CALLED BY:        application, XcpPrint
              | PRECONDITIONS:    XCP is initialized and in connected state.
              | INPUT PARAMETERS: c : character
              | RETURN VALUES:    none
              | DESCRIPTION:      Put a char into a service request packet (SERV).
              ******************************************************************************/
              void XcpPutchar( const vuint8 c )
              {
                /* Activation control */
                XcpPlCheckControlState()
                  
                  /* Check for stall condition */         
              #if defined ( XCP_ENABLE_SEND_QUEUE )
C166 COMPILER V7.57.0, XCPBASIC                                                            01/03/2020 16:20:10 PAGE 58  

                  
                  while ( (xcp.SendStatus & (vuint8)XCP_EVT_REQUEST) != 0 )
                  {
                    if ( ApplXcpSendStall() == 0 )
                    {
                      return; /* Abort */
                    }
                  }
                  
              #endif
                  
                  /* If xcp.EvLen!=0 there is a pending text message*/
                  if (xcp.EvLen<2)
                  {
                    xcp.EvLen = 2;
                  }
                  
                  xcp.Ev.b[xcp.EvLen] = c;
                  xcp.EvLen++;
                  
                  if ( (xcp.EvLen>=(vuint8)kXcpMaxCTO) || (c==(vuint8)0x00u) )  /* Flush */
                  { 
                    EV_BYTE(0) = 0xFC; /* SERV */
                    EV_BYTE(1) = 0x01; /* SERV_TEXT*/
                    XcpSendEv();
                  }
                  /* PRQA S 2006 1 */ /* MD_MSR_14.7 */
              }
              
              #if defined ( XCP_ENABLE_SERV_TEXT_PRINT )
              
              /*****************************************************************************
              | NAME:             XcpPrint
              | CALLED BY:        application
              | PRECONDITIONS:    XCP is initialized and in connected state.
              | INPUT PARAMETERS: *str : pointer to a string
              | RETURN VALUES:    none
              | DESCRIPTION:      Transmission of a service request packet (SERV).
              ******************************************************************************/
              void XcpPrint( const vuint8 *str )
              {
                /* Activation control */
                XcpPlCheckControlState()
                  
                  /* Transmit the text message. */
                  while ( *str != 0x00 )
                  {
                    XcpPutchar(*str);
                    str++; /* PRQA S 0489 */ /* MD_Xcp_0489 */
                  }
                  /* Transmit the terminating 0x00. */
                  XcpPutchar( (vuint8)0x00u );
                  /* PRQA S 2006 1 */ /* MD_MSR_14.7 */
              }
              
              #endif
              #if defined ( XCP_ENABLE_SERV_TEXT_PRINTF )
              
              /*****************************************************************************
              | NAME:             XcpPrintf
              | CALLED BY:        application
              | PRECONDITIONS:    none
C166 COMPILER V7.57.0, XCPBASIC                                                            01/03/2020 16:20:10 PAGE 59  

              | INPUT PARAMETERS: *str : pointer to a string
              |                   ...  : varaibale number of parameters (see printf)
              | RETURN VALUES:    none
              | DESCRIPTION:      Printf into a SERV_TEXT message
              ******************************************************************************/
              void XcpPrintf( const vuint8 *str, ... )
              {
                va_list argptr;
                vuint8 buf[128];
                
                /* Activation control */
                XcpPlCheckControlState()
                  
                  va_start(argptr,str);
                vsprintf((vsint8*)buf,( const vsint8*)str,argptr );
                va_end(argptr);
                
                /* Transmit the text message*/
                {
                  vuint8 *p = buf;
                  while (*p != 0)
                  {
                    XcpPutchar(*p);
                    p++; /* PRQA S 0489 */ /* MD_Xcp_0489 */
                  }
                }
                /* Transmit the terminating 0x00. */
                XcpPutchar( 0x00 );
              }
              
              #endif /* XCP_ENABLE_SERV_TEXT_PRINTF */
              #endif /* XCP_ENABLE_SERV_TEXT_PUTCHAR */
              #endif /* XCP_ENABLE_SERV_TEXT */
 3544         
 3545         
 3546         #if defined ( XCP_ENABLE_SEND_EVENT )
 3547         
 3548         /*****************************************************************************
 3549         | NAME:             XcpSendEvent
 3550         | CALLED BY:        application
 3551         | PRECONDITIONS:    none
 3552         | INPUT PARAMETERS: evc : event code 
 3553         |                   c   : pointer to event data
 3554         |                   len : event data length
 3555         | RETURN VALUES:    none
 3556         | DESCRIPTION:      Transmission of an event packet (EV).
 3557         ******************************************************************************/
 3558         void XcpSendEvent( vuint8 evc, const BYTEPTR c, vuint8 len)
 3559         {
 3560  1        vuint8 i;
 3561  1        
 3562  1        /* Activation control */
 3563  1        XcpPlCheckControlState()
 3564  1          
 3565  1          /* Check for stall condition */         
 3566  1      #if defined ( XCP_ENABLE_SEND_QUEUE )
 3567  1          while ( (xcp.SendStatus & (vuint8)XCP_EVT_REQUEST) != (vuint8)0u )
 3568  1          {
 3569  2            if (!ApplXcpSendStall())
 3570  2            {
 3571  3              return; /* Abort */
 3572  3            }
C166 COMPILER V7.57.0, XCPBASIC                                                            01/03/2020 16:20:10 PAGE 60  

 3573  2          }
 3574  1      #endif
 3575  1          
 3576  1          EV_BYTE(0)  = PID_EV; /* Event*/
 3577  1          EV_BYTE(1)  = evc;  /* Event Code*/
 3578  1          xcp.EvLen   = 2;
 3579  1          
 3580  1          if (len <= (vuint8)(kXcpMaxCTO-2) )
 3581  1          {
 3582  2            if (c != 0x00u)
 3583  2            {
 3584  3              for (i = 0; i < len; i++)
 3585  3              {
 3586  4                xcp.Ev.b[xcp.EvLen]       = c[i];
 3587  4                xcp.EvLen++;
 3588  4              }
 3589  3            } 
 3590  2            else
 3591  2            {
 3592  3              xcp.EvLen += len;
 3593  3            }
 3594  2          }
 3595  1          
 3596  1      #if defined ( XCP_ENABLE_TESTMODE )
                  if ( gDebugLevel != 0)
                  {
                    ApplXcpPrint("[XcpSendEvent]");
                    for (i = 0; i < xcp.EvLen; i++)
                    {
                      ApplXcpPrint(" %02x",xcp.Ev.b[i]);
                    }
                    ApplXcpPrint("\n");
                  }
              #endif
 3607  1          
 3608  1          XcpSendEv();
 3609  1          /* PRQA S 2006 1 */ /* MD_MSR_14.7 */
 3610  1      }
 3611         
 3612         #endif /* XCP_ENABLE_SEND_EVENT */
 3613         
 3614         #if defined ( XCP_ENABLE_GET_CONNECTION_STATE ) || defined ( XCP_ENABLE_GET_SESSION_STATUS_API )
              /*****************************************************************************
              | NAME:             XcpGetState
              | CALLED BY:        XcpPreCopy
              | PRECONDITIONS:    none
              | INPUT PARAMETERS: none
              | RETURN VALUES:    XCP_CONNECTED    : XCP is connected
              |                   XCP_DISCONNECTED : XCP is disconnected
              | DESCRIPTION:      Get the connection state of the XCP Protocol Layer
              ******************************************************************************/
              vuint8 XcpGetState( void )
              {
                return ((xcp.SessionStatus & (SessionStatusType)SS_CONNECTED) > 0u) ? XCP_CONNECTED : XCP_DISCONNECTED;
              }
              #endif
 3629         
 3630         #if defined ( XCP_ENABLE_GET_SESSION_STATUS_API )
              /*****************************************************************************
              | NAME:             XcpGetSessionStatus
              | CALLED BY:        -
              | PRECONDITIONS:    none
C166 COMPILER V7.57.0, XCPBASIC                                                            01/03/2020 16:20:10 PAGE 61  

              | INPUT PARAMETERS: none
              | RETURN VALUES:    Xcp session state
              | DESCRIPTION:      Get the session state of the XCP Protocol Layer
              ******************************************************************************/
              SessionStatusType XcpGetSessionStatus( void )
              {
                SessionStatusType result;
                
                result = xcp.SessionStatus;
                /* Reset the polling state */
                xcp.SessionStatus &= (SessionStatusType)(~SS_POLLING);
                return(result);
              } /* PRQA S 2006 */ /* MD_MSR_14.7 */
              #endif
 3649         
 3650         
 3651         #if defined ( XCP_ENABLE_GET_XCP_DATA_POINTER )
                        /*****************************************************************************
                        | NAME:             XcpGetXcpDataPointer
                        | CALLED BY:        Application
                        | PRECONDITIONS:    none
                        | INPUT PARAMETERS: tXcpData ** pXcpData: Pointer to Pointer that is set to xcp
                        | RETURN VALUES:    none
                        | DESCRIPTION:      Get the pointer to the internal xcp structure
              ******************************************************************************/
              void XcpGetXcpDataPointer( RAM tXcpData ** pXcpData )
              {
                *pXcpData = &xcp;
              }
              #endif
 3665         
 3666         
 3667         #if defined ( XCP_ENABLE_VERSION_INFO_API )
              /**************************************************************************************************
              Function name    : XcpGetVersionInfo
              ------------------------------------------------------------------------------------------------
              Description      : Returns version information of module
              ------------------------------------------------------------------------------------------------
              Called by        : -
              ------------------------------------------------------------------------------------------------
              Parameter        : Pointer to location at which version information shall be stored at
              ------------------------------------------------------------------------------------------------
              Returncode       : void
              ------------------------------------------------------------------------------------------------
              Misc             : -
              **************************************************************************************************/
              void XcpGetVersionInfo(Std_VersionInfoType *XcpVerInfoPtr)
              {
              /* Since this service only access non-volatile data and no channel parameter is passed,
                checking of the channel handle and initialization is omitted. */
                XcpVerInfoPtr->vendorID = XCP_VENDOR_ID;
                XcpVerInfoPtr->moduleID = XCP_MODULE_ID;
                XcpVerInfoPtr->sw_major_version = (CP_XCP_VERSION >> 8u);
                XcpVerInfoPtr->sw_minor_version = (CP_XCP_VERSION & 0xff);
                XcpVerInfoPtr->sw_patch_version = CP_XCP_RELEASE_VERSION;
              }
              #endif /* XCP_ENABLE_VERSION_INFO_API */
 3692         
 3693         
 3694         /****************************************************************************/
 3695         /* Test                                                                     */
 3696         /* Some screen output functions for test and diagnostics                    */
C166 COMPILER V7.57.0, XCPBASIC                                                            01/03/2020 16:20:10 PAGE 62  

 3697         /****************************************************************************/
 3698         
 3699         
 3700         #if defined ( XCP_ENABLE_TESTMODE )
              #if defined ( XCP_ENABLE_DAQ )
              
              /*****************************************************************************
              | NAME:             XcpPrintDaqList
              | CALLED BY:        
              | PRECONDITIONS:    none
              | INPUT PARAMETERS: 
              | RETURN VALUES:    none
              | DESCRIPTION:      Print all DAQ lists to screen
              ******************************************************************************/
              void XcpPrintDaqList( vuint8 daq )
              {
                vuint8 i;
                vuint16 e;
                
                /* Activation control */
                XcpPlCheckControlState()
                  
                  if (daq>=xcp.Daq.DaqCount)
                  {
                    return;
                  }
                  
                  ApplXcpPrint("DAQ %u:\n",daq);
              #if defined ( kXcpMaxEvent ) 
                  for (i=0;i<kXcpMaxEvent;i++)
                  {
                    if (xcp.Daq.EventDaq[i]==daq)
                    {
                      ApplXcpPrint(" eventchannel=%04Xh,",i);
                    }
                  }
              #else
                  ApplXcpPrint(" eventchannel=%04Xh,",DaqListEventChannel(daq));
              #endif
              #if defined (XCP_ENABLE_DAQ_PRESCALER )
                  ApplXcpPrint(" prescaler=%u,",DaqListPrescaler(daq));
              #endif
                  ApplXcpPrint(" firstOdt=%u,",DaqListFirstOdt(daq));
                  ApplXcpPrint(" lastOdt=%u,",DaqListLastOdt(daq));
                  ApplXcpPrint(" flags=%02Xh\n",DaqListFlags(daq));
                  ApplXcpPrint(" firstPid=%02Xh\n",DaqListFirstPid(daq)); 
                  for (i=DaqListFirstOdt(daq);i<=DaqListLastOdt(daq);i++)
                  {
                    ApplXcpPrint("  ODT %u (%u):\n",i-DaqListFirstOdt(daq),i);
                    ApplXcpPrint("   pid=%u:\n",i);
                    ApplXcpPrint("   firstOdtEntry=%u,lastOdtEntry=%u:\n",DaqListOdtFirstEntry(i),DaqListOdtLastEntry(i));
                    for (e=DaqListOdtFirstEntry(i);e<=DaqListOdtLastEntry(i);e++)
                    {
                      ApplXcpPrint("   [%08Xh,%u]\n",OdtEntryAddr(e),OdtEntrySize(e));
                    }
                  } /* j */
              } /* Deviation of MISRA rule 82 (more than one return path). */
              
              #endif /* XCP_ENABLE_DAQ */
              #endif /* XCP_ENABLE_TESTMODE */
 3757         
 3758         
C166 COMPILER V7.57.0, XCPBASIC                                                            01/03/2020 16:20:10 PAGE 63  

 3759         
 3760           /*******************************************************************************
 3761           Consistency checks
 3762         *******************************************************************************/
 3763         
 3764         /* Check definition of endianess of CPU */
 3765         
 3766         #if defined ( XCP_CPUTYPE_LITTLEENDIAN ) || defined ( XCP_CPUTYPE_BIGENDIAN )
 3767         #else
              #error "Please define XCP_CPUTYPE_LITTLEENDIAN or XCP_CPUTYPE_BIGENDIAN."
              #endif
 3770         
 3771         /* Check consistency of alignment switch */
 3772         
 3773         #if defined ( XCP_DISABLE_UNALIGNED_MEM_ACCESS )
 3774         #if defined ( C_CPUTYPE_8BIT )
              #error "XCP consistency error: Forcing alignment for 8-bit microcontrollers is useless."
              #endif
 3777         #if defined ( XCP_ENABLE_UNALIGNED_MEM_ACCESS )
              #error "XCP consistency error: Select either alignment or no alignment."
              #endif
 3780         #else /* if defined ( XCP_DISABLE_UNALIGNED_MEM_ACCESS ) */
              #if defined ( XCP_ENABLE_UNALIGNED_MEM_ACCESS )
              #else
              #error "XCP consistency error: Usage of alignment not specified."
              #endif
              #endif /* if defined ( XCP_DISABLE_UNALIGNED_MEM_ACCESS ) */
 3786         
 3787         
 3788         /*******************************************************************************
 3789         * Organi check
 3790         *******************************************************************************/
 3791         
 3792         
 3793         
 3794         
 3795         
 3796         
 3797         
 3798         
 3799         
 3800         
 3801         
 3802         
 3803         
 3804         
 3805         
 3806         
 3807         
 3808         
 3809         
 3810         
 3811         
 3812         /* module specific MISRA deviations:
 3813         MD_Xcp_0306:    Rule 11.3
 3814         Reason:     Pointer alignment has to be set manually due to dynamically structures; solved via cast to int
             -, AND calculation and cast back to a pointer.
 3815         Risk:       Maintainability reduced due to optimization.
 3816         Prevention: Covered by code review.
 3817         MD_Xcp_0310:    Rule 11.4
 3818         Reason:     Alignment is given by calling function.
 3819         Risk:       Maintainability reduced due to optimization.
C166 COMPILER V7.57.0, XCPBASIC                                                            01/03/2020 16:20:10 PAGE 64  

 3820         Prevention: Covered by code review.
 3821         MD_Xcp_0310_ByteCopy: Rule 11.4
 3822         Reason:     XCP accesses arrays always byte-wise (ODT handling and interpretation)
 3823         Risk:       Maintainability reduced due to optimization.
 3824         Prevention: Covered by code review.
 3825         MD_Xcp_0311_StimBuffer: Rule 11.5
 3826         Reason:     Casting to remove const for optimization reason; XCP command data is re-used for status flag h
             -andling.
 3827         Risk:       Maintainability reduced due to optimization.
 3828         Prevention: Covered by code review.
 3829         MD_Xcp_0488:    Rule 17.4
 3830         Reason:     For optimization reasons direct pointer arithmetic is used.
 3831         Risk:       There is no risk as this has no effect on the code.
 3832         Prevention: Covered by code review.
 3833         MD_Xcp_0489:    Rule 17.4
 3834         Reason:     For optimization reasons direct pointer arithmetic is used.
 3835         Risk:       There is no risk as this has no effect on the code.
 3836         Prevention: Covered by code review.
 3837         MD_Xcp_0770:    Rule 14.5
 3838         Reason:     For optimization reasons more than one break/continue was used to leave the for loop.
 3839         Risk:       Maintainability reduced due to multiple break/continue statements.
 3840         Prevention: Covered by code review.
 3841         MD_Xcp_2001:    Rule 14.4
 3842         Reason:     For optimization reasons a goto is used.
 3843         Risk:       There is no risk as this the goto is only used function internally.
 3844         Prevention: Covered by code review.
 3845         MD_Xcp_2003:    Rule 15.2
 3846         Reason:     For optimization reasons fall-through is used.
 3847         Risk:       There is no risk as this the goto is only used function internally.
 3848         Prevention: Covered by code review.
 3849         MD_Xcp_3397:    Rule 12.1
 3850         Reason:     The statement as used in the ASAM specification is used.
 3851         Risk:       There is no risk as this is reviewd by ASAM group.
 3852         Prevention: Covered by code review.
 3853         MD_Xcp_3408:    Rule 8.8
 3854         Reason:     The variable is not defined as static to be accessible for calibration. No prototype is requir
             -ed for this.
 3855         Risk:       There is no risk as this variable is not accessed externally.
 3856         Prevention: Covered by code review.
 3857         MD_Xcp_3757:    Rule 10.1
 3858         Reason:     Due to byte access the variable is split.
 3859         Risk:       There is no risk as this variable is positive.
 3860         Prevention: Covered by code review.
 3861         MD_Xcp_4130:    Rule 12.7
 3862         Reason:     When a vuint8 is in reality 16bit then proper value range must be handled by and mask.
 3863         Risk:       There is no risk as the target variable is intended to be uint8.
 3864         Prevention: Covered by code review.
 3865         */
 3866         
 3867         /*********************************************************************************************************
             -*************
 3868         *  END OF FILE: XcpProf.c
 3869         **********************************************************************************************************
             -***********/
C166 COMPILER V7.57.0, XCPBASIC                                                            01/03/2020 16:20:10 PAGE 65  

ASSEMBLY LISTING OF GENERATED OBJECT CODE


             ; FUNCTION XcpMemSet (BEGIN  RMASK = @0x4540)
                                           ; SOURCE LINE # 493
;---- Variable 'b' assigned to Register 'R11' ----
;---- Variable 'n' assigned to Register 'R10' ----
;---- Variable 'p' assigned to Register 'R8/R9' ----
                                           ; SOURCE LINE # 495
0000 0D05          JMPR      cc_UC,?C0003
0002         ?C0004:
                                           ; SOURCE LINE # 497
0002 F06B          MOV       R6,R11
0004 DC49          EXTP      R9,#01H
0006 B9C8          MOVB      [R8],RL6
                                           ; SOURCE LINE # 498
0008 0881          ADD       R8,#01H
                                           ; SOURCE LINE # 499
000A 28A1          SUB       R10,#01H
000C         ?C0003:
000C 48A0          CMP       R10,#00H
000E EDF9          JMPR      cc_UGT,?C0004
0010         ?C0002:
                                           ; SOURCE LINE # 500
0010 DB00          RETS      
             ; FUNCTION XcpMemSet (END    RMASK = @0x4540)

             ; FUNCTION XcpMemClr (BEGIN  RMASK = @0x4DD0)
                                           ; SOURCE LINE # 517
0012 F04A          MOV       R4,R10
;---- Variable 'n' assigned to Register 'R4' ----
0014 F068          MOV       R6,R8
0016 F079          MOV       R7,R9
;---- Variable 'p' assigned to Register 'R6/R7' ----
                                           ; SOURCE LINE # 519
0018 E00B          MOV       R11,#00H
001A DA000000 R    CALLS     SEG (XcpMemSet),XcpMemSet
                                           ; SOURCE LINE # 520
001E DB00          RETS      
             ; FUNCTION XcpMemClr (END    RMASK = @0x4DD0)

             ; FUNCTION XcpMemCpy (BEGIN  RMASK = @0x5550)
                                           ; SOURCE LINE # 542
;---- Variable 'n' assigned to Register 'R12' ----
;---- Variable 'src' assigned to Register 'R10/R11' ----
;---- Variable 'dest' assigned to Register 'R8/R9' ----
                                           ; SOURCE LINE # 544
0020 0D07          JMPR      cc_UC,?C0008
0022         ?C0009:
                                           ; SOURCE LINE # 547
0022 DC4B          EXTP      R11,#01H
0024 A9CA          MOVB      RL6,[R10]
0026 DC49          EXTP      R9,#01H
0028 B9C8          MOVB      [R8],RL6
                                           ; SOURCE LINE # 548
002A 0881          ADD       R8,#01H
                                           ; SOURCE LINE # 549
002C 08A1          ADD       R10,#01H
                                           ; SOURCE LINE # 550
002E 28C1          SUB       R12,#01H
0030         ?C0008:
0030 F04C          MOV       R4,R12
C166 COMPILER V7.57.0, XCPBASIC                                                            01/03/2020 16:20:10 PAGE 66  

0032 4980          CMPB      RL4,#00H
0034 EDF6          JMPR      cc_UGT,?C0009
0036         ?C0007:
                                           ; SOURCE LINE # 551
0036 DB00          RETS      
             ; FUNCTION XcpMemCpy (END    RMASK = @0x5550)

             ; FUNCTION XcpSetActiveTl (BEGIN  RMASK = @0x4010)
                                           ; SOURCE LINE # 564
;---- Variable 'ActiveTl' assigned to Register 'R10' ----
;---- Variable 'MaxDto' assigned to Register 'R9' ----
;---- Variable 'MaxCto' assigned to Register 'R8' ----
                                           ; SOURCE LINE # 569
0038 F04A          MOV       R4,R10
003A D7400000 R    EXTP      #PAG (xcp),#01H
003E F7F82200 R    MOVB      POF (xcp+022H),RL4
                                           ; SOURCE LINE # 570
0042 DB00          RETS      
             ; FUNCTION XcpSetActiveTl (END    RMASK = @0x4010)

             ; FUNCTION XcpGetActiveTl (BEGIN  RMASK = @0x0010)
                                           ; SOURCE LINE # 580
                                           ; SOURCE LINE # 582
0044 D7400000 R    EXTP      #PAG (xcp),#01H
0048 F3F82200 R    MOVB      RL4,POF (xcp+022H)
                                           ; SOURCE LINE # 583
004C DB00          RETS      
             ; FUNCTION XcpGetActiveTl (END    RMASK = @0x0010)

             ; FUNCTION XcpSendCrm (BEGIN  RMASK = @0x7FFF)
                                           ; SOURCE LINE # 602
                                           ; SOURCE LINE # 609
004E DA000000 E    CALLS     SEG (ApplXcpInterruptDisable),ApplXcpInterruptDisable
                                           ; SOURCE LINE # 611
0052 D7400000 R    EXTP      #PAG (xcp),#01H
0056 F3F83E08 R    MOVB      RL4,POF (xcp+083EH)
005A 67F87000      ANDB      RL4,#070H
005E 2D19          JMPR      cc_Z,?C0012
                                           ; SOURCE LINE # 613
0060 D7400000 R    EXTP      #PAG (xcp),#01H
0064 F3F83E08 R    MOVB      RL4,POF (xcp+083EH)
0068 9AF40900      JNB       R4.0,?C0013
                                           ; SOURCE LINE # 616
006C D7400000 R    EXTP      #PAG (xcp),#01H
0070 F2F41400 R    MOV       R4,POF (xcp+014H)
0074 4FF4          BSET      R4.4
0076 D7400000 R    EXTP      #PAG (xcp),#01H
007A F6F41400 R    MOV       POF (xcp+014H),R4
                                           ; SOURCE LINE # 617
007E         ?C0013:
                                           ; SOURCE LINE # 618
007E D7400000 R    EXTP      #PAG (xcp),#01H
0082 F3F83E08 R    MOVB      RL4,POF (xcp+083EH)
0086 7981          ORB       RL4,#01H
0088 D7400000 R    EXTP      #PAG (xcp),#01H
008C F7F83E08 R    MOVB      POF (xcp+083EH),RL4
                                           ; SOURCE LINE # 619
0090 0D14          JMPR      cc_UC,?C0014
0092         ?C0012:
                                           ; SOURCE LINE # 622
0092 D7400000 R    EXTP      #PAG (xcp),#01H
0096 F3F83E08 R    MOVB      RL4,POF (xcp+083EH)
C166 COMPILER V7.57.0, XCPBASIC                                                            01/03/2020 16:20:10 PAGE 67  

009A 77F81000      ORB       RL4,#010H
009E D7400000 R    EXTP      #PAG (xcp),#01H
00A2 F7F83E08 R    MOVB      POF (xcp+083EH),RL4
                                           ; SOURCE LINE # 623
00A6 E6F90000 R    MOV       R9,#POF (xcp)
00AA E6FA0000 R    MOV       R10,#PAG (xcp)
00AE D7400000 R    EXTP      #PAG (xcp),#01H
00B2 C2F80800 R    MOVBZ     R8,POF (xcp+08H)
00B6 DA000000 E    CALLS     SEG (XcpCanSend),XcpCanSend
                                           ; SOURCE LINE # 624
00BA         ?C0014:
                                           ; SOURCE LINE # 626
00BA DA000000 E    CALLS     SEG (ApplXcpInterruptEnable),ApplXcpInterruptEnable
                                           ; SOURCE LINE # 636
00BE DB00          RETS      
             ; FUNCTION XcpSendCrm (END    RMASK = @0x7FFF)

             ; FUNCTION XcpSendEv (BEGIN  RMASK = @0x7FFF)
                                           ; SOURCE LINE # 647
                                           ; SOURCE LINE # 651
00C0 DA000000 E    CALLS     SEG (ApplXcpInterruptDisable),ApplXcpInterruptDisable
                                           ; SOURCE LINE # 653
00C4 D7400000 R    EXTP      #PAG (xcp),#01H
00C8 F3F83E08 R    MOVB      RL4,POF (xcp+083EH)
00CC 67F87000      ANDB      RL4,#070H
00D0 2D19          JMPR      cc_Z,?C0015
                                           ; SOURCE LINE # 655
00D2 D7400000 R    EXTP      #PAG (xcp),#01H
00D6 F3F83E08 R    MOVB      RL4,POF (xcp+083EH)
00DA 9AF40920      JNB       R4.2,?C0016
                                           ; SOURCE LINE # 658
00DE D7400000 R    EXTP      #PAG (xcp),#01H
00E2 F2F41400 R    MOV       R4,POF (xcp+014H)
00E6 4FF4          BSET      R4.4
00E8 D7400000 R    EXTP      #PAG (xcp),#01H
00EC F6F41400 R    MOV       POF (xcp+014H),R4
                                           ; SOURCE LINE # 659
00F0         ?C0016:
                                           ; SOURCE LINE # 660
00F0 D7400000 R    EXTP      #PAG (xcp),#01H
00F4 F3F83E08 R    MOVB      RL4,POF (xcp+083EH)
00F8 7984          ORB       RL4,#04H
00FA D7400000 R    EXTP      #PAG (xcp),#01H
00FE F7F83E08 R    MOVB      POF (xcp+083EH),RL4
                                           ; SOURCE LINE # 661
0102 0D18          JMPR      cc_UC,?C0017
0104         ?C0015:
                                           ; SOURCE LINE # 664
0104 D7400000 R    EXTP      #PAG (xcp),#01H
0108 F3F83E08 R    MOVB      RL4,POF (xcp+083EH)
010C 77F84000      ORB       RL4,#040H
0110 D7400000 R    EXTP      #PAG (xcp),#01H
0114 F7F83E08 R    MOVB      POF (xcp+083EH),RL4
                                           ; SOURCE LINE # 665
0118 E6F90A00 R    MOV       R9,#POF (xcp+0AH)
011C E6FA0000 R    MOV       R10,#PAG (xcp)
0120 D7400000 R    EXTP      #PAG (xcp),#01H
0124 C2F81200 R    MOVBZ     R8,POF (xcp+012H)
0128 DA000000 E    CALLS     SEG (XcpCanSend),XcpCanSend
                                           ; SOURCE LINE # 666
012C D7400000 R    EXTP      #PAG (xcp),#01H
0130 F78E1200 R    MOVB      POF (xcp+012H),ZEROS
C166 COMPILER V7.57.0, XCPBASIC                                                            01/03/2020 16:20:10 PAGE 68  

                                           ; SOURCE LINE # 667
0134         ?C0017:
                                           ; SOURCE LINE # 669
0134 DA000000 E    CALLS     SEG (ApplXcpInterruptEnable),ApplXcpInterruptEnable
                                           ; SOURCE LINE # 680
0138 DB00          RETS      
             ; FUNCTION XcpSendEv (END    RMASK = @0x7FFF)

             ; FUNCTION XcpSendDto (BEGIN  RMASK = @0x7FFF)
                                           ; SOURCE LINE # 696
013A F079          MOV       R7,R9
;---- Variable 'dto' assigned to Register 'R6/R7' ----
                                           ; SOURCE LINE # 698
013C F0A9          MOV       R10,R9
013E F098          MOV       R9,R8
0140 DC47          EXTP      R7,#01H
0142 F4880800      MOVB      RL4,[R8+#POF(08H)]
0146 C088          MOVBZ     R8,RL4
0148 DA000000 E    CALLS     SEG (XcpCanSend),XcpCanSend
                                           ; SOURCE LINE # 699
014C DB00          RETS      
             ; FUNCTION XcpSendDto (END    RMASK = @0x7FFF)

             ; FUNCTION XcpSendDtoFromQueue (BEGIN  RMASK = @0x7FFF)
                                           ; SOURCE LINE # 714
                                           ; SOURCE LINE # 716
014E DA000000 E    CALLS     SEG (ApplXcpInterruptDisable),ApplXcpInterruptDisable
                                           ; SOURCE LINE # 717
0152 D7400000 R    EXTP      #PAG (xcp),#01H
0156 F3F83E08 R    MOVB      RL4,POF (xcp+083EH)
015A 67F87000      ANDB      RL4,#070H
015E 3D3B          JMPR      cc_NZ,?C0018
0160 D7400000 R    EXTP      #PAG (xcp),#01H
0164 F2F43A08 R    MOV       R4,POF (xcp+083AH)
0168 2D36          JMPR      cc_Z,?C0018
                                           ; SOURCE LINE # 719
016A D7400000 R    EXTP      #PAG (xcp),#01H
016E F3F83E08 R    MOVB      RL4,POF (xcp+083EH)
0172 77F82000      ORB       RL4,#020H
0176 D7500000 R    EXTP      #PAG (xcp),#02H
017A F7F83E08 R    MOVB      POF (xcp+083EH),RL4
                                           ; SOURCE LINE # 720
017E F2F53C08 R    MOV       R5,POF (xcp+083CH)
0182 F045          MOV       R4,R5
0184 5C34          SHL       R4,#03H
0186 0045          ADD       R4,R5
0188 D7500000 R    EXTP      #PAG (xcp),#02H
018C F2F93608 R    MOV       R9,POF (xcp+0836H)
0190 F2F83408 R    MOV       R8,POF (xcp+0834H)
0194 0084          ADD       R8,R4
0196 DA000000 R    CALLS     SEG (XcpSendDto),XcpSendDto
                                           ; SOURCE LINE # 721
019A D7400000 R    EXTP      #PAG (xcp),#01H
019E F2F43C08 R    MOV       R4,POF (xcp+083CH)
01A2 0841          ADD       R4,#01H
01A4 D7500000 R    EXTP      #PAG (xcp),#02H
01A8 F6F43C08 R    MOV       POF (xcp+083CH),R4
                                           ; SOURCE LINE # 722
01AC F2F53808 R    MOV       R5,POF (xcp+0838H)
01B0 4045          CMP       R4,R5
01B2 8D04          JMPR      cc_ULT,?C0019
                                           ; SOURCE LINE # 724
C166 COMPILER V7.57.0, XCPBASIC                                                            01/03/2020 16:20:10 PAGE 69  

01B4 D7400000 R    EXTP      #PAG (xcp),#01H
01B8 F68E3C08 R    MOV       POF (xcp+083CH),ZEROS
                                           ; SOURCE LINE # 725
01BC         ?C0019:
                                           ; SOURCE LINE # 726
01BC D7400000 R    EXTP      #PAG (xcp),#01H
01C0 F2F43A08 R    MOV       R4,POF (xcp+083AH)
01C4 2841          SUB       R4,#01H
01C6 D7400000 R    EXTP      #PAG (xcp),#01H
01CA F6F43A08 R    MOV       POF (xcp+083AH),R4
                                           ; SOURCE LINE # 727
01CE DA000000 E    CALLS     SEG (ApplXcpInterruptEnable),ApplXcpInterruptEnable
                                           ; SOURCE LINE # 728
01D2 E118          MOVB      RL4,#01H
01D4 DB00          RETS      
                                           ; SOURCE LINE # 729
01D6         ?C0018:
                                           ; SOURCE LINE # 730
01D6 DA000000 E    CALLS     SEG (ApplXcpInterruptEnable),ApplXcpInterruptEnable
                                           ; SOURCE LINE # 731
01DA E108          MOVB      RL4,#00H
                                           ; SOURCE LINE # 733
01DC         ?C0020:
01DC DB00          RETS      
             ; FUNCTION XcpSendDtoFromQueue (END    RMASK = @0x7FFF)

             ; FUNCTION XcpQueueInit (BEGIN  RMASK = @0x8000)
                                           ; SOURCE LINE # 751
                                           ; SOURCE LINE # 753
01DE D7500000 R    EXTP      #PAG (xcp),#02H
01E2 F68E3A08 R    MOV       POF (xcp+083AH),ZEROS
                                           ; SOURCE LINE # 754
01E6 F68E3C08 R    MOV       POF (xcp+083CH),ZEROS
                                           ; SOURCE LINE # 755
01EA DB00          RETS      
             ; FUNCTION XcpQueueInit (END    RMASK = @0x8000)

             ; FUNCTION XcpWriteMta (BEGIN  RMASK = @0x4370)
                                           ; SOURCE LINE # 780
;---- Variable 'data' assigned to Register 'R9/R10' ----
;---- Variable 'size' assigned to Register 'R8' ----
                                           ; SOURCE LINE # 798
01EC 0D11          JMPR      cc_UC,?C0021
01EE         ?C0023:
                                           ; SOURCE LINE # 800
01EE DC4A          EXTP      R10,#01H
01F0 A9C9          MOVB      RL6,[R9]
01F2 D7500000 R    EXTP      #PAG (xcp),#02H
01F6 F2F51800 R    MOV       R5,POF (xcp+018H)
01FA F2F41600 R    MOV       R4,POF (xcp+016H)
01FE DC45          EXTP      R5,#01H
0200 B9C4          MOVB      [R4],RL6
                                           ; SOURCE LINE # 801
0202 0841          ADD       R4,#01H
0204 D7400000 R    EXTP      #PAG (xcp),#01H
0208 F6F41600 R    MOV       POF (xcp+016H),R4
                                           ; SOURCE LINE # 802
020C 0891          ADD       R9,#01H
                                           ; SOURCE LINE # 803
020E 2881          SUB       R8,#01H
                                           ; SOURCE LINE # 804
0210         ?C0021:
C166 COMPILER V7.57.0, XCPBASIC                                                            01/03/2020 16:20:10 PAGE 70  

0210 F048          MOV       R4,R8
0212 4980          CMPB      RL4,#00H
0214 EDEC          JMPR      cc_UGT,?C0023
0216         ?C0022:
                                           ; SOURCE LINE # 805
0216 E118          MOVB      RL4,#01H
                                           ; SOURCE LINE # 808
0218 DB00          RETS      
             ; FUNCTION XcpWriteMta (END    RMASK = @0x4370)

             ; FUNCTION XcpReadMta (BEGIN  RMASK = @0x4370)
                                           ; SOURCE LINE # 820
;---- Variable 'data' assigned to Register 'R9/R10' ----
;---- Variable 'size' assigned to Register 'R8' ----
                                           ; SOURCE LINE # 838
021A 0D15          JMPR      cc_UC,?C0026
021C         ?C0028:
                                           ; SOURCE LINE # 844
021C D7500000 R    EXTP      #PAG (xcp),#02H
0220 F2F51800 R    MOV       R5,POF (xcp+018H)
0224 F2F41600 R    MOV       R4,POF (xcp+016H)
0228 DC45          EXTP      R5,#01H
022A A9C4          MOVB      RL6,[R4]
022C DC4A          EXTP      R10,#01H
022E B9C9          MOVB      [R9],RL6
                                           ; SOURCE LINE # 845
0230 0891          ADD       R9,#01H
                                           ; SOURCE LINE # 846
0232 D7400000 R    EXTP      #PAG (xcp),#01H
0236 F2F41600 R    MOV       R4,POF (xcp+016H)
023A 0841          ADD       R4,#01H
023C D7400000 R    EXTP      #PAG (xcp),#01H
0240 F6F41600 R    MOV       POF (xcp+016H),R4
                                           ; SOURCE LINE # 847
0244 2881          SUB       R8,#01H
                                           ; SOURCE LINE # 848
0246         ?C0026:
0246 F048          MOV       R4,R8
0248 4980          CMPB      RL4,#00H
024A EDE8          JMPR      cc_UGT,?C0028
024C         ?C0027:
                                           ; SOURCE LINE # 849
024C E118          MOVB      RL4,#01H
                                           ; SOURCE LINE # 852
024E DB00          RETS      
             ; FUNCTION XcpReadMta (END    RMASK = @0x4370)

             ; FUNCTION XcpFreeDaq (BEGIN  RMASK = @0x0FD0)
                                           ; SOURCE LINE # 870
                                           ; SOURCE LINE # 872
0250 D7400000 R    EXTP      #PAG (xcp),#01H
0254 F2F41400 R    MOV       R4,POF (xcp+014H)
0258 66F4BF00      AND       R4,#0BFH
025C D7700000 R    EXTP      #PAG (xcp),#04H
0260 F6F41400 R    MOV       POF (xcp+014H),R4
                                           ; SOURCE LINE # 874
0264 F78E2300 R    MOVB      POF (xcp+023H),ZEROS
                                           ; SOURCE LINE # 875
0268 F78E2400 R    MOVB      POF (xcp+024H),ZEROS
                                           ; SOURCE LINE # 876
026C F68E2600 R    MOV       POF (xcp+026H),ZEROS
                                           ; SOURCE LINE # 878
C166 COMPILER V7.57.0, XCPBASIC                                                            01/03/2020 16:20:10 PAGE 71  

0270 E004          MOV       R4,#00H
0272 D7700000 R    EXTP      #PAG (xcp),#04H
0276 F6F42808 R    MOV       POF (xcp+0828H),R4
027A F6F42A08 R    MOV       POF (xcp+082AH),R4
                                           ; SOURCE LINE # 879
027E F6F42C08 R    MOV       POF (xcp+082CH),R4
0282 F6F42E08 R    MOV       POF (xcp+082EH),R4
                                           ; SOURCE LINE # 880
0286 D7500000 R    EXTP      #PAG (xcp),#02H
028A F6F43008 R    MOV       POF (xcp+0830H),R4
028E F6F43208 R    MOV       POF (xcp+0832H),R4
                                           ; SOURCE LINE # 882
0292 E6FA0008      MOV       R10,#0800H
0296 E6F82800 R    MOV       R8,#POF (xcp+028H)
029A E6F90000 R    MOV       R9,#PAG (xcp)
029E DA000000 R    CALLS     SEG (XcpMemClr),XcpMemClr
                                           ; SOURCE LINE # 888
02A2 DA000000 R    CALLS     SEG (XcpQueueInit),XcpQueueInit
                                           ; SOURCE LINE # 890
02A6 DB00          RETS      
             ; FUNCTION XcpFreeDaq (END    RMASK = @0x0FD0)

             ; FUNCTION XcpAllocMemory (BEGIN  RMASK = @0x60F0)
                                           ; SOURCE LINE # 901
                                           ; SOURCE LINE # 902
                                           ; SOURCE LINE # 913
02A8 D7400000 R    EXTP      #PAG (xcp),#01H
02AC C2F72400 R    MOVBZ     R7,POF (xcp+024H)
02B0 5C27          SHL       R7,#02H
02B2 D7400000 R    EXTP      #PAG (xcp),#01H
02B6 C2F62300 R    MOVBZ     R6,POF (xcp+023H)
02BA E065          MOV       R5,#06H
02BC 1B65          MULU      R6,R5
02BE 02F70EFE      ADD       R7,MDL
02C2 D7400000 R    EXTP      #PAG (xcp),#01H
02C6 F2F62600 R    MOV       R6,POF (xcp+026H)
02CA E055          MOV       R5,#05H
02CC 1B65          MULU      R6,R5
02CE 02F70EFE      ADD       R7,MDL
;---- Variable 's' assigned to Register 'R7' ----
                                           ; SOURCE LINE # 918
02D2 06F70900      ADD       R7,#09H
                                           ; SOURCE LINE # 922
02D6 46F70008      CMP       R7,#0800H
02DA 8D03          JMPR      cc_ULT,?C0031
                                           ; SOURCE LINE # 924
02DC E7F83000      MOVB      RL4,#030H
02E0 DB00          RETS      
                                           ; SOURCE LINE # 925
02E2         ?C0031:
                                           ; SOURCE LINE # 940
02E2 D7400000 R    EXTP      #PAG (xcp),#01H
02E6 C2F52300 R    MOVBZ     R5,POF (xcp+023H)
02EA F065          MOV       R6,R5
02EC 5C26          SHL       R6,#02H
02EE 2065          SUB       R6,R5
02F0 5C16          SHL       R6,#01H
02F2 E6F42800 R    MOV       R4,#POF (xcp+028H)
02F6 E6F50000 R    MOV       R5,#PAG (xcp)
02FA 0046          ADD       R4,R6
02FC 4AF5F40E      BMOV      R4.14,R5.0
0300 4AF5F41F      BMOV      R4.15,R5.1
C166 COMPILER V7.57.0, XCPBASIC                                                            01/03/2020 16:20:10 PAGE 72  

0304 7C25          SHR       R5,#02H
0306 0843          ADD       R4,#03H
0308 1850          ADDC      R5,#00H
030A 66F4FCFF      AND       R4,#0FFFCH
030E 0044          ADD       R4,R4
0310 1055          ADDC      R5,R5
0312 0044          ADD       R4,R4
0314 1055          ADDC      R5,R5
0316 7C24          SHR       R4,#02H
0318 D7600000 R    EXTP      #PAG (xcp),#03H
031C F6F42808 R    MOV       POF (xcp+0828H),R4
0320 F6F52A08 R    MOV       POF (xcp+082AH),R5
                                           ; SOURCE LINE # 957
0324 C2F62400 R    MOVBZ     R6,POF (xcp+024H)
0328 5C26          SHL       R6,#02H
032A 0046          ADD       R4,R6
032C 4AF5F40E      BMOV      R4.14,R5.0
0330 4AF5F41F      BMOV      R4.15,R5.1
0334 7C25          SHR       R5,#02H
0336 0843          ADD       R4,#03H
0338 1850          ADDC      R5,#00H
033A 66F4FCFF      AND       R4,#0FFFCH
033E 0044          ADD       R4,R4
0340 1055          ADDC      R5,R5
0342 0044          ADD       R4,R4
0344 1055          ADDC      R5,R5
0346 7C24          SHR       R4,#02H
0348 D7600000 R    EXTP      #PAG (xcp),#03H
034C F6F42C08 R    MOV       POF (xcp+082CH),R4
0350 F6F52E08 R    MOV       POF (xcp+082EH),R5
                                           ; SOURCE LINE # 962
0354 F2F62600 R    MOV       R6,POF (xcp+026H)
0358 5C26          SHL       R6,#02H
035A 0046          ADD       R4,R6
035C D7600000 R    EXTP      #PAG (xcp),#03H
0360 F6F43008 R    MOV       POF (xcp+0830H),R4
0364 F6F53208 R    MOV       POF (xcp+0832H),R5
                                           ; SOURCE LINE # 978
0368 F2F62600 R    MOV       R6,POF (xcp+026H)
036C 0046          ADD       R4,R6
036E 4AF5F40E      BMOV      R4.14,R5.0
0372 4AF5F41F      BMOV      R4.15,R5.1
0376 7C25          SHR       R5,#02H
0378 0843          ADD       R4,#03H
037A 1850          ADDC      R5,#00H
037C 66F4FCFF      AND       R4,#0FFFCH
0380 0044          ADD       R4,R4
0382 1055          ADDC      R5,R5
0384 0044          ADD       R4,R4
0386 1055          ADDC      R5,R5
0388 7C24          SHR       R4,#02H
038A D7500000 R    EXTP      #PAG (xcp),#02H
038E F6F43408 R    MOV       POF (xcp+0834H),R4
0392 F6F53608 R    MOV       POF (xcp+0836H),R5
                                           ; SOURCE LINE # 985
0396 E6F50008      MOV       R5,#0800H
039A 2057          SUB       R5,R7
039C E094          MOV       R4,#09H
039E F6F50EFE      MOV       MDL,R5
03A2 5B44          DIVU      R4
03A4 F2F40EFE      MOV       R4,MDL
03A8 D7500000 R    EXTP      #PAG (xcp),#02H
C166 COMPILER V7.57.0, XCPBASIC                                                            01/03/2020 16:20:10 PAGE 73  

03AC F6F43808 R    MOV       POF (xcp+0838H),R4
                                           ; SOURCE LINE # 994
03B0 C2F52400 R    MOVBZ     R5,POF (xcp+024H)
03B4 4045          CMP       R4,R5
03B6 9D03          JMPR      cc_UGE,?C0033
                                           ; SOURCE LINE # 996
03B8 E7F83000      MOVB      RL4,#030H
03BC DB00          RETS      
                                           ; SOURCE LINE # 997
03BE         ?C0033:
                                           ; SOURCE LINE # 1011
03BE E108          MOVB      RL4,#00H
                                           ; SOURCE LINE # 1013
03C0         ?C0032:
03C0 DB00          RETS      
             ; FUNCTION XcpAllocMemory (END    RMASK = @0x60F0)

             ; FUNCTION XcpAllocDaq (BEGIN  RMASK = @0x60F0)
                                           ; SOURCE LINE # 1025
;---- Variable 'daqCount' assigned to Register 'R8' ----
                                           ; SOURCE LINE # 1038
03C2 F048          MOV       R4,R8
03C4 D7400000 R    EXTP      #PAG (xcp),#01H
03C8 F7F82300 R    MOVB      POF (xcp+023H),RL4
                                           ; SOURCE LINE # 1040
03CC DA000000 R    CALLS     SEG (XcpAllocMemory),XcpAllocMemory
                                           ; SOURCE LINE # 1042
03D0 DB00          RETS      
             ; FUNCTION XcpAllocDaq (END    RMASK = @0x60F0)

             ; FUNCTION XcpAllocOdt (BEGIN  RMASK = @0x60F0)
                                           ; SOURCE LINE # 1054
;---- Variable 'odtCount' assigned to Register 'R9' ----
;---- Variable 'daq' assigned to Register 'R8' ----
                                           ; SOURCE LINE # 1070
03D2 F049          MOV       R4,R9
03D4 C085          MOVBZ     R5,RL4
03D6 D7400000 R    EXTP      #PAG (xcp),#01H
03DA C2F42400 R    MOVBZ     R4,POF (xcp+024H)
03DE 0045          ADD       R4,R5
03E0 46F47B00      CMP       R4,#07BH
03E4 FD03          JMPR      cc_ULE,?C0035
                                           ; SOURCE LINE # 1075
03E6 E7F83000      MOVB      RL4,#030H
03EA DB00          RETS      
                                           ; SOURCE LINE # 1076
03EC         ?C0035:
                                           ; SOURCE LINE # 1079
03EC D7400000 R    EXTP      #PAG (xcp),#01H
03F0 F3FC2400 R    MOVB      RL6,POF (xcp+024H)
03F4 F048          MOV       R4,R8
03F6 C087          MOVBZ     R7,RL4
03F8 F057          MOV       R5,R7
03FA 5C25          SHL       R5,#02H
03FC 2057          SUB       R5,R7
03FE 5C15          SHL       R5,#01H
0400 D7500000 R    EXTP      #PAG (xcp),#02H
0404 E4C52900 R    MOVB      [R5+#POF(xcp+029H)],RL6
                                           ; SOURCE LINE # 1080
0408 F3F82400 R    MOVB      RL4,POF (xcp+024H)
040C 0049          ADD       R4,R9
040E D7500000 R    EXTP      #PAG (xcp),#02H
C166 COMPILER V7.57.0, XCPBASIC                                                            01/03/2020 16:20:10 PAGE 74  

0412 F7F82400 R    MOVB      POF (xcp+024H),RL4
                                           ; SOURCE LINE # 1081
0416 C2F42400 R    MOVBZ     R4,POF (xcp+024H)
041A 2841          SUB       R4,#01H
041C F1C8          MOVB      RL6,RL4
041E D7400000 R    EXTP      #PAG (xcp),#01H
0422 E4C52800 R    MOVB      [R5+#POF(xcp+028H)],RL6
                                           ; SOURCE LINE # 1083
0426 DA000000 R    CALLS     SEG (XcpAllocMemory),XcpAllocMemory
                                           ; SOURCE LINE # 1085
042A         ?C0036:
042A DB00          RETS      
             ; FUNCTION XcpAllocOdt (END    RMASK = @0x60F0)

             ; FUNCTION XcpAllocOdtEntry (BEGIN  RMASK = @0x68F2)
                                           ; SOURCE LINE # 1098
;---- Variable 'odtEntryCount' assigned to Register 'R10' ----
;---- Variable 'odt' assigned to Register 'R9' ----
;---- Variable 'daq' assigned to Register 'R8' ----
                                           ; SOURCE LINE # 1099
                                           ; SOURCE LINE # 1114
042C F04A          MOV       R4,R10
042E C084          MOVBZ     R4,RL4
0430 E6F5FFFF      MOV       R5,#0FFFFH
0434 2054          SUB       R5,R4
0436 D7400000 R    EXTP      #PAG (xcp),#01H
043A F2FB2600 R    MOV       R11,POF (xcp+026H)
043E 40B5          CMP       R11,R5
0440 FD03          JMPR      cc_ULE,?C0037
                                           ; SOURCE LINE # 1116
0442 E7F83000      MOVB      RL4,#030H
0446 DB00          RETS      
                                           ; SOURCE LINE # 1117
0448         ?C0037:
                                           ; SOURCE LINE # 1118
0448 F048          MOV       R4,R8
044A C085          MOVBZ     R5,RL4
044C F045          MOV       R4,R5
044E 5C24          SHL       R4,#02H
0450 2045          SUB       R4,R5
0452 5C14          SHL       R4,#01H
0454 D7400000 R    EXTP      #PAG (xcp),#01H
0458 F4242900 R    MOVB      RL1,[R4+#POF(xcp+029H)]
;---- Variable 'xcpFirstOdt' assigned to Register 'RL1' ----
                                           ; SOURCE LINE # 1119
045C F049          MOV       R4,R9
045E C085          MOVBZ     R5,RL4
0460 C026          MOVBZ     R6,RL1
0462 0065          ADD       R6,R5
0464 5C26          SHL       R6,#02H
0466 D7500000 R    EXTP      #PAG (xcp),#02H
046A F2F52A08 R    MOV       R5,POF (xcp+082AH)
046E F2F42808 R    MOV       R4,POF (xcp+0828H)
0472 0046          ADD       R4,R6
0474 DC45          EXTP      R5,#01H
0476 B8B4          MOV       [R4],R11
                                           ; SOURCE LINE # 1120
0478 F04A          MOV       R4,R10
047A C085          MOVBZ     R5,RL4
047C D7400000 R    EXTP      #PAG (xcp),#01H
0480 F2F42600 R    MOV       R4,POF (xcp+026H)
0484 0045          ADD       R4,R5
C166 COMPILER V7.57.0, XCPBASIC                                                            01/03/2020 16:20:10 PAGE 75  

0486 D7400000 R    EXTP      #PAG (xcp),#01H
048A F6F42600 R    MOV       POF (xcp+026H),R4
                                           ; SOURCE LINE # 1121
048E F074          MOV       R7,R4
0490 2871          SUB       R7,#01H
0492 F049          MOV       R4,R9
0494 C085          MOVBZ     R5,RL4
0496 C026          MOVBZ     R6,RL1
0498 0065          ADD       R6,R5
049A 5C26          SHL       R6,#02H
049C D7500000 R    EXTP      #PAG (xcp),#02H
04A0 F2F52A08 R    MOV       R5,POF (xcp+082AH)
04A4 F2F42808 R    MOV       R4,POF (xcp+0828H)
04A8 0046          ADD       R4,R6
04AA DC45          EXTP      R5,#01H
04AC C4740200      MOV       [R4+#POF(02H)],R7
                                           ; SOURCE LINE # 1123
04B0 DA000000 R    CALLS     SEG (XcpAllocMemory),XcpAllocMemory
                                           ; SOURCE LINE # 1125
04B4         ?C0038:
04B4 DB00          RETS      
             ; FUNCTION XcpAllocOdtEntry (END    RMASK = @0x68F2)

             ; FUNCTION XcpStartDaq (BEGIN  RMASK = @0x42D0)
                                           ; SOURCE LINE # 1135
;---- Variable 'daq' assigned to Register 'R8' ----
                                           ; SOURCE LINE # 1138
04B6 F048          MOV       R4,R8
04B8 C087          MOVBZ     R7,RL4
04BA F097          MOV       R9,R7
04BC 5C29          SHL       R9,#02H
04BE 2097          SUB       R9,R7
04C0 5C19          SHL       R9,#01H
04C2 D7400000 R    EXTP      #PAG (xcp),#01H
04C6 F4892A00 R    MOVB      RL4,[R9+#POF(xcp+02AH)]
04CA 77F84000      ORB       RL4,#040H
04CE D7400000 R    EXTP      #PAG (xcp),#01H
04D2 E4892A00 R    MOVB      [R9+#POF(xcp+02AH)],RL4
                                           ; SOURCE LINE # 1140
04D6 E11C          MOVB      RL6,#01H
04D8 D7500000 R    EXTP      #PAG (xcp),#02H
04DC E4C92D00 R    MOVB      [R9+#POF(xcp+02DH)],RL6
                                           ; SOURCE LINE # 1143
04E0 F2F41400 R    MOV       R4,POF (xcp+014H)
04E4 6FF4          BSET      R4.6
04E6 D7400000 R    EXTP      #PAG (xcp),#01H
04EA F6F41400 R    MOV       POF (xcp+014H),R4
                                           ; SOURCE LINE # 1144
04EE DB00          RETS      
             ; FUNCTION XcpStartDaq (END    RMASK = @0x42D0)

             ; FUNCTION XcpStartAllSelectedDaq (BEGIN  RMASK = @0x43F2)
                                           ; SOURCE LINE # 1154
                                           ; SOURCE LINE # 1155
                                           ; SOURCE LINE # 1159
04F0 E102          MOVB      RL1,#00H
;---- Variable 'daq' assigned to Register 'RL1' ----
04F2 0D1E          JMPR      cc_UC,?C0041
04F4         ?C0042:
                                           ; SOURCE LINE # 1161
04F4 C025          MOVBZ     R5,RL1
04F6 F045          MOV       R4,R5
C166 COMPILER V7.57.0, XCPBASIC                                                            01/03/2020 16:20:10 PAGE 76  

04F8 5C24          SHL       R4,#02H
04FA 2045          SUB       R4,R5
04FC 5C14          SHL       R4,#01H
04FE D7400000 R    EXTP      #PAG (xcp),#01H
0502 F4842A00 R    MOVB      RL4,[R4+#POF(xcp+02AH)]
0506 9AF41200      JNB       R4.0,?C0039
                                           ; SOURCE LINE # 1163
050A C028          MOVBZ     R8,RL1
050C DA000000 R    CALLS     SEG (XcpStartDaq),XcpStartDaq
                                           ; SOURCE LINE # 1164
0510 C025          MOVBZ     R5,RL1
0512 F045          MOV       R4,R5
0514 5C25          SHL       R5,#02H
0516 2054          SUB       R5,R4
0518 5C15          SHL       R5,#01H
051A D7400000 R    EXTP      #PAG (xcp),#01H
051E F4852A00 R    MOVB      RL4,[R5+#POF(xcp+02AH)]
0522 67F8FE00      ANDB      RL4,#0FEH
0526 D7400000 R    EXTP      #PAG (xcp),#01H
052A E4852A00 R    MOVB      [R5+#POF(xcp+02AH)],RL4
                                           ; SOURCE LINE # 1165
052E         ?C0039:
052E 0921          ADDB      RL1,#01H
0530         ?C0041:
0530 D7400000 R    EXTP      #PAG (xcp),#01H
0534 F3FA2300 R    MOVB      RL5,POF (xcp+023H)
0538 41A2          CMPB      RL5,RL1
053A EDDC          JMPR      cc_UGT,?C0042
053C         ?C0040:
                                           ; SOURCE LINE # 1167
053C DB00          RETS      
             ; FUNCTION XcpStartAllSelectedDaq (END    RMASK = @0x43F2)

             ; FUNCTION XcpStopDaq (BEGIN  RMASK = @0x4070)
                                           ; SOURCE LINE # 1177
;---- Variable 'daq' assigned to Register 'R8' ----
                                           ; SOURCE LINE # 1178
                                           ; SOURCE LINE # 1181
053E F048          MOV       R4,R8
0540 C085          MOVBZ     R5,RL4
0542 F045          MOV       R4,R5
0544 5C25          SHL       R5,#02H
0546 2054          SUB       R5,R4
0548 5C15          SHL       R5,#01H
054A D7400000 R    EXTP      #PAG (xcp),#01H
054E F4852A00 R    MOVB      RL4,[R5+#POF(xcp+02AH)]
0552 67F83200      ANDB      RL4,#032H
0556 D7400000 R    EXTP      #PAG (xcp),#01H
055A E4852A00 R    MOVB      [R5+#POF(xcp+02AH)],RL4
                                           ; SOURCE LINE # 1184
055E E10C          MOVB      RL6,#00H
;---- Variable 'i' assigned to Register 'RL6' ----
0560 0D0C          JMPR      cc_UC,?C0047
0562         ?C0048:
                                           ; SOURCE LINE # 1186
0562 C0C5          MOVBZ     R5,RL6
0564 F045          MOV       R4,R5
0566 5C24          SHL       R4,#02H
0568 2045          SUB       R4,R5
056A 5C14          SHL       R4,#01H
056C D7400000 R    EXTP      #PAG (xcp),#01H
0570 F4842A00 R    MOVB      RL4,[R4+#POF(xcp+02AH)]
C166 COMPILER V7.57.0, XCPBASIC                                                            01/03/2020 16:20:10 PAGE 77  

0574 8AF41360      JB        R4.6,?C0051
                                           ; SOURCE LINE # 1188
                                           ; SOURCE LINE # 1189
0578 09C1          ADDB      RL6,#01H
057A         ?C0047:
057A D7400000 R    EXTP      #PAG (xcp),#01H
057E F3FA2300 R    MOVB      RL5,POF (xcp+023H)
0582 41AC          CMPB      RL5,RL6
0584 EDEE          JMPR      cc_UGT,?C0048
0586         ?C0046:
                                           ; SOURCE LINE # 1192
0586 D7400000 R    EXTP      #PAG (xcp),#01H
058A F2F41400 R    MOV       R4,POF (xcp+014H)
058E 66F4BF00      AND       R4,#0BFH
0592 D7400000 R    EXTP      #PAG (xcp),#01H
0596 F6F41400 R    MOV       POF (xcp+014H),R4
                                           ; SOURCE LINE # 1195
059A DA000000 R    CALLS     SEG (XcpQueueInit),XcpQueueInit
                                           ; SOURCE LINE # 1198
059E         ?C0051:
059E DB00          RETS      
             ; FUNCTION XcpStopDaq (END    RMASK = @0x4070)

             ; FUNCTION XcpStopAllSelectedDaq (BEGIN  RMASK = @0x41F0)
                                           ; SOURCE LINE # 1208
                                           ; SOURCE LINE # 1209
                                           ; SOURCE LINE # 1212
05A0 E10E          MOVB      RL7,#00H
;---- Variable 'daq' assigned to Register 'RL7' ----
05A2 0D1E          JMPR      cc_UC,?C0054
05A4         ?C0055:
                                           ; SOURCE LINE # 1214
05A4 C0E5          MOVBZ     R5,RL7
05A6 F045          MOV       R4,R5
05A8 5C24          SHL       R4,#02H
05AA 2045          SUB       R4,R5
05AC 5C14          SHL       R4,#01H
05AE D7400000 R    EXTP      #PAG (xcp),#01H
05B2 F4842A00 R    MOVB      RL4,[R4+#POF(xcp+02AH)]
05B6 9AF41200      JNB       R4.0,?C0052
                                           ; SOURCE LINE # 1216
05BA C0E8          MOVBZ     R8,RL7
05BC DA000000 R    CALLS     SEG (XcpStopDaq),XcpStopDaq
                                           ; SOURCE LINE # 1217
05C0 C0E5          MOVBZ     R5,RL7
05C2 F045          MOV       R4,R5
05C4 5C25          SHL       R5,#02H
05C6 2054          SUB       R5,R4
05C8 5C15          SHL       R5,#01H
05CA D7400000 R    EXTP      #PAG (xcp),#01H
05CE F4852A00 R    MOVB      RL4,[R5+#POF(xcp+02AH)]
05D2 67F8FE00      ANDB      RL4,#0FEH
05D6 D7400000 R    EXTP      #PAG (xcp),#01H
05DA E4852A00 R    MOVB      [R5+#POF(xcp+02AH)],RL4
                                           ; SOURCE LINE # 1218
05DE         ?C0052:
05DE 09E1          ADDB      RL7,#01H
05E0         ?C0054:
05E0 D7400000 R    EXTP      #PAG (xcp),#01H
05E4 F3FA2300 R    MOVB      RL5,POF (xcp+023H)
05E8 41AE          CMPB      RL5,RL7
05EA EDDC          JMPR      cc_UGT,?C0055
C166 COMPILER V7.57.0, XCPBASIC                                                            01/03/2020 16:20:10 PAGE 78  

05EC         ?C0053:
                                           ; SOURCE LINE # 1220
05EC DB00          RETS      
             ; FUNCTION XcpStopAllSelectedDaq (END    RMASK = @0x41F0)

             ; FUNCTION XcpStopAllDaq (BEGIN  RMASK = @0x4070)
                                           ; SOURCE LINE # 1230
                                           ; SOURCE LINE # 1231
                                           ; SOURCE LINE # 1234
05EE E10C          MOVB      RL6,#00H
;---- Variable 'daq' assigned to Register 'RL6' ----
05F0 0D10          JMPR      cc_UC,?C0060
05F2         ?C0061:
                                           ; SOURCE LINE # 1236
05F2 C0C5          MOVBZ     R5,RL6
05F4 F045          MOV       R4,R5
05F6 5C25          SHL       R5,#02H
05F8 2054          SUB       R5,R4
05FA 5C15          SHL       R5,#01H
05FC D7400000 R    EXTP      #PAG (xcp),#01H
0600 F4852A00 R    MOVB      RL4,[R5+#POF(xcp+02AH)]
0604 67F83200      ANDB      RL4,#032H
0608 D7400000 R    EXTP      #PAG (xcp),#01H
060C E4852A00 R    MOVB      [R5+#POF(xcp+02AH)],RL4
                                           ; SOURCE LINE # 1237
0610 09C1          ADDB      RL6,#01H
0612         ?C0060:
0612 D7400000 R    EXTP      #PAG (xcp),#01H
0616 F3FA2300 R    MOVB      RL5,POF (xcp+023H)
061A 41AC          CMPB      RL5,RL6
061C EDEA          JMPR      cc_UGT,?C0061
061E         ?C0059:
                                           ; SOURCE LINE # 1239
061E D7400000 R    EXTP      #PAG (xcp),#01H
0622 F2F41400 R    MOV       R4,POF (xcp+014H)
0626 66F4BF00      AND       R4,#0BFH
062A D7400000 R    EXTP      #PAG (xcp),#01H
062E F6F41400 R    MOV       POF (xcp+014H),R4
                                           ; SOURCE LINE # 1242
0632 DA000000 R    CALLS     SEG (XcpQueueInit),XcpQueueInit
                                           ; SOURCE LINE # 1244
0636 DB00          RETS      
             ; FUNCTION XcpStopAllDaq (END    RMASK = @0x4070)

             ; FUNCTION XcpEvent (BEGIN  RMASK = @0x7FFF)
                                           ; SOURCE LINE # 1269
0638 ECFD          PUSH      R13
063A ECFE          PUSH      R14
063C ECFF          PUSH      R15
063E F0D8          MOV       R13,R8
;---- Variable 'event' assigned to Register 'R13' ----
0640 06F0EAFF      ADD       R0,#0FFEAH
                                           ; SOURCE LINE # 1270
                                           ; SOURCE LINE # 1287
0644 E108          MOVB      RL4,#00H
0646 E4800800      MOVB      [R0+#08H],RL4 ; status
                                           ; SOURCE LINE # 1289
064A D7400000 R    EXTP      #PAG (xcp),#01H
064E F2F41400 R    MOV       R4,POF (xcp+014H)
0652 8AF40360      JB        R4.6,?C0069
                                           ; SOURCE LINE # 1291
0656 E108          MOVB      RL4,#00H
C166 COMPILER V7.57.0, XCPBASIC                                                            01/03/2020 16:20:10 PAGE 79  

0658 EA00F409 R    JMPA      cc_UC,?C0064
                                           ; SOURCE LINE # 1292
                                           ; SOURCE LINE # 1314
065C         ?C0069:
065C E00E          MOV       R14,#00H
;---- Variable 'daq' assigned to Register 'R14' ----
065E EA00E009 R    JMPA      cc_UC,?C0067
0662         ?C0068:
                                           ; SOURCE LINE # 1316
0662 F04E          MOV       R4,R14
0664 C085          MOVBZ     R5,RL4
0666 F045          MOV       R4,R5
0668 5C24          SHL       R4,#02H
066A 2045          SUB       R4,R5
066C 5C14          SHL       R4,#01H
066E D7400000 R    EXTP      #PAG (xcp),#01H
0672 F4842A00 R    MOVB      RL4,[R4+#POF(xcp+02AH)]
0676 8AF40260      JB        R4.6,$+8
067A EA00DE09 R    JMPA      cc_UC,?C0065
                                           ; SOURCE LINE # 1318
                                           ; SOURCE LINE # 1319
067E         ?C0070:
                                           ; SOURCE LINE # 1320
067E F04E          MOV       R4,R14
0680 C085          MOVBZ     R5,RL4
0682 F045          MOV       R4,R5
0684 5C24          SHL       R4,#02H
0686 2045          SUB       R4,R5
0688 5C14          SHL       R4,#01H
068A D7400000 R    EXTP      #PAG (xcp),#01H
068E F4A42B00 R    MOVB      RL5,[R4+#POF(xcp+02BH)]
0692 F04D          MOV       R4,R13
0694 41A8          CMPB      RL5,RL4
0696 EA30DE09 R    JMPA      cc_NZ,?C0065
                                           ; SOURCE LINE # 1322
                                           ; SOURCE LINE # 1323
069A         ?C0071:
                                           ; SOURCE LINE # 1328
069A F04E          MOV       R4,R14
069C C085          MOVBZ     R5,RL4
069E F045          MOV       R4,R5
06A0 5C25          SHL       R5,#02H
06A2 2054          SUB       R5,R4
06A4 5C15          SHL       R5,#01H
06A6 D7400000 R    EXTP      #PAG (xcp),#01H
06AA F4852D00 R    MOVB      RL4,[R5+#POF(xcp+02DH)]
06AE 2981          SUBB      RL4,#01H
06B0 D7400000 R    EXTP      #PAG (xcp),#01H
06B4 E4852D00 R    MOVB      [R5+#POF(xcp+02DH)],RL4
                                           ; SOURCE LINE # 1329
06B8 F04E          MOV       R4,R14
06BA C085          MOVBZ     R5,RL4
06BC F045          MOV       R4,R5
06BE 5C24          SHL       R4,#02H
06C0 2045          SUB       R4,R5
06C2 5C14          SHL       R4,#01H
06C4 D7400000 R    EXTP      #PAG (xcp),#01H
06C8 F4842D00 R    MOVB      RL4,[R4+#POF(xcp+02DH)]
06CC EA30DE09 R    JMPA      cc_NZ,?C0065
                                           ; SOURCE LINE # 1331
06D0 F04E          MOV       R4,R14
06D2 C085          MOVBZ     R5,RL4
C166 COMPILER V7.57.0, XCPBASIC                                                            01/03/2020 16:20:10 PAGE 80  

06D4 F045          MOV       R4,R5
06D6 5C24          SHL       R4,#02H
06D8 2045          SUB       R4,R5
06DA 5C14          SHL       R4,#01H
06DC D7400000 R    EXTP      #PAG (xcp),#01H
06E0 F4C42C00 R    MOVB      RL6,[R4+#POF(xcp+02CH)]
06E4 F04E          MOV       R4,R14
06E6 C085          MOVBZ     R5,RL4
06E8 F045          MOV       R4,R5
06EA 5C24          SHL       R4,#02H
06EC 2045          SUB       R4,R5
06EE 5C14          SHL       R4,#01H
06F0 D7400000 R    EXTP      #PAG (xcp),#01H
06F4 E4C42D00 R    MOVB      [R4+#POF(xcp+02DH)],RL6
                                           ; SOURCE LINE # 1336
06F8 F04E          MOV       R4,R14
06FA C085          MOVBZ     R5,RL4
06FC F045          MOV       R4,R5
06FE 5C24          SHL       R4,#02H
0700 2045          SUB       R4,R5
0702 5C14          SHL       R4,#01H
0704 D7400000 R    EXTP      #PAG (xcp),#01H
0708 F4842900 R    MOVB      RL4,[R4+#POF(xcp+029H)]
070C F0F4          MOV       R15,R4
;---- Variable 'odt' assigned to Register 'R15' ----
070E EA00C209 R    JMPA      cc_UC,?C0075
0712         ?C0076:
                                           ; SOURCE LINE # 1337
                                           ; SOURCE LINE # 1341
0712 F4800800      MOVB      RL4,[R0+#08H] ; status
0716 7981          ORB       RL4,#01H
0718 E4800800      MOVB      [R0+#08H],RL4 ; status
                                           ; SOURCE LINE # 1344
071C DA000000 E    CALLS     SEG (ApplXcpInterruptDisable),ApplXcpInterruptDisable
                                           ; SOURCE LINE # 1348
0720 D7500000 R    EXTP      #PAG (xcp),#02H
0724 F2F53808 R    MOV       R5,POF (xcp+0838H)
0728 F2F43A08 R    MOV       R4,POF (xcp+083AH)
072C 4045          CMP       R4,R5
072E 8D17          JMPR      cc_ULT,?C0078
                                           ; SOURCE LINE # 1350
0730 F4800800      MOVB      RL4,[R0+#08H] ; status
0734 7982          ORB       RL4,#02H
0736 E4800800      MOVB      [R0+#08H],RL4 ; status
                                           ; SOURCE LINE # 1351
073A F04E          MOV       R4,R14
073C C085          MOVBZ     R5,RL4
073E F045          MOV       R4,R5
0740 5C25          SHL       R5,#02H
0742 2054          SUB       R5,R4
0744 5C15          SHL       R5,#01H
0746 D7400000 R    EXTP      #PAG (xcp),#01H
074A F4852A00 R    MOVB      RL4,[R5+#POF(xcp+02AH)]
074E 77F80800      ORB       RL4,#08H
0752 D7400000 R    EXTP      #PAG (xcp),#01H
0756 E4852A00 R    MOVB      [R5+#POF(xcp+02AH)],RL4
                                           ; SOURCE LINE # 1352
075A EA00BC09 R    JMPA      cc_UC,next_odt
                                           ; SOURCE LINE # 1353
075E         ?C0078:
                                           ; SOURCE LINE # 1355
075E D7500000 R    EXTP      #PAG (xcp),#02H
C166 COMPILER V7.57.0, XCPBASIC                                                            01/03/2020 16:20:10 PAGE 81  

0762 F2F53A08 R    MOV       R5,POF (xcp+083AH)
0766 F2F43C08 R    MOV       R4,POF (xcp+083CH)
076A 0045          ADD       R4,R5
076C C4401400      MOV       [R0+#014H],R4 ; qs
                                           ; SOURCE LINE # 1356
0770 D7400000 R    EXTP      #PAG (xcp),#01H
0774 F2F53808 R    MOV       R5,POF (xcp+0838H)
0778 D4401400      MOV       R4,[R0+#014H] ; qs
077C 4054          CMP       R5,R4
077E ED05          JMPR      cc_UGT,?C0080
                                           ; SOURCE LINE # 1358
0780 D4401400      MOV       R4,[R0+#014H] ; qs
0784 2045          SUB       R4,R5
0786 C4401400      MOV       [R0+#014H],R4 ; qs
                                           ; SOURCE LINE # 1359
078A         ?C0080:
                                           ; SOURCE LINE # 1361
078A D4501400      MOV       R5,[R0+#014H] ; qs
078E F065          MOV       R6,R5
0790 5C36          SHL       R6,#03H
0792 0065          ADD       R6,R5
0794 D7500000 R    EXTP      #PAG (xcp),#02H
0798 F2F53608 R    MOV       R5,POF (xcp+0836H)
079C F2F43408 R    MOV       R4,POF (xcp+0834H)
07A0 0046          ADD       R4,R6
07A2 B840          MOV       [R0],R4       ; dtop
07A4 C4500200      MOV       [R0+#02H],R5  ; dtop+2
                                           ; SOURCE LINE # 1379
07A8 F06F          MOV       R6,R15
07AA D4500200      MOV       R5,[R0+#02H]  ; dtop+2
07AE A840          MOV       R4,[R0]       ; dtop
07B0 DC45          EXTP      R5,#01H
07B2 B9C4          MOVB      [R4],RL6
                                           ; SOURCE LINE # 1380
07B4 E118          MOVB      RL4,#01H
07B6 E4801000      MOVB      [R0+#010H],RL4; i
                                           ; SOURCE LINE # 1387
07BA F04E          MOV       R4,R14
07BC C085          MOVBZ     R5,RL4
07BE F045          MOV       R4,R5
07C0 5C24          SHL       R4,#02H
07C2 2045          SUB       R4,R5
07C4 5C14          SHL       R4,#01H
07C6 D7400000 R    EXTP      #PAG (xcp),#01H
07CA F4842A00 R    MOVB      RL4,[R4+#POF(xcp+02AH)]
07CE 9AF41930      JNB       R4.3,?C0081
                                           ; SOURCE LINE # 1389
07D2 D4700200      MOV       R7,[R0+#02H]  ; dtop+2
07D6 A860          MOV       R6,[R0]       ; dtop
07D8 DC47          EXTP      R7,#01H
07DA A986          MOVB      RL4,[R6]
07DC 77F88000      ORB       RL4,#080H
07E0 DC47          EXTP      R7,#01H
07E2 B986          MOVB      [R6],RL4
                                           ; SOURCE LINE # 1390
07E4 F04E          MOV       R4,R14
07E6 C085          MOVBZ     R5,RL4
07E8 F045          MOV       R4,R5
07EA 5C25          SHL       R5,#02H
07EC 2054          SUB       R5,R4
07EE 5C15          SHL       R5,#01H
07F0 D7400000 R    EXTP      #PAG (xcp),#01H
C166 COMPILER V7.57.0, XCPBASIC                                                            01/03/2020 16:20:10 PAGE 82  

07F4 F4852A00 R    MOVB      RL4,[R5+#POF(xcp+02AH)]
07F8 67F8F700      ANDB      RL4,#0F7H
07FC D7400000 R    EXTP      #PAG (xcp),#01H
0800 E4852A00 R    MOVB      [R5+#POF(xcp+02AH)],RL4
                                           ; SOURCE LINE # 1391
0804         ?C0081:
                                           ; SOURCE LINE # 1399
0804 F04E          MOV       R4,R14
0806 C085          MOVBZ     R5,RL4
0808 F045          MOV       R4,R5
080A 5C24          SHL       R4,#02H
080C 2045          SUB       R4,R5
080E 5C14          SHL       R4,#01H
0810 D7400000 R    EXTP      #PAG (xcp),#01H
0814 F4842A00 R    MOVB      RL4,[R4+#POF(xcp+02AH)]
0818 9AF42840      JNB       R4.4,?C0082
                                           ; SOURCE LINE # 1403
081C F04E          MOV       R4,R14
081E C085          MOVBZ     R5,RL4
0820 F045          MOV       R4,R5
0822 5C24          SHL       R4,#02H
0824 2045          SUB       R4,R5
0826 5C14          SHL       R4,#01H
0828 D7400000 R    EXTP      #PAG (xcp),#01H
082C F4A42900 R    MOVB      RL5,[R4+#POF(xcp+029H)]
0830 F04F          MOV       R4,R15
0832 41A8          CMPB      RL5,RL4
0834 3D1B          JMPR      cc_NZ,?C0082
                                           ; SOURCE LINE # 1406
0836 DA000000 E    CALLS     SEG (ApplXcpGetTimestamp),ApplXcpGetTimestamp
083A C4401200      MOV       [R0+#012H],R4 ; t
                                           ; SOURCE LINE # 1430
083E D4401200      MOV       R4,[R0+#012H] ; t
0842 F1C8          MOVB      RL6,RL4
0844 D4500200      MOV       R5,[R0+#02H]  ; dtop+2
0848 A840          MOV       R4,[R0]       ; dtop
084A DC45          EXTP      R5,#01H
084C E4C40100      MOVB      [R4+#POF(01H)],RL6
                                           ; SOURCE LINE # 1432
0850 D4401200      MOV       R4,[R0+#012H] ; t
0854 7C84          SHR       R4,#08H
0856 F1C8          MOVB      RL6,RL4
0858 D4500200      MOV       R5,[R0+#02H]  ; dtop+2
085C A840          MOV       R4,[R0]       ; dtop
085E 0841          ADD       R4,#01H
0860 DC45          EXTP      R5,#01H
0862 E4C40100      MOVB      [R4+#POF(01H)],RL6
                                           ; SOURCE LINE # 1442
0866 E138          MOVB      RL4,#03H
0868 E4801000      MOVB      [R0+#010H],RL4; i
                                           ; SOURCE LINE # 1445
086C         ?C0082:
                                           ; SOURCE LINE # 1455
086C F04F          MOV       R4,R15
086E C086          MOVBZ     R6,RL4
0870 5C26          SHL       R6,#02H
0872 D7500000 R    EXTP      #PAG (xcp),#02H
0876 F2F52A08 R    MOV       R5,POF (xcp+082AH)
087A F2F42808 R    MOV       R4,POF (xcp+0828H)
087E 0046          ADD       R4,R6
0880 DC45          EXTP      R5,#01H
0882 A844          MOV       R4,[R4]
C166 COMPILER V7.57.0, XCPBASIC                                                            01/03/2020 16:20:10 PAGE 83  

0884 C4400A00      MOV       [R0+#0AH],R4  ; e
                                           ; SOURCE LINE # 1456
0888 D4600A00      MOV       R6,[R0+#0AH]  ; e
088C D7500000 R    EXTP      #PAG (xcp),#02H
0890 F2F53208 R    MOV       R5,POF (xcp+0832H)
0894 F2F43008 R    MOV       R4,POF (xcp+0830H)
0898 0046          ADD       R4,R6
089A DC45          EXTP      R5,#01H
089C A984          MOVB      RL4,[R4]
089E EA20BC09 R    JMPA      cc_Z,next_odt
                                           ; SOURCE LINE # 1458
                                           ; SOURCE LINE # 1459
08A2         ?C0084:
                                           ; SOURCE LINE # 1460
08A2 F04F          MOV       R4,R15
08A4 C086          MOVBZ     R6,RL4
08A6 5C26          SHL       R6,#02H
08A8 D7500000 R    EXTP      #PAG (xcp),#02H
08AC F2F52A08 R    MOV       R5,POF (xcp+082AH)
08B0 F2F42808 R    MOV       R4,POF (xcp+0828H)
08B4 0046          ADD       R4,R6
08B6 DC45          EXTP      R5,#01H
08B8 D4440200      MOV       R4,[R4+#POF(02H)]
08BC C4400C00      MOV       [R0+#0CH],R4  ; el
                                           ; SOURCE LINE # 1461
08C0 F4801000      MOVB      RL4,[R0+#010H]; i
08C4 C086          MOVBZ     R6,RL4
08C6 D4500200      MOV       R5,[R0+#02H]  ; dtop+2
08CA A840          MOV       R4,[R0]       ; dtop
08CC 0046          ADD       R4,R6
08CE C4400400      MOV       [R0+#04H],R4  ; d
08D2 C4500600      MOV       [R0+#06H],R5  ; d+2
                                           ; SOURCE LINE # 1463
08D6 0D34          JMPR      cc_UC,?C0085
08D8         ?C0087:
                                           ; SOURCE LINE # 1465
08D8 D4600A00      MOV       R6,[R0+#0AH]  ; e
08DC D7500000 R    EXTP      #PAG (xcp),#02H
08E0 F2F53208 R    MOV       R5,POF (xcp+0832H)
08E4 F2F43008 R    MOV       R4,POF (xcp+0830H)
08E8 0046          ADD       R4,R6
08EA DC45          EXTP      R5,#01H
08EC A984          MOVB      RL4,[R4]
08EE E4800E00      MOVB      [R0+#0EH],RL4 ; n
                                           ; SOURCE LINE # 1466
08F2 F4800E00      MOVB      RL4,[R0+#0EH] ; n
08F6 2D2A          JMPR      cc_Z,?C0086
                                           ; SOURCE LINE # 1468
                                           ; SOURCE LINE # 1469
08F8         ?C0089:
                                           ; SOURCE LINE # 1479
08F8 F4800E00      MOVB      RL4,[R0+#0EH] ; n
08FC C08C          MOVBZ     R12,RL4
08FE D4600A00      MOV       R6,[R0+#0AH]  ; e
0902 5C26          SHL       R6,#02H
0904 D7500000 R    EXTP      #PAG (xcp),#02H
0908 F2F52E08 R    MOV       R5,POF (xcp+082EH)
090C F2F42C08 R    MOV       R4,POF (xcp+082CH)
0910 0046          ADD       R4,R6
0912 DC55          EXTP      R5,#02H
0914 D4B40200      MOV       R11,[R4+#POF(02H)]
0918 A8A4          MOV       R10,[R4]
C166 COMPILER V7.57.0, XCPBASIC                                                            01/03/2020 16:20:10 PAGE 84  

091A D4900600      MOV       R9,[R0+#06H]  ; d+2
091E D4800400      MOV       R8,[R0+#04H]  ; d
0922 DA000000 R    CALLS     SEG (XcpMemCpy),XcpMemCpy
                                           ; SOURCE LINE # 1480
0926 F4800E00      MOVB      RL4,[R0+#0EH] ; n
092A C086          MOVBZ     R6,RL4
092C D4400400      MOV       R4,[R0+#04H]  ; d
0930 0046          ADD       R4,R6
0932 C4400400      MOV       [R0+#04H],R4  ; d
                                           ; SOURCE LINE # 1482
0936 D4400A00      MOV       R4,[R0+#0AH]  ; e
093A 0841          ADD       R4,#01H
093C C4400A00      MOV       [R0+#0AH],R4  ; e
                                           ; SOURCE LINE # 1483
0940         ?C0085:
0940 D4500C00      MOV       R5,[R0+#0CH]  ; el
0944 D4400A00      MOV       R4,[R0+#0AH]  ; e
0948 4045          CMP       R4,R5
094A FDC6          JMPR      cc_ULE,?C0087
094C         ?C0086:
                                           ; SOURCE LINE # 1484
094C D4700200      MOV       R7,[R0+#02H]  ; dtop+2
0950 A860          MOV       R6,[R0]       ; dtop
0952 F046          MOV       R4,R6
0954 F057          MOV       R5,R7
0956 5CE5          SHL       R5,#0EH
0958 7045          OR        R4,R5
095A F084          MOV       R8,R4
095C D4700600      MOV       R7,[R0+#06H]  ; d+2
0960 D4600400      MOV       R6,[R0+#04H]  ; d
0964 F046          MOV       R4,R6
0966 F057          MOV       R5,R7
0968 5CE5          SHL       R5,#0EH
096A 7045          OR        R4,R5
096C 2048          SUB       R4,R8
096E F1C8          MOVB      RL6,RL4
0970 D4500200      MOV       R5,[R0+#02H]  ; dtop+2
0974 A840          MOV       R4,[R0]       ; dtop
0976 DC45          EXTP      R5,#01H
0978 E4C40800      MOVB      [R4+#POF(08H)],RL6
                                           ; SOURCE LINE # 1492
097C D7400000 R    EXTP      #PAG (xcp),#01H
0980 F3F83E08 R    MOVB      RL4,POF (xcp+083EH)
0984 67F87000      ANDB      RL4,#070H
0988 2D0A          JMPR      cc_Z,?C0090
                                           ; SOURCE LINE # 1494
098A D7400000 R    EXTP      #PAG (xcp),#01H
098E F2F43A08 R    MOV       R4,POF (xcp+083AH)
0992 0841          ADD       R4,#01H
0994 D7400000 R    EXTP      #PAG (xcp),#01H
0998 F6F43A08 R    MOV       POF (xcp+083AH),R4
                                           ; SOURCE LINE # 1495
099C 0D0F          JMPR      cc_UC,next_odt
099E         ?C0090:
                                           ; SOURCE LINE # 1498
099E D7400000 R    EXTP      #PAG (xcp),#01H
09A2 F3F83E08 R    MOVB      RL4,POF (xcp+083EH)
09A6 77F82000      ORB       RL4,#020H
09AA D7400000 R    EXTP      #PAG (xcp),#01H
09AE F7F83E08 R    MOVB      POF (xcp+083EH),RL4
                                           ; SOURCE LINE # 1499
09B2 D4900200      MOV       R9,[R0+#02H]  ; dtop+2
C166 COMPILER V7.57.0, XCPBASIC                                                            01/03/2020 16:20:10 PAGE 85  

09B6 A880          MOV       R8,[R0]       ; dtop
09B8 DA000000 R    CALLS     SEG (XcpSendDto),XcpSendDto
                                           ; SOURCE LINE # 1500
                                           ; SOURCE LINE # 1505
09BC         next_odt:
                                           ; SOURCE LINE # 1507
09BC DA000000 E    CALLS     SEG (ApplXcpInterruptEnable),ApplXcpInterruptEnable
                                           ; SOURCE LINE # 1509
09C0 08F1          ADD       R15,#01H
09C2         ?C0075:
09C2 F04E          MOV       R4,R14
09C4 C085          MOVBZ     R5,RL4
09C6 F045          MOV       R4,R5
09C8 5C24          SHL       R4,#02H
09CA 2045          SUB       R4,R5
09CC 5C14          SHL       R4,#01H
09CE D7400000 R    EXTP      #PAG (xcp),#01H
09D2 F4A42800 R    MOVB      RL5,[R4+#POF(xcp+028H)]
09D6 F04F          MOV       R4,R15
09D8 41A8          CMPB      RL5,RL4
09DA EA901207 R    JMPA      cc_UGE,?C0076
09DE         ?C0074:
                                           ; SOURCE LINE # 1517
09DE         ?C0065:
09DE 08E1          ADD       R14,#01H
09E0         ?C0067:
09E0 D7400000 R    EXTP      #PAG (xcp),#01H
09E4 F3FA2300 R    MOVB      RL5,POF (xcp+023H)
09E8 F04E          MOV       R4,R14
09EA 41A8          CMPB      RL5,RL4
09EC EAE06206 R    JMPA      cc_UGT,?C0068
09F0         ?C0066:
                                           ; SOURCE LINE # 1523
09F0 F4800800      MOVB      RL4,[R0+#08H] ; status
                                           ; SOURCE LINE # 1528
09F4         ?C0064:
09F4 06F01600      ADD       R0,#016H
09F8 FCFF          POP       R15
09FA FCFE          POP       R14
09FC FCFD          POP       R13
09FE DB00          RETS      
             ; FUNCTION XcpEvent (END    RMASK = @0x7FFF)

             ; FUNCTION XcpBackground (BEGIN  RMASK = @0x7FFF)
                                           ; SOURCE LINE # 1635
0A00 ECFD          PUSH      R13
;---- Variable 'n' assigned to Register 'R13' ----
                                           ; SOURCE LINE # 1656
0A02 D7400000 R    EXTP      #PAG (xcp),#01H
0A06 F2F51C00 R    MOV       R5,POF (xcp+01CH)
0A0A 2D50          JMPR      cc_Z,?C0092
                                           ; SOURCE LINE # 1657
                                           ; SOURCE LINE # 1661
0A0C 46F5FF00      CMP       R5,#0FFH
0A10 ED06          JMPR      cc_UGT,?C0093
                                           ; SOURCE LINE # 1663
0A12 F0D5          MOV       R13,R5
                                           ; SOURCE LINE # 1664
0A14 D7400000 R    EXTP      #PAG (xcp),#01H
0A18 F68E1C00 R    MOV       POF (xcp+01CH),ZEROS
                                           ; SOURCE LINE # 1665
0A1C 0D08          JMPR      cc_UC,?C0095
C166 COMPILER V7.57.0, XCPBASIC                                                            01/03/2020 16:20:10 PAGE 86  

0A1E         ?C0093:
                                           ; SOURCE LINE # 1668
0A1E E6FD0001      MOV       R13,#0100H
                                           ; SOURCE LINE # 1669
0A22 26F50001      SUB       R5,#0100H
0A26 D7400000 R    EXTP      #PAG (xcp),#01H
0A2A F6F51C00 R    MOV       POF (xcp+01CH),R5
                                           ; SOURCE LINE # 1670
                                           ; SOURCE LINE # 1673
0A2E         ?C0096:
0A2E         ?C0095:
                                           ; SOURCE LINE # 1674
                                           ; SOURCE LINE # 1676
0A2E D7500000 R    EXTP      #PAG (xcp),#02H
0A32 F2F51800 R    MOV       R5,POF (xcp+018H)
0A36 F2F41600 R    MOV       R4,POF (xcp+016H)
0A3A DC45          EXTP      R5,#01H
0A3C A9C4          MOVB      RL6,[R4]
;---- Variable 'data' assigned to Register 'RL6' ----
                                           ; SOURCE LINE # 1694
0A3E C0C6          MOVBZ     R6,RL6
0A40 E007          MOV       R7,#00H
0A42 D7500000 R    EXTP      #PAG (xcp),#02H
0A46 F2F41E00 R    MOV       R4,POF (xcp+01EH)
0A4A F2F52000 R    MOV       R5,POF (xcp+020H)
0A4E 0046          ADD       R4,R6
0A50 1057          ADDC      R5,R7
0A52 D7600000 R    EXTP      #PAG (xcp),#03H
0A56 F6F41E00 R    MOV       POF (xcp+01EH),R4
0A5A F6F52000 R    MOV       POF (xcp+020H),R5
                                           ; SOURCE LINE # 1698
0A5E F2F41600 R    MOV       R4,POF (xcp+016H)
0A62 0841          ADD       R4,#01H
0A64 D7400000 R    EXTP      #PAG (xcp),#01H
0A68 F6F41600 R    MOV       POF (xcp+016H),R4
                                           ; SOURCE LINE # 1699
0A6C 28D1          SUB       R13,#01H
                                           ; SOURCE LINE # 1702
0A6E 48D0          CMP       R13,#00H
0A70 3DDE          JMPR      cc_NZ,?C0095
0A72         ?C0098:
                                           ; SOURCE LINE # 1707
0A72 D7400000 R    EXTP      #PAG (xcp),#01H
0A76 F2F41C00 R    MOV       R4,POF (xcp+01CH)
0A7A 2D02          JMPR      cc_Z,?C0099
                                           ; SOURCE LINE # 1710
0A7C E118          MOVB      RL4,#01H
0A7E 0D19          JMPR      cc_UC,?C0100
                                           ; SOURCE LINE # 1711
0A80         ?C0099:
                                           ; SOURCE LINE # 1713
0A80 E138          MOVB      RL4,#03H
0A82 D7700000 R    EXTP      #PAG (xcp),#04H
0A86 F7F80100 R    MOVB      POF (xcp+01H),RL4
                                           ; SOURCE LINE # 1715
0A8A F2F41E00 R    MOV       R4,POF (xcp+01EH)
0A8E F2F52000 R    MOV       R5,POF (xcp+020H)
0A92 F6F40400 R    MOV       POF (xcp+04H),R4
0A96 D7400000 R    EXTP      #PAG (xcp),#01H
0A9A F6F50600 R    MOV       POF (xcp+06H),R5
                                           ; SOURCE LINE # 1716
0A9E E188          MOVB      RL4,#08H
C166 COMPILER V7.57.0, XCPBASIC                                                            01/03/2020 16:20:10 PAGE 87  

0AA0 D7400000 R    EXTP      #PAG (xcp),#01H
0AA4 F7F80800 R    MOVB      POF (xcp+08H),RL4
                                           ; SOURCE LINE # 1725
0AA8 DA000000 R    CALLS     SEG (XcpSendCrm),XcpSendCrm
                                           ; SOURCE LINE # 1727
0AAC         ?C0092:
                                           ; SOURCE LINE # 1731
0AAC DA000000 E    CALLS     SEG (XcpCanBackground),XcpCanBackground
                                           ; SOURCE LINE # 1735
0AB0 E108          MOVB      RL4,#00H
                                           ; SOURCE LINE # 1738
0AB2         ?C0100:
0AB2 FCFD          POP       R13
0AB4 DB00          RETS      
             ; FUNCTION XcpBackground (END    RMASK = @0x7FFF)

             ; FUNCTION XcpDisconnect (BEGIN  RMASK = @0x0070)
                                           ; SOURCE LINE # 1756
                                           ; SOURCE LINE # 1761
0AB6 D7400000 R    EXTP      #PAG (xcp),#01H
0ABA F2F41400 R    MOV       R4,POF (xcp+014H)
0ABE 66F4DF00      AND       R4,#0DFH
0AC2 D7400000 R    EXTP      #PAG (xcp),#01H
0AC6 F6F41400 R    MOV       POF (xcp+014H),R4
                                           ; SOURCE LINE # 1764
0ACA DA000000 R    CALLS     SEG (XcpStopAllDaq),XcpStopAllDaq
                                           ; SOURCE LINE # 1768
0ACE E7F81D00      MOVB      RL4,#01DH
0AD2 D7400000 R    EXTP      #PAG (xcp),#01H
0AD6 F7F81A00 R    MOVB      POF (xcp+01AH),RL4
                                           ; SOURCE LINE # 1772
0ADA DB00          RETS      
             ; FUNCTION XcpDisconnect (END    RMASK = @0x0070)

             ; FUNCTION XcpCommand (BEGIN  RMASK = @0x7FFF)
                                           ; SOURCE LINE # 1783
0ADC ECFD          PUSH      R13
0ADE ECFE          PUSH      R14
0AE0 ECFF          PUSH      R15
;---- Variable 'pCommand' assigned to Register 'R8/R9' ----
;---- Variable 'err' assigned to Register 'R13' ----
                                           ; SOURCE LINE # 1784
                                           ; SOURCE LINE # 1785
0AE2 F0E8          MOV       R14,R8
0AE4 F0F9          MOV       R15,R9
;---- Variable 'pCmd' assigned to Register 'R14/R15' ----
                                           ; SOURCE LINE # 1800
0AE6 DC49          EXTP      R9,#01H
0AE8 A988          MOVB      RL4,[R8]
0AEA 47F8FF00      CMPB      RL4,#0FFH
0AEE 3D4C          JMPR      cc_NZ,?C0101
                                           ; SOURCE LINE # 1805
0AF0 D7400000 R    EXTP      #PAG (xcp),#01H
0AF4 F78F0000 R    MOVB      POF (xcp),ONES
                                           ; SOURCE LINE # 1806
0AF8 E118          MOVB      RL4,#01H
0AFA D7500000 R    EXTP      #PAG (xcp),#02H
0AFE F7F80800 R    MOVB      POF (xcp+08H),RL4
                                           ; SOURCE LINE # 1821
0B02 F2F41400 R    MOV       R4,POF (xcp+014H)
0B06 8AF40670      JB        R4.7,?C0102
                                           ; SOURCE LINE # 1823
C166 COMPILER V7.57.0, XCPBASIC                                                            01/03/2020 16:20:10 PAGE 88  

0B0A DA000000 R    CALLS     SEG (XcpFreeDaq),XcpFreeDaq
                                           ; SOURCE LINE # 1825
0B0E D7400000 R    EXTP      #PAG (xcp),#01H
0B12 F78E3E08 R    MOVB      POF (xcp+083EH),ZEROS
                                           ; SOURCE LINE # 1827
0B16         ?C0102:
                                           ; SOURCE LINE # 1832
0B16 E7F81D00      MOVB      RL4,#01DH
0B1A D7400000 R    EXTP      #PAG (xcp),#01H
0B1E F7F81A00 R    MOVB      POF (xcp+01AH),RL4
                                           ; SOURCE LINE # 1836
0B22 E6F42000      MOV       R4,#020H
0B26 D7400000 R    EXTP      #PAG (xcp),#01H
0B2A F6F41400 R    MOV       POF (xcp+014H),R4
                                           ; SOURCE LINE # 1838
0B2E E188          MOVB      RL4,#08H
0B30 D7400000 R    EXTP      #PAG (xcp),#01H
0B34 F7F80800 R    MOVB      POF (xcp+08H),RL4
                                           ; SOURCE LINE # 1841
0B38 E118          MOVB      RL4,#01H
0B3A D7400000 R    EXTP      #PAG (xcp),#01H
0B3E F7F80700 R    MOVB      POF (xcp+07H),RL4
                                           ; SOURCE LINE # 1842
0B42 E118          MOVB      RL4,#01H
0B44 D7400000 R    EXTP      #PAG (xcp),#01H
0B48 F7F80600 R    MOVB      POF (xcp+06H),RL4
                                           ; SOURCE LINE # 1844
0B4C E188          MOVB      RL4,#08H
0B4E D7400000 R    EXTP      #PAG (xcp),#01H
0B52 F7F80300 R    MOVB      POF (xcp+03H),RL4
                                           ; SOURCE LINE # 1845
0B56 E084          MOV       R4,#08H
0B58 D7400000 R    EXTP      #PAG (xcp),#01H
0B5C F6F40400 R    MOV       POF (xcp+04H),R4
                                           ; SOURCE LINE # 1848
0B60 E118          MOVB      RL4,#01H
0B62 D7400000 R    EXTP      #PAG (xcp),#01H
0B66 F7F80100 R    MOVB      POF (xcp+01H),RL4
                                           ; SOURCE LINE # 1853
0B6A E158          MOVB      RL4,#05H
0B6C D7500000 R    EXTP      #PAG (xcp),#02H
0B70 F7F80100 R    MOVB      POF (xcp+01H),RL4
                                           ; SOURCE LINE # 1856
0B74 F78E0200 R    MOVB      POF (xcp+02H),ZEROS
                                           ; SOURCE LINE # 1858
0B78 E7F88000      MOVB      RL4,#080H
0B7C D7400000 R    EXTP      #PAG (xcp),#01H
0B80 F7F80200 R    MOVB      POF (xcp+02H),RL4
                                           ; SOURCE LINE # 1872
0B84 EA00C213 R    JMPA      cc_UC,positive_response
                                           ; SOURCE LINE # 1874
0B88         ?C0101:
                                           ; SOURCE LINE # 1879
0B88 D7400000 R    EXTP      #PAG (xcp),#01H
0B8C F2F51400 R    MOV       R5,POF (xcp+014H)
0B90 8AF50250      JB        R5.5,$+8
0B94 EA00C613 R    JMPA      cc_UC,no_response
                                           ; SOURCE LINE # 1883
0B98 D7400000 R    EXTP      #PAG (xcp),#01H
0B9C F3F83E08 R    MOVB      RL4,POF (xcp+083EH)
0BA0 67F81100      ANDB      RL4,#011H
0BA4 2D07          JMPR      cc_Z,?C0106
C166 COMPILER V7.57.0, XCPBASIC                                                            01/03/2020 16:20:10 PAGE 89  

                                           ; SOURCE LINE # 1885
0BA6 4FF5          BSET      R5.4
0BA8 D7400000 R    EXTP      #PAG (xcp),#01H
0BAC F6F51400 R    MOV       POF (xcp+014H),R5
                                           ; SOURCE LINE # 1889
0BB0 EA00C613 R    JMPA      cc_UC,no_response
                                           ; SOURCE LINE # 1890
0BB4         ?C0106:
                                           ; SOURCE LINE # 1899
0BB4 D7400000 R    EXTP      #PAG (xcp),#01H
0BB8 F78F0000 R    MOVB      POF (xcp),ONES
                                           ; SOURCE LINE # 1900
0BBC E118          MOVB      RL4,#01H
0BBE D7400000 R    EXTP      #PAG (xcp),#01H
0BC2 F7F80800 R    MOVB      POF (xcp+08H),RL4
                                           ; SOURCE LINE # 1902
0BC6 DC4F          EXTP      R15,#01H
0BC8 A98E          MOVB      RL4,[R14]
0BCA 07F82D00      ADDB      RL4,#02DH
0BCE EA20E210 R    JMPA      cc_Z,?C0109
0BD2 2982          SUBB      RL4,#02H
0BD4 EA80C010 R    JMPA      cc_C,?C0111
0BD8 EA20A810 R    JMPA      cc_Z,?C0112
0BDC 2981          SUBB      RL4,#01H
0BDE EA208C10 R    JMPA      cc_Z,?C0113
0BE2 2983          SUBB      RL4,#03H
0BE4 EA204010 R    JMPA      cc_Z,?C0114
0BE8 2981          SUBB      RL4,#01H
0BEA EA200E10 R    JMPA      cc_Z,?C0115
0BEE 2982          SUBB      RL4,#02H
0BF0 EA208013 R    JMPA      cc_Z,?C0116
0BF4 2982          SUBB      RL4,#02H
0BF6 EA802A13 R    JMPA      cc_C,?C0117
0BFA EA20A812 R    JMPA      cc_Z,?C0118
0BFE 2982          SUBB      RL4,#02H
0C00 EA800A11 R    JMPA      cc_C,?C0119
0C04 EA206C11 R    JMPA      cc_Z,?C0120
0C08 2982          SUBB      RL4,#02H
0C0A EA802812 R    JMPA      cc_C,?C0121
0C0E EA20CA11 R    JMPA      cc_Z,?C0122
0C12 07F8F800      ADDB      RL4,#0F8H
0C16 EA202A0E R    JMPA      cc_Z,?C0123
0C1A 2981          SUBB      RL4,#01H
0C1C EA20020E R    JMPA      cc_Z,?C0124
0C20 2983          SUBB      RL4,#03H
0C22 EA20D00E R    JMPA      cc_Z,?C0125
0C26 2982          SUBB      RL4,#02H
0C28 EA20780E R    JMPA      cc_Z,?C0126
0C2C 2983          SUBB      RL4,#03H
0C2E EA20C40F R    JMPA      cc_Z,?C0127
0C32 2982          SUBB      RL4,#02H
0C34 EA80600F R    JMPA      cc_C,?C0128
0C38 EA20160F R    JMPA      cc_Z,?C0129
0C3C 2982          SUBB      RL4,#02H
0C3E EA80540E R    JMPA      cc_C,?C0130
0C42 EA20AA0D R    JMPA      cc_Z,?C0131
0C46 2981          SUBB      RL4,#01H
0C48 2D7C          JMPR      cc_Z,?C0132
0C4A 2982          SUBB      RL4,#02H
0C4C 2D38          JMPR      cc_Z,?C0133
0C4E 2981          SUBB      RL4,#01H
0C50 2D16          JMPR      cc_Z,?C0134
C166 COMPILER V7.57.0, XCPBASIC                                                            01/03/2020 16:20:10 PAGE 90  

0C52 2982          SUBB      RL4,#02H
0C54 2D63          JMPR      cc_Z,?C0136
0C56 2981          SUBB      RL4,#01H
0C58 2D29          JMPR      cc_Z,?C0137
0C5A 0982          ADDB      RL4,#02H
0C5C EA309E13 R    JMPA      cc_NZ,?C0110
                                           ; SOURCE LINE # 1905
0C60         ?C0135:
                                           ; SOURCE LINE # 1908
0C60 E128          MOVB      RL4,#02H
0C62 D7400000 R    EXTP      #PAG (xcp),#01H
0C66 F7F80800 R    MOVB      POF (xcp+08H),RL4
                                           ; SOURCE LINE # 1909
0C6A E7F8FE00      MOVB      RL4,#0FEH
0C6E D7500000 R    EXTP      #PAG (xcp),#02H
0C72 F7F80000 R    MOVB      POF (xcp),RL4
                                           ; SOURCE LINE # 1910
0C76 F78E0100 R    MOVB      POF (xcp+01H),ZEROS
                                           ; SOURCE LINE # 1920
0C7A EA00C213 R    JMPA      cc_UC,positive_response
                                           ; SOURCE LINE # 1924
0C7E         ?C0134:
                                           ; SOURCE LINE # 1926
0C7E E188          MOVB      RL4,#08H
0C80 D7400000 R    EXTP      #PAG (xcp),#01H
0C84 F7F80800 R    MOVB      POF (xcp+08H),RL4
                                           ; SOURCE LINE # 1931
0C88 E7F81000      MOVB      RL4,#010H
0C8C D7700000 R    EXTP      #PAG (xcp),#04H
0C90 F7F80700 R    MOVB      POF (xcp+07H),RL4
                                           ; SOURCE LINE # 1932
0C94 F78E0200 R    MOVB      POF (xcp+02H),ZEROS
                                           ; SOURCE LINE # 1933
0C98 F78E0600 R    MOVB      POF (xcp+06H),ZEROS
                                           ; SOURCE LINE # 1934
0C9C F78E0400 R    MOVB      POF (xcp+04H),ZEROS
                                           ; SOURCE LINE # 1935
0CA0 D7400000 R    EXTP      #PAG (xcp),#01H
0CA4 F78E0500 R    MOVB      POF (xcp+05H),ZEROS
                                           ; SOURCE LINE # 1946
0CA8 EA00C213 R    JMPA      cc_UC,positive_response
                                           ; SOURCE LINE # 1950
0CAC         ?C0137:
                                           ; SOURCE LINE # 1952
0CAC E118          MOVB      RL4,#01H
0CAE D7400000 R    EXTP      #PAG (xcp),#01H
0CB2 F7F80800 R    MOVB      POF (xcp+08H),RL4
                                           ; SOURCE LINE # 1953
0CB6 DA000000 R    CALLS     SEG (XcpDisconnect),XcpDisconnect
                                           ; SOURCE LINE # 1963
0CBA EA00C213 R    JMPA      cc_UC,positive_response
                                           ; SOURCE LINE # 1967
0CBE         ?C0133:
                                           ; SOURCE LINE # 1969
0CBE E188          MOVB      RL4,#08H
0CC0 D7700000 R    EXTP      #PAG (xcp),#04H
0CC4 F7F80800 R    MOVB      POF (xcp+08H),RL4
                                           ; SOURCE LINE # 1970
0CC8 F78E0100 R    MOVB      POF (xcp+01H),ZEROS
                                           ; SOURCE LINE # 1971
0CCC F68E0400 R    MOV       POF (xcp+04H),ZEROS
0CD0 F68E0600 R    MOV       POF (xcp+06H),ZEROS
C166 COMPILER V7.57.0, XCPBASIC                                                            01/03/2020 16:20:10 PAGE 91  

                                           ; SOURCE LINE # 1974
0CD4 DC4F          EXTP      R15,#01H
0CD6 F48E0100      MOVB      RL4,[R14+#POF(01H)]
0CDA 4981          CMPB      RL4,#01H
0CDC EA30C213 R    JMPA      cc_NZ,positive_response
                                           ; SOURCE LINE # 1976
0CE0 E074          MOV       R4,#07H
0CE2 D7500000 R    EXTP      #PAG (xcp),#02H
0CE6 F6F40400 R    MOV       POF (xcp+04H),R4
0CEA F68E0600 R    MOV       POF (xcp+06H),ZEROS
                                           ; SOURCE LINE # 1977
0CEE E6F40000 E    MOV       R4,#POF (kXcpStationId)
0CF2 E6F50000 E    MOV       R5,#PAG (kXcpStationId)
0CF6 F094          MOV       R9,R4
0CF8 F0A5          MOV       R10,R5
0CFA 4AFAF90E      BMOV      R9.14,R10.0
0CFE 4AFAF91F      BMOV      R9.15,R10.1
0D02 7C2A          SHR       R10,#02H
0D04 E6F8FF00      MOV       R8,#0FFH
0D08 DA000000 E    CALLS     SEG (ApplXcpGetPointer),ApplXcpGetPointer
0D0C D7500000 R    EXTP      #PAG (xcp),#02H
0D10 F6F41600 R    MOV       POF (xcp+016H),R4
0D14 F6F51800 R    MOV       POF (xcp+018H),R5
                                           ; SOURCE LINE # 1978
0D18 EA00C213 R    JMPA      cc_UC,positive_response
                                           ; SOURCE LINE # 1987
                                           ; SOURCE LINE # 1997
                                           ; SOURCE LINE # 2001
0D1C         ?C0136:
                                           ; SOURCE LINE # 2003
0D1C E168          MOVB      RL4,#06H
0D1E D7700000 R    EXTP      #PAG (xcp),#04H
0D22 F7F80800 R    MOVB      POF (xcp+08H),RL4
                                           ; SOURCE LINE # 2004
0D26 F3F81400 R    MOVB      RL4,POF (xcp+014H)
0D2A F7F80100 R    MOVB      POF (xcp+01H),RL4
                                           ; SOURCE LINE # 2007
0D2E F3F81A00 R    MOVB      RL4,POF (xcp+01AH)
0D32 D7500000 R    EXTP      #PAG (xcp),#02H
0D36 F7F80200 R    MOVB      POF (xcp+02H),RL4
                                           ; SOURCE LINE # 2013
0D3A F68E0400 R    MOV       POF (xcp+04H),ZEROS
                                           ; SOURCE LINE # 2023
0D3E EA00C213 R    JMPA      cc_UC,positive_response
                                           ; SOURCE LINE # 2028
0D42         ?C0132:
                                           ; SOURCE LINE # 2033
0D42 DC4F          EXTP      R15,#01H
0D44 F48E0100      MOVB      RL4,[R14+#POF(01H)]
0D48 4981          CMPB      RL4,#01H
0D4A 3D04          JMPR      cc_NZ,?C0140
                                           ; SOURCE LINE # 2036
0D4C E6FD2200      MOV       R13,#022H
0D50 EA00A213 R    JMPA      cc_UC,negative_response
                                           ; SOURCE LINE # 2037
0D54         ?C0140:
                                           ; SOURCE LINE # 2057
0D54 DC4F          EXTP      R15,#01H
0D56 F4CE0200      MOVB      RL6,[R14+#POF(02H)]
0D5A D7400000 R    EXTP      #PAG (xcp),#01H
0D5E F3F81A00 R    MOVB      RL4,POF (xcp+01AH)
0D62 618C          ANDB      RL4,RL6
C166 COMPILER V7.57.0, XCPBASIC                                                            01/03/2020 16:20:10 PAGE 92  

0D64 2D13          JMPR      cc_Z,?C0143
                                           ; SOURCE LINE # 2058
                                           ; SOURCE LINE # 2060
0D66 E6F90200 R    MOV       R9,#POF (xcp+02H)
0D6A E6FA0000 R    MOV       R10,#PAG (xcp)
0D6E C0C8          MOVBZ     R8,RL6
0D70 DA000000 E    CALLS     SEG (ApplXcpGetSeed),ApplXcpGetSeed
0D74 F1A8          MOVB      RL5,RL4
;---- Variable 'seedLength' assigned to Register 'RL5' ----
                                           ; SOURCE LINE # 2061
0D76 49A6          CMPB      RL5,#06H
0D78 FD04          JMPR      cc_ULE,?C0144
                                           ; SOURCE LINE # 2064
0D7A E6FD2200      MOV       R13,#022H
0D7E EA00A213 R    JMPA      cc_UC,negative_response
                                           ; SOURCE LINE # 2065
0D82         ?C0144:
                                           ; SOURCE LINE # 2066
0D82 D7400000 R    EXTP      #PAG (xcp),#01H
0D86 F7FA0100 R    MOVB      POF (xcp+01H),RL5
                                           ; SOURCE LINE # 2067
0D8A 0D04          JMPR      cc_UC,?C0145
0D8C         ?C0143:
                                           ; SOURCE LINE # 2071
0D8C D7400000 R    EXTP      #PAG (xcp),#01H
0D90 F78E0100 R    MOVB      POF (xcp+01H),ZEROS
                                           ; SOURCE LINE # 2072
0D94         ?C0145:
                                           ; SOURCE LINE # 2073
0D94 D7400000 R    EXTP      #PAG (xcp),#01H
0D98 C2F40100 R    MOVBZ     R4,POF (xcp+01H)
0D9C 0842          ADD       R4,#02H
0D9E D7400000 R    EXTP      #PAG (xcp),#01H
0DA2 F7F80800 R    MOVB      POF (xcp+08H),RL4
                                           ; SOURCE LINE # 2074
                                           ; SOURCE LINE # 2084
0DA6 EA00C213 R    JMPA      cc_UC,positive_response
                                           ; SOURCE LINE # 2086
0DAA         ?C0131:
                                           ; SOURCE LINE # 2087
                                           ; SOURCE LINE # 2098
0DAA DC4F          EXTP      R15,#01H
0DAC F4AE0100      MOVB      RL5,[R14+#POF(01H)]
0DB0 49A6          CMPB      RL5,#06H
0DB2 FD04          JMPR      cc_ULE,?C0146
                                           ; SOURCE LINE # 2100
0DB4 E6FD2900      MOV       R13,#029H
0DB8 EA00A213 R    JMPA      cc_UC,negative_response
                                           ; SOURCE LINE # 2101
0DBC         ?C0146:
                                           ; SOURCE LINE # 2104
0DBC C0AA          MOVBZ     R10,RL5
0DBE F08E          MOV       R8,R14
0DC0 0882          ADD       R8,#02H
0DC2 F09F          MOV       R9,R15
0DC4 DA000000 E    CALLS     SEG (ApplXcpUnlock),ApplXcpUnlock
0DC8 F1E8          MOVB      RL7,RL4
;---- Variable 'resource' assigned to Register 'RL7' ----
                                           ; SOURCE LINE # 2105
0DCA 49E0          CMPB      RL7,#00H
0DCC 3D06          JMPR      cc_NZ,?C0148
                                           ; SOURCE LINE # 2109
C166 COMPILER V7.57.0, XCPBASIC                                                            01/03/2020 16:20:10 PAGE 93  

0DCE DA000000 R    CALLS     SEG (XcpDisconnect),XcpDisconnect
                                           ; SOURCE LINE # 2110
0DD2 E6FD2500      MOV       R13,#025H
0DD6 EA00A213 R    JMPA      cc_UC,negative_response
                                           ; SOURCE LINE # 2111
0DDA         ?C0148:
                                           ; SOURCE LINE # 2115
0DDA F1AE          MOVB      RL5,RL7
0DDC B1A0          CPLB      RL5
0DDE D7400000 R    EXTP      #PAG (xcp),#01H
0DE2 F3F81A00 R    MOVB      RL4,POF (xcp+01AH)
0DE6 618A          ANDB      RL4,RL5
0DE8 D7500000 R    EXTP      #PAG (xcp),#02H
0DEC F7F81A00 R    MOVB      POF (xcp+01AH),RL4
                                           ; SOURCE LINE # 2118
0DF0 F7F80100 R    MOVB      POF (xcp+01H),RL4
                                           ; SOURCE LINE # 2119
0DF4 E128          MOVB      RL4,#02H
0DF6 D7400000 R    EXTP      #PAG (xcp),#01H
0DFA F7F80800 R    MOVB      POF (xcp+08H),RL4
                                           ; SOURCE LINE # 2120
                                           ; SOURCE LINE # 2121
                                           ; SOURCE LINE # 2130
0DFE EA00C213 R    JMPA      cc_UC,positive_response
                                           ; SOURCE LINE # 2137
0E02         ?C0124:
                                           ; SOURCE LINE # 2146
0E02 DC4F          EXTP      R15,#01H
0E04 F48E0100      MOVB      RL4,[R14+#POF(01H)]
0E08 C08A          MOVBZ     R10,RL4
0E0A DC4F          EXTP      R15,#01H
0E0C F48E0300      MOVB      RL4,[R14+#POF(03H)]
0E10 C089          MOVBZ     R9,RL4
0E12 DC4F          EXTP      R15,#01H
0E14 F48E0200      MOVB      RL4,[R14+#POF(02H)]
0E18 C088          MOVBZ     R8,RL4
0E1A DA000000 E    CALLS     SEG (ApplXcpSetCalPage),ApplXcpSetCalPage
0E1E F0D4          MOV       R13,R4
0E20 4980          CMPB      RL4,#00H
0E22 EA30A213 R    JMPA      cc_NZ,negative_response
0E26         ?C0150:
                                           ; SOURCE LINE # 2155
0E26 EA00C213 R    JMPA      cc_UC,positive_response
                                           ; SOURCE LINE # 2157
0E2A         ?C0123:
                                           ; SOURCE LINE # 2167
0E2A E148          MOVB      RL4,#04H
0E2C D7400000 R    EXTP      #PAG (xcp),#01H
0E30 F7F80800 R    MOVB      POF (xcp+08H),RL4
                                           ; SOURCE LINE # 2168
0E34 DC4F          EXTP      R15,#01H
0E36 F48E0100      MOVB      RL4,[R14+#POF(01H)]
0E3A C089          MOVBZ     R9,RL4
0E3C DC4F          EXTP      R15,#01H
0E3E F48E0200      MOVB      RL4,[R14+#POF(02H)]
0E42 C088          MOVBZ     R8,RL4
0E44 DA000000 E    CALLS     SEG (ApplXcpGetCalPage),ApplXcpGetCalPage
0E48 D7400000 R    EXTP      #PAG (xcp),#01H
0E4C F7F80300 R    MOVB      POF (xcp+03H),RL4
                                           ; SOURCE LINE # 2177
0E50 EA00C213 R    JMPA      cc_UC,positive_response
                                           ; SOURCE LINE # 2385
C166 COMPILER V7.57.0, XCPBASIC                                                            01/03/2020 16:20:10 PAGE 94  

0E54         ?C0130:
                                           ; SOURCE LINE # 2393
0E54 DC6F          EXTP      R15,#03H
0E56 D49E0400      MOV       R9,[R14+#POF(04H)]
0E5A D4AE0600      MOV       R10,[R14+#POF(06H)]
0E5E F48E0300      MOVB      RL4,[R14+#POF(03H)]
0E62 C088          MOVBZ     R8,RL4
0E64 DA000000 E    CALLS     SEG (ApplXcpGetPointer),ApplXcpGetPointer
0E68 D7500000 R    EXTP      #PAG (xcp),#02H
0E6C F6F41600 R    MOV       POF (xcp+016H),R4
0E70 F6F51800 R    MOV       POF (xcp+018H),R5
                                           ; SOURCE LINE # 2403
0E74 EA00C213 R    JMPA      cc_UC,positive_response
                                           ; SOURCE LINE # 2406
0E78         ?C0126:
                                           ; SOURCE LINE # 2407
                                           ; SOURCE LINE # 2424
0E78 D7400000 R    EXTP      #PAG (xcp),#01H
0E7C F3F81A00 R    MOVB      RL4,POF (xcp+01AH)
0E80 9AF40400      JNB       R4.0,?C0151
0E84 E6FD2500      MOV       R13,#025H
0E88 EA00A213 R    JMPA      cc_UC,negative_response
0E8C         ?C0151:
                                           ; SOURCE LINE # 2426
0E8C DC4F          EXTP      R15,#01H
0E8E F4AE0100      MOVB      RL5,[R14+#POF(01H)]
;---- Variable 'size' assigned to Register 'RL5' ----
                                           ; SOURCE LINE # 2427
0E92 49A6          CMPB      RL5,#06H
0E94 FD04          JMPR      cc_ULE,?C0152
                                           ; SOURCE LINE # 2429
0E96 E6FD2200      MOV       R13,#022H
0E9A EA00A213 R    JMPA      cc_UC,negative_response
                                           ; SOURCE LINE # 2430
0E9E         ?C0152:
                                           ; SOURCE LINE # 2432
0E9E F09E          MOV       R9,R14
0EA0 0892          ADD       R9,#02H
0EA2 F0AF          MOV       R10,R15
0EA4 C0A8          MOVBZ     R8,RL5
0EA6 DA000000 R    CALLS     SEG (XcpWriteMta),XcpWriteMta
0EAA F0D4          MOV       R13,R4
                                           ; SOURCE LINE # 2433
0EAC 4982          CMPB      RL4,#02H
0EAE EA20C613 R    JMPA      cc_Z,no_response
                                           ; SOURCE LINE # 2435
                                           ; SOURCE LINE # 2436
0EB2         ?C0153:
                                           ; SOURCE LINE # 2437
0EB2 F04D          MOV       R4,R13
0EB4 4980          CMPB      RL4,#00H
0EB6 3D04          JMPR      cc_NZ,?C0155
                                           ; SOURCE LINE # 2439
0EB8 E6FD2300      MOV       R13,#023H
0EBC EA00A213 R    JMPA      cc_UC,negative_response
                                           ; SOURCE LINE # 2440
0EC0         ?C0155:
                                           ; SOURCE LINE # 2441
0EC0 F04D          MOV       R4,R13
0EC2 4983          CMPB      RL4,#03H
0EC4 EA30C213 R    JMPA      cc_NZ,positive_response
                                           ; SOURCE LINE # 2443
C166 COMPILER V7.57.0, XCPBASIC                                                            01/03/2020 16:20:10 PAGE 95  

0EC8 E6FD2100      MOV       R13,#021H
0ECC EA00A213 R    JMPA      cc_UC,negative_response
                                           ; SOURCE LINE # 2444
                                           ; SOURCE LINE # 2458
                                           ; SOURCE LINE # 2460
0ED0         ?C0125:
                                           ; SOURCE LINE # 2476
0ED0 D7400000 R    EXTP      #PAG (xcp),#01H
0ED4 F3F81A00 R    MOVB      RL4,POF (xcp+01AH)
0ED8 9AF40400      JNB       R4.0,?C0157
0EDC E6FD2500      MOV       R13,#025H
0EE0 EA00A213 R    JMPA      cc_UC,negative_response
0EE4         ?C0157:
                                           ; SOURCE LINE # 2478
0EE4 F09E          MOV       R9,R14
0EE6 0891          ADD       R9,#01H
0EE8 F0AF          MOV       R10,R15
0EEA E078          MOV       R8,#07H
0EEC DA000000 R    CALLS     SEG (XcpWriteMta),XcpWriteMta
0EF0 F0D4          MOV       R13,R4
                                           ; SOURCE LINE # 2479
0EF2 4982          CMPB      RL4,#02H
0EF4 EA20C613 R    JMPA      cc_Z,no_response
                                           ; SOURCE LINE # 2481
                                           ; SOURCE LINE # 2482
0EF8         ?C0158:
                                           ; SOURCE LINE # 2483
0EF8 F04D          MOV       R4,R13
0EFA 4980          CMPB      RL4,#00H
0EFC 3D04          JMPR      cc_NZ,?C0159
                                           ; SOURCE LINE # 2485
0EFE E6FD2300      MOV       R13,#023H
0F02 EA00A213 R    JMPA      cc_UC,negative_response
                                           ; SOURCE LINE # 2486
0F06         ?C0159:
                                           ; SOURCE LINE # 2487
0F06 F04D          MOV       R4,R13
0F08 4983          CMPB      RL4,#03H
0F0A EA30C213 R    JMPA      cc_NZ,positive_response
                                           ; SOURCE LINE # 2489
0F0E E6FD2100      MOV       R13,#021H
0F12 EA00A213 R    JMPA      cc_UC,negative_response
                                           ; SOURCE LINE # 2490
                                           ; SOURCE LINE # 2502
                                           ; SOURCE LINE # 2506
0F16         ?C0129:
                                           ; SOURCE LINE # 2507
                                           ; SOURCE LINE # 2508
0F16 DC4F          EXTP      R15,#01H
0F18 F4EE0100      MOVB      RL7,[R14+#POF(01H)]
;---- Variable 'size' assigned to Register 'RL7' ----
                                           ; SOURCE LINE # 2517
0F1C 49E7          CMPB      RL7,#07H
0F1E FD04          JMPR      cc_ULE,?C0161
                                           ; SOURCE LINE # 2519
0F20 E6FD2200      MOV       R13,#022H
0F24 EA00A213 R    JMPA      cc_UC,negative_response
                                           ; SOURCE LINE # 2520
0F28         ?C0161:
                                           ; SOURCE LINE # 2521
0F28 E6F90100 R    MOV       R9,#POF (xcp+01H)
0F2C E6FA0000 R    MOV       R10,#PAG (xcp)
C166 COMPILER V7.57.0, XCPBASIC                                                            01/03/2020 16:20:10 PAGE 96  

0F30 C0E8          MOVBZ     R8,RL7
0F32 DA000000 R    CALLS     SEG (XcpReadMta),XcpReadMta
0F36 F0D4          MOV       R13,R4
                                           ; SOURCE LINE # 2522
0F38 C0E4          MOVBZ     R4,RL7
0F3A 0841          ADD       R4,#01H
0F3C 66F4FF00      AND       R4,#0FFH
0F40 D7400000 R    EXTP      #PAG (xcp),#01H
0F44 F7F80800 R    MOVB      POF (xcp+08H),RL4
                                           ; SOURCE LINE # 2523
0F48 F04D          MOV       R4,R13
0F4A 4982          CMPB      RL4,#02H
0F4C EA20C613 R    JMPA      cc_Z,no_response
                                           ; SOURCE LINE # 2525
                                           ; SOURCE LINE # 2526
0F50         ?C0162:
                                           ; SOURCE LINE # 2527
0F50 F04D          MOV       R4,R13
0F52 4980          CMPB      RL4,#00H
0F54 EA30C213 R    JMPA      cc_NZ,positive_response
                                           ; SOURCE LINE # 2529
0F58 E6FD2400      MOV       R13,#024H
0F5C EA00A213 R    JMPA      cc_UC,negative_response
                                           ; SOURCE LINE # 2530
                                           ; SOURCE LINE # 2545
                                           ; SOURCE LINE # 2547
0F60         ?C0128:
                                           ; SOURCE LINE # 2562
0F60 DC6F          EXTP      R15,#03H
0F62 D49E0400      MOV       R9,[R14+#POF(04H)]
0F66 D4AE0600      MOV       R10,[R14+#POF(06H)]
0F6A F48E0300      MOVB      RL4,[R14+#POF(03H)]
0F6E C088          MOVBZ     R8,RL4
0F70 DA000000 E    CALLS     SEG (ApplXcpGetPointer),ApplXcpGetPointer
0F74 D7500000 R    EXTP      #PAG (xcp),#02H
0F78 F6F41600 R    MOV       POF (xcp+016H),R4
0F7C F6F51800 R    MOV       POF (xcp+018H),R5
                                           ; SOURCE LINE # 2563
0F80 E6F90100 R    MOV       R9,#POF (xcp+01H)
0F84 E6FA0000 R    MOV       R10,#PAG (xcp)
0F88 DC4F          EXTP      R15,#01H
0F8A F48E0100      MOVB      RL4,[R14+#POF(01H)]
0F8E C088          MOVBZ     R8,RL4
0F90 DA000000 R    CALLS     SEG (XcpReadMta),XcpReadMta
0F94 F0D4          MOV       R13,R4
                                           ; SOURCE LINE # 2564
0F96 DC4F          EXTP      R15,#01H
0F98 F48E0100      MOVB      RL4,[R14+#POF(01H)]
0F9C C084          MOVBZ     R4,RL4
0F9E 0841          ADD       R4,#01H
0FA0 66F4FF00      AND       R4,#0FFH
0FA4 D7400000 R    EXTP      #PAG (xcp),#01H
0FA8 F7F80800 R    MOVB      POF (xcp+08H),RL4
                                           ; SOURCE LINE # 2565
0FAC F04D          MOV       R4,R13
0FAE 4982          CMPB      RL4,#02H
0FB0 EA20C613 R    JMPA      cc_Z,no_response
                                           ; SOURCE LINE # 2567
                                           ; SOURCE LINE # 2568
0FB4         ?C0164:
                                           ; SOURCE LINE # 2569
0FB4 F04D          MOV       R4,R13
C166 COMPILER V7.57.0, XCPBASIC                                                            01/03/2020 16:20:10 PAGE 97  

0FB6 4980          CMPB      RL4,#00H
0FB8 EA30C213 R    JMPA      cc_NZ,positive_response
                                           ; SOURCE LINE # 2571
0FBC E6FD2400      MOV       R13,#024H
0FC0 EA00A213 R    JMPA      cc_UC,negative_response
                                           ; SOURCE LINE # 2572
                                           ; SOURCE LINE # 2587
                                           ; SOURCE LINE # 2592
0FC4         ?C0127:
                                           ; SOURCE LINE # 2593
                                           ; SOURCE LINE # 2602
0FC4 DC5F          EXTP      R15,#02H
0FC6 D46E0400      MOV       R6,[R14+#POF(04H)]
0FCA D47E0600      MOV       R7,[R14+#POF(06H)]
;---- Variable 's' assigned to Register 'R6/R7' ----
                                           ; SOURCE LINE # 2610
0FCE D7500000 R    EXTP      #PAG (xcp),#02H
0FD2 F68E1E00 R    MOV       POF (xcp+01EH),ZEROS
0FD6 F68E2000 R    MOV       POF (xcp+020H),ZEROS
                                           ; SOURCE LINE # 2614
0FDA F046          MOV       R4,R6
0FDC 6840          AND       R4,#00H
0FDE F057          MOV       R5,R7
0FE0 7047          OR        R4,R7
0FE2 2D0F          JMPR      cc_Z,?C0166
                                           ; SOURCE LINE # 2616
0FE4 D7500000 R    EXTP      #PAG (xcp),#02H
0FE8 F68F0400 R    MOV       POF (xcp+04H),ONES
0FEC F68E0600 R    MOV       POF (xcp+06H),ZEROS
                                           ; SOURCE LINE # 2617
0FF0 E6FD2200      MOV       R13,#022H
                                           ; SOURCE LINE # 2618
0FF4 E188          MOVB      RL4,#08H
0FF6 D7400000 R    EXTP      #PAG (xcp),#01H
0FFA F7F80800 R    MOVB      POF (xcp+08H),RL4
                                           ; SOURCE LINE # 2620
0FFE EA00AC13 R    JMPA      cc_UC,negative_response1
                                           ; SOURCE LINE # 2621
1002         ?C0166:
                                           ; SOURCE LINE # 2653
1002 D7400000 R    EXTP      #PAG (xcp),#01H
1006 F6F61C00 R    MOV       POF (xcp+01CH),R6
                                           ; SOURCE LINE # 2655
100A EA00C613 R    JMPA      cc_UC,no_response
                                           ; SOURCE LINE # 2658
                                           ; SOURCE LINE # 2671
100E         ?C0115:
                                           ; SOURCE LINE # 2680
100E E188          MOVB      RL4,#08H
1010 D7700000 R    EXTP      #PAG (xcp),#04H
1014 F7F80800 R    MOVB      POF (xcp+08H),RL4
                                           ; SOURCE LINE # 2681
1018 F78E0600 R    MOVB      POF (xcp+06H),ZEROS
                                           ; SOURCE LINE # 2683
101C C2F42300 R    MOVBZ     R4,POF (xcp+023H)
1020 F6F40200 R    MOV       POF (xcp+02H),R4
                                           ; SOURCE LINE # 2687
1024 D7500000 R    EXTP      #PAG (xcp),#02H
1028 F68E0400 R    MOV       POF (xcp+04H),ZEROS
                                           ; SOURCE LINE # 2694
102C F78E0700 R    MOVB      POF (xcp+07H),ZEROS
                                           ; SOURCE LINE # 2706
C166 COMPILER V7.57.0, XCPBASIC                                                            01/03/2020 16:20:10 PAGE 98  

1030 E7F85300      MOVB      RL4,#053H
1034 D7400000 R    EXTP      #PAG (xcp),#01H
1038 F7F80100 R    MOVB      POF (xcp+01H),RL4
                                           ; SOURCE LINE # 2715
103C EA00C213 R    JMPA      cc_UC,positive_response
                                           ; SOURCE LINE # 2721
1040         ?C0114:
                                           ; SOURCE LINE # 2730
1040 E188          MOVB      RL4,#08H
1042 D7400000 R    EXTP      #PAG (xcp),#01H
1046 F7F80800 R    MOVB      POF (xcp+08H),RL4
                                           ; SOURCE LINE # 2731
104A E118          MOVB      RL4,#01H
104C D7400000 R    EXTP      #PAG (xcp),#01H
1050 F7F80100 R    MOVB      POF (xcp+01H),RL4
                                           ; SOURCE LINE # 2732
1054 E118          MOVB      RL4,#01H
1056 D7400000 R    EXTP      #PAG (xcp),#01H
105A F7F80300 R    MOVB      POF (xcp+03H),RL4
                                           ; SOURCE LINE # 2733
105E E178          MOVB      RL4,#07H
1060 D7400000 R    EXTP      #PAG (xcp),#01H
1064 F7F80200 R    MOVB      POF (xcp+02H),RL4
                                           ; SOURCE LINE # 2734
1068 E178          MOVB      RL4,#07H
106A D7400000 R    EXTP      #PAG (xcp),#01H
106E F7F80400 R    MOVB      POF (xcp+04H),RL4
                                           ; SOURCE LINE # 2740
1072 E128          MOVB      RL4,#02H
1074 D7400000 R    EXTP      #PAG (xcp),#01H
1078 F7F80500 R    MOVB      POF (xcp+05H),RL4
                                           ; SOURCE LINE # 2741
107C E6F4003C      MOV       R4,#03C00H
1080 D7400000 R    EXTP      #PAG (xcp),#01H
1084 F6F40600 R    MOV       POF (xcp+06H),R4
                                           ; SOURCE LINE # 2754
1088 EA00C213 R    JMPA      cc_UC,positive_response
                                           ; SOURCE LINE # 2800
108C         ?C0113:
                                           ; SOURCE LINE # 2809
108C D7400000 R    EXTP      #PAG (xcp),#01H
1090 F3F81A00 R    MOVB      RL4,POF (xcp+01AH)
1094 9AF40420      JNB       R4.2,?C0169
1098 E6FD2500      MOV       R13,#025H
109C EA00A213 R    JMPA      cc_UC,negative_response
10A0         ?C0169:
                                           ; SOURCE LINE # 2811
10A0 DA000000 R    CALLS     SEG (XcpFreeDaq),XcpFreeDaq
                                           ; SOURCE LINE # 2820
10A4 EA00C213 R    JMPA      cc_UC,positive_response
                                           ; SOURCE LINE # 2822
10A8         ?C0112:
                                           ; SOURCE LINE # 2823
                                           ; SOURCE LINE # 2824
10A8 DC4F          EXTP      R15,#01H
10AA D44E0200      MOV       R4,[R14+#POF(02H)]
;---- Variable 'count' assigned to Register 'RL4' ----
                                           ; SOURCE LINE # 2833
10AE C088          MOVBZ     R8,RL4
10B0 DA000000 R    CALLS     SEG (XcpAllocDaq),XcpAllocDaq
10B4 F0D4          MOV       R13,R4
10B6 4980          CMPB      RL4,#00H
C166 COMPILER V7.57.0, XCPBASIC                                                            01/03/2020 16:20:10 PAGE 99  

10B8 EA30A213 R    JMPA      cc_NZ,negative_response
10BC         ?C0170:
                                           ; SOURCE LINE # 2842
10BC EA00C213 R    JMPA      cc_UC,positive_response
                                           ; SOURCE LINE # 2844
10C0         ?C0111:
                                           ; SOURCE LINE # 2845
                                           ; SOURCE LINE # 2846
10C0 DC4F          EXTP      R15,#01H
10C2 D44E0200      MOV       R4,[R14+#POF(02H)]
10C6 F1A8          MOVB      RL5,RL4
;---- Variable 'daq' assigned to Register 'RL5' ----
                                           ; SOURCE LINE # 2847
10C8 DC4F          EXTP      R15,#01H
10CA F48E0400      MOVB      RL4,[R14+#POF(04H)]
;---- Variable 'count' assigned to Register 'RL4' ----
                                           ; SOURCE LINE # 2863
10CE C089          MOVBZ     R9,RL4
10D0 C0A8          MOVBZ     R8,RL5
10D2 DA000000 R    CALLS     SEG (XcpAllocOdt),XcpAllocOdt
10D6 F0D4          MOV       R13,R4
10D8 4980          CMPB      RL4,#00H
10DA EA30A213 R    JMPA      cc_NZ,negative_response
10DE         ?C0171:
                                           ; SOURCE LINE # 2872
10DE EA00C213 R    JMPA      cc_UC,positive_response
                                           ; SOURCE LINE # 2874
10E2         ?C0109:
                                           ; SOURCE LINE # 2875
                                           ; SOURCE LINE # 2876
10E2 DC4F          EXTP      R15,#01H
10E4 D44E0200      MOV       R4,[R14+#POF(02H)]
10E8 F1C8          MOVB      RL6,RL4
;---- Variable 'daq' assigned to Register 'RL6' ----
                                           ; SOURCE LINE # 2877
10EA DC5F          EXTP      R15,#02H
10EC F4AE0400      MOVB      RL5,[R14+#POF(04H)]
;---- Variable 'odt' assigned to Register 'RL5' ----
                                           ; SOURCE LINE # 2878
10F0 F48E0500      MOVB      RL4,[R14+#POF(05H)]
;---- Variable 'count' assigned to Register 'RL4' ----
                                           ; SOURCE LINE # 2894
10F4 C08A          MOVBZ     R10,RL4
10F6 C0A9          MOVBZ     R9,RL5
10F8 C0C8          MOVBZ     R8,RL6
10FA DA000000 R    CALLS     SEG (XcpAllocOdtEntry),XcpAllocOdtEntry
10FE F0D4          MOV       R13,R4
1100 4980          CMPB      RL4,#00H
1102 EA30A213 R    JMPA      cc_NZ,negative_response
1106         ?C0172:
                                           ; SOURCE LINE # 2903
1106 EA00C213 R    JMPA      cc_UC,positive_response
                                           ; SOURCE LINE # 2905
110A         ?C0119:
                                           ; SOURCE LINE # 2906
                                           ; SOURCE LINE # 2907
110A DC4F          EXTP      R15,#01H
110C D44E0200      MOV       R4,[R14+#POF(02H)]
1110 F1C8          MOVB      RL6,RL4
;---- Variable 'daq' assigned to Register 'RL6' ----
                                           ; SOURCE LINE # 2923
1112 E188          MOVB      RL4,#08H
C166 COMPILER V7.57.0, XCPBASIC                                                            01/03/2020 16:20:10 PAGE 100 

1114 D7400000 R    EXTP      #PAG (xcp),#01H
1118 F7F80800 R    MOVB      POF (xcp+08H),RL4
                                           ; SOURCE LINE # 2924
111C C0C5          MOVBZ     R5,RL6
111E F045          MOV       R4,R5
1120 5C24          SHL       R4,#02H
1122 2045          SUB       R4,R5
1124 5C14          SHL       R4,#01H
1126 D7500000 R    EXTP      #PAG (xcp),#02H
112A F4842A00 R    MOVB      RL4,[R4+#POF(xcp+02AH)]
112E F7F80100 R    MOVB      POF (xcp+01H),RL4
                                           ; SOURCE LINE # 2926
1132 C0C5          MOVBZ     R5,RL6
1134 F045          MOV       R4,R5
1136 5C24          SHL       R4,#02H
1138 2045          SUB       R4,R5
113A 5C14          SHL       R4,#01H
113C D7500000 R    EXTP      #PAG (xcp),#02H
1140 F4842C00 R    MOVB      RL4,[R4+#POF(xcp+02CH)]
1144 F7F80600 R    MOVB      POF (xcp+06H),RL4
                                           ; SOURCE LINE # 2933
1148 C0C5          MOVBZ     R5,RL6
114A F045          MOV       R4,R5
114C 5C24          SHL       R4,#02H
114E 2045          SUB       R4,R5
1150 5C14          SHL       R4,#01H
1152 D7400000 R    EXTP      #PAG (xcp),#01H
1156 F4842B00 R    MOVB      RL4,[R4+#POF(xcp+02BH)]
115A C084          MOVBZ     R4,RL4
115C D7500000 R    EXTP      #PAG (xcp),#02H
1160 F6F40400 R    MOV       POF (xcp+04H),R4
                                           ; SOURCE LINE # 2935
1164 F78E0700 R    MOVB      POF (xcp+07H),ZEROS
                                           ; SOURCE LINE # 2945
1168 EA00C213 R    JMPA      cc_UC,positive_response
                                           ; SOURCE LINE # 2947
116C         ?C0120:
                                           ; SOURCE LINE # 2948
                                           ; SOURCE LINE # 2949
116C DC4F          EXTP      R15,#01H
116E D44E0200      MOV       R4,[R14+#POF(02H)]
1172 F128          MOVB      RL1,RL4
;---- Variable 'daq' assigned to Register 'RL1' ----
                                           ; SOURCE LINE # 2951
1174 DC5F          EXTP      R15,#02H
1176 F4EE0600      MOVB      RL7,[R14+#POF(06H)]
;---- Variable 'xcpPrescaler' assigned to Register 'RL7' ----
                                           ; SOURCE LINE # 2953
117A D44E0400      MOV       R4,[R14+#POF(04H)]
117E 66F4FF00      AND       R4,#0FFH
1182 F148          MOVB      RL2,RL4
;---- Variable 'event' assigned to Register 'RL2' ----
                                           ; SOURCE LINE # 2987
1184 49E0          CMPB      RL7,#00H
1186 3D01          JMPR      cc_NZ,?C0173
                                           ; SOURCE LINE # 2989
1188 E11E          MOVB      RL7,#01H
                                           ; SOURCE LINE # 2990
118A         ?C0173:
                                           ; SOURCE LINE # 2991
118A C025          MOVBZ     R5,RL1
118C F045          MOV       R4,R5
C166 COMPILER V7.57.0, XCPBASIC                                                            01/03/2020 16:20:10 PAGE 101 

118E 5C24          SHL       R4,#02H
1190 2045          SUB       R4,R5
1192 5C14          SHL       R4,#01H
1194 D7400000 R    EXTP      #PAG (xcp),#01H
1198 E4E42C00 R    MOVB      [R4+#POF(xcp+02CH)],RL7
                                           ; SOURCE LINE # 2996
119C C025          MOVBZ     R5,RL1
119E F045          MOV       R4,R5
11A0 5C24          SHL       R4,#02H
11A2 2045          SUB       R4,R5
11A4 5C14          SHL       R4,#01H
11A6 D7400000 R    EXTP      #PAG (xcp),#01H
11AA E4442B00 R    MOVB      [R4+#POF(xcp+02BH)],RL2
                                           ; SOURCE LINE # 2998
11AE DC4F          EXTP      R15,#01H
11B0 F4CE0100      MOVB      RL6,[R14+#POF(01H)]
11B4 C025          MOVBZ     R5,RL1
11B6 F045          MOV       R4,R5
11B8 5C24          SHL       R4,#02H
11BA 2045          SUB       R4,R5
11BC 5C14          SHL       R4,#01H
11BE D7400000 R    EXTP      #PAG (xcp),#01H
11C2 E4C42A00 R    MOVB      [R4+#POF(xcp+02AH)],RL6
                                           ; SOURCE LINE # 3007
11C6 EA00C213 R    JMPA      cc_UC,positive_response
                                           ; SOURCE LINE # 3011
11CA         ?C0122:
                                           ; SOURCE LINE # 3012
                                           ; SOURCE LINE # 3013
11CA DC4F          EXTP      R15,#01H
11CC D44E0200      MOV       R4,[R14+#POF(02H)]
11D0 66F4FF00      AND       R4,#0FFH
;---- Variable 'daq' assigned to Register 'RL4' ----
                                           ; SOURCE LINE # 3014
11D4 DC5F          EXTP      R15,#02H
11D6 F4CE0400      MOVB      RL6,[R14+#POF(04H)]
;---- Variable 'odt' assigned to Register 'RL6' ----
                                           ; SOURCE LINE # 3015
11DA F4EE0500      MOVB      RL7,[R14+#POF(05H)]
;---- Variable 'idx' assigned to Register 'RL7' ----
                                           ; SOURCE LINE # 3016
11DE C085          MOVBZ     R5,RL4
11E0 F045          MOV       R4,R5
11E2 5C24          SHL       R4,#02H
11E4 2045          SUB       R4,R5
11E6 5C14          SHL       R4,#01H
11E8 D7400000 R    EXTP      #PAG (xcp),#01H
11EC F4842900 R    MOVB      RL4,[R4+#POF(xcp+029H)]
11F0 C085          MOVBZ     R5,RL4
11F2 C0C4          MOVBZ     R4,RL6
11F4 0045          ADD       R4,R5
11F6 F1A8          MOVB      RL5,RL4
;---- Variable 'odt0' assigned to Register 'RL5' ----
                                           ; SOURCE LINE # 3032
11F8 E118          MOVB      RL4,#01H
11FA D7400000 R    EXTP      #PAG (xcp),#01H
11FE F7F80800 R    MOVB      POF (xcp+08H),RL4
                                           ; SOURCE LINE # 3033
1202 C0A6          MOVBZ     R6,RL5
1204 5C26          SHL       R6,#02H
1206 D7500000 R    EXTP      #PAG (xcp),#02H
120A F2F52A08 R    MOV       R5,POF (xcp+082AH)
C166 COMPILER V7.57.0, XCPBASIC                                                            01/03/2020 16:20:10 PAGE 102 

120E F2F42808 R    MOV       R4,POF (xcp+0828H)
1212 0046          ADD       R4,R6
1214 DC45          EXTP      R5,#01H
1216 A854          MOV       R5,[R4]
1218 C0E4          MOVBZ     R4,RL7
121A 0045          ADD       R4,R5
121C D7400000 R    EXTP      #PAG (xcp),#01H
1220 F6F44008 R    MOV       POF (xcp+0840H),R4
                                           ; SOURCE LINE # 3041
1224 EA00C213 R    JMPA      cc_UC,positive_response
                                           ; SOURCE LINE # 3043
1228         ?C0121:
                                           ; SOURCE LINE # 3044
                                           ; SOURCE LINE # 3053
1228 D7400000 R    EXTP      #PAG (xcp),#01H
122C F3F81A00 R    MOVB      RL4,POF (xcp+01AH)
1230 9AF40420      JNB       R4.2,?C0174
1234 E6FD2500      MOV       R13,#025H
1238 EA00A213 R    JMPA      cc_UC,negative_response
123C         ?C0174:
                                           ; SOURCE LINE # 3065
123C DC6F          EXTP      R15,#03H
123E D49E0400      MOV       R9,[R14+#POF(04H)]
1242 D4AE0600      MOV       R10,[R14+#POF(06H)]
1246 F48E0300      MOVB      RL4,[R14+#POF(03H)]
124A C088          MOVBZ     R8,RL4
124C DA000000 E    CALLS     SEG (ApplXcpGetPointer),ApplXcpGetPointer
1250 F0A4          MOV       R10,R4
1252 F0B5          MOV       R11,R5
;---- Variable 'addr' assigned to Register 'R10/R11' ----
                                           ; SOURCE LINE # 3067
1254 E118          MOVB      RL4,#01H
1256 D7400000 R    EXTP      #PAG (xcp),#01H
125A F7F80800 R    MOVB      POF (xcp+08H),RL4
                                           ; SOURCE LINE # 3068
125E DC4F          EXTP      R15,#01H
1260 F4EE0200      MOVB      RL7,[R14+#POF(02H)]
1264 D7600000 R    EXTP      #PAG (xcp),#03H
1268 F2F64008 R    MOV       R6,POF (xcp+0840H)
126C F2F53208 R    MOV       R5,POF (xcp+0832H)
1270 F2F43008 R    MOV       R4,POF (xcp+0830H)
1274 0046          ADD       R4,R6
1276 DC45          EXTP      R5,#01H
1278 B9E4          MOVB      [R4],RL7
                                           ; SOURCE LINE # 3069
127A 5C26          SHL       R6,#02H
127C D7500000 R    EXTP      #PAG (xcp),#02H
1280 F2F52E08 R    MOV       R5,POF (xcp+082EH)
1284 F2F42C08 R    MOV       R4,POF (xcp+082CH)
1288 0046          ADD       R4,R6
128A DC55          EXTP      R5,#02H
128C B8A4          MOV       [R4],R10
128E C4B40200      MOV       [R4+#POF(02H)],R11
                                           ; SOURCE LINE # 3071
1292 D7400000 R    EXTP      #PAG (xcp),#01H
1296 F2F44008 R    MOV       R4,POF (xcp+0840H)
129A 0841          ADD       R4,#01H
129C D7400000 R    EXTP      #PAG (xcp),#01H
12A0 F6F44008 R    MOV       POF (xcp+0840H),R4
                                           ; SOURCE LINE # 3080
12A4 EA00C213 R    JMPA      cc_UC,positive_response
                                           ; SOURCE LINE # 3082
C166 COMPILER V7.57.0, XCPBASIC                                                            01/03/2020 16:20:10 PAGE 103 

12A8         ?C0118:
                                           ; SOURCE LINE # 3083
                                           ; SOURCE LINE # 3084
12A8 DC4F          EXTP      R15,#01H
12AA D44E0200      MOV       R4,[R14+#POF(02H)]
12AE 66F4FF00      AND       R4,#0FFH
12B2 F128          MOVB      RL1,RL4
;---- Variable 'daq' assigned to Register 'RL1' ----
                                           ; SOURCE LINE # 3086
12B4 D7400000 R    EXTP      #PAG (xcp),#01H
12B8 F3F81A00 R    MOVB      RL4,POF (xcp+01AH)
12BC 9AF40320      JNB       R4.2,?C0175
12C0 E6FD2500      MOV       R13,#025H
12C4 0D6E          JMPR      cc_UC,negative_response
12C6         ?C0175:
                                           ; SOURCE LINE # 3095
12C6 DC4F          EXTP      R15,#01H
12C8 F4AE0100      MOVB      RL5,[R14+#POF(01H)]
12CC 49A1          CMPB      RL5,#01H
12CE 2D02          JMPR      cc_Z,?C0177
12D0 49A2          CMPB      RL5,#02H
12D2 3D27          JMPR      cc_NZ,?C0176
12D4         ?C0177:
                                           ; SOURCE LINE # 3097
12D4 C025          MOVBZ     R5,RL1
12D6 F045          MOV       R4,R5
12D8 5C25          SHL       R5,#02H
12DA 2054          SUB       R5,R4
12DC 5C15          SHL       R5,#01H
12DE D7400000 R    EXTP      #PAG (xcp),#01H
12E2 F4852A00 R    MOVB      RL4,[R5+#POF(xcp+02AH)]
12E6 7981          ORB       RL4,#01H
12E8 D7400000 R    EXTP      #PAG (xcp),#01H
12EC E4852A00 R    MOVB      [R5+#POF(xcp+02AH)],RL4
                                           ; SOURCE LINE # 3105
12F0 DC4F          EXTP      R15,#01H
12F2 F48E0100      MOVB      RL4,[R14+#POF(01H)]
12F6 4981          CMPB      RL4,#01H
12F8 3D03          JMPR      cc_NZ,?C0178
                                           ; SOURCE LINE # 3107
12FA C028          MOVBZ     R8,RL1
12FC DA000000 R    CALLS     SEG (XcpStartDaq),XcpStartDaq
                                           ; SOURCE LINE # 3108
1300         ?C0178:
                                           ; SOURCE LINE # 3109
1300 E128          MOVB      RL4,#02H
1302 D7400000 R    EXTP      #PAG (xcp),#01H
1306 F7F80800 R    MOVB      POF (xcp+08H),RL4
                                           ; SOURCE LINE # 3110
130A C025          MOVBZ     R5,RL1
130C F045          MOV       R4,R5
130E 5C24          SHL       R4,#02H
1310 2045          SUB       R4,R5
1312 5C14          SHL       R4,#01H
1314 D7500000 R    EXTP      #PAG (xcp),#02H
1318 F4842900 R    MOVB      RL4,[R4+#POF(xcp+029H)]
131C F7F80100 R    MOVB      POF (xcp+01H),RL4
                                           ; SOURCE LINE # 3111
1320 0D50          JMPR      cc_UC,positive_response
1322         ?C0176:
                                           ; SOURCE LINE # 3114
1322 C028          MOVBZ     R8,RL1
C166 COMPILER V7.57.0, XCPBASIC                                                            01/03/2020 16:20:10 PAGE 104 

1324 DA000000 R    CALLS     SEG (XcpStopDaq),XcpStopDaq
                                           ; SOURCE LINE # 3121
                                           ; SOURCE LINE # 3130
1328 0D4C          JMPR      cc_UC,positive_response
                                           ; SOURCE LINE # 3132
132A         ?C0117:
                                           ; SOURCE LINE # 3141
132A D7400000 R    EXTP      #PAG (xcp),#01H
132E F3F81A00 R    MOVB      RL4,POF (xcp+01AH)
1332 9AF40320      JNB       R4.2,?C0180
1336 E6FD2500      MOV       R13,#025H
133A 0D33          JMPR      cc_UC,negative_response
133C         ?C0180:
                                           ; SOURCE LINE # 3143
133C D7400000 R    EXTP      #PAG (xcp),#01H
1340 F3F82300 R    MOVB      RL4,POF (xcp+023H)
1344 2D0A          JMPR      cc_Z,?C0182
1346 D7400000 R    EXTP      #PAG (xcp),#01H
134A F3F82400 R    MOVB      RL4,POF (xcp+024H)
134E 2D05          JMPR      cc_Z,?C0182
1350 D7400000 R    EXTP      #PAG (xcp),#01H
1354 F2F42600 R    MOV       R4,POF (xcp+026H)
1358 3D03          JMPR      cc_NZ,?C0181
135A         ?C0182:
                                           ; SOURCE LINE # 3145
135A E6FD2A00      MOV       R13,#02AH
135E 0D21          JMPR      cc_UC,negative_response
                                           ; SOURCE LINE # 3146
1360         ?C0181:
                                           ; SOURCE LINE # 3148
1360 DC4F          EXTP      R15,#01H
1362 F42E0100      MOVB      RL1,[R14+#POF(01H)]
1366 4922          CMPB      RL1,#02H
1368 3D03          JMPR      cc_NZ,?C0183
                                           ; SOURCE LINE # 3150
136A DA000000 R    CALLS     SEG (XcpStopAllSelectedDaq),XcpStopAllSelectedDaq
                                           ; SOURCE LINE # 3151
136E 0D29          JMPR      cc_UC,positive_response
1370         ?C0183:
                                           ; SOURCE LINE # 3154
1370 4921          CMPB      RL1,#01H
1372 3D03          JMPR      cc_NZ,?C0185
                                           ; SOURCE LINE # 3156
1374 DA000000 R    CALLS     SEG (XcpStartAllSelectedDaq),XcpStartAllSelectedDaq
                                           ; SOURCE LINE # 3157
1378 0D24          JMPR      cc_UC,positive_response
137A         ?C0185:
                                           ; SOURCE LINE # 3161
137A DA000000 R    CALLS     SEG (XcpStopAllDaq),XcpStopAllDaq
                                           ; SOURCE LINE # 3162
                                           ; SOURCE LINE # 3163
                                           ; SOURCE LINE # 3171
137E 0D21          JMPR      cc_UC,positive_response
                                           ; SOURCE LINE # 3174
1380         ?C0116:
                                           ; SOURCE LINE # 3176
1380 E188          MOVB      RL4,#08H
1382 D7400000 R    EXTP      #PAG (xcp),#01H
1386 F7F80800 R    MOVB      POF (xcp+08H),RL4
                                           ; SOURCE LINE # 3178
138A DA000000 E    CALLS     SEG (ApplXcpGetTimestamp),ApplXcpGetTimestamp
138E E005          MOV       R5,#00H
C166 COMPILER V7.57.0, XCPBASIC                                                            01/03/2020 16:20:10 PAGE 105 

1390 D7500000 R    EXTP      #PAG (xcp),#02H
1394 F6F40400 R    MOV       POF (xcp+04H),R4
1398 F6F50600 R    MOV       POF (xcp+06H),R5
                                           ; SOURCE LINE # 3188
139C 0D12          JMPR      cc_UC,positive_response
                                           ; SOURCE LINE # 3243
139E         ?C0110:
                                           ; SOURCE LINE # 3251
139E E6FD2000      MOV       R13,#020H
                                           ; SOURCE LINE # 3254
                                           ; SOURCE LINE # 3256
                                           ; SOURCE LINE # 3257
                                           ; SOURCE LINE # 3262
                                           ; SOURCE LINE # 3263
                                           ; SOURCE LINE # 3264
                                           ; SOURCE LINE # 3266
13A2         negative_response:
                                           ; SOURCE LINE # 3267
13A2 E128          MOVB      RL4,#02H
13A4 D7400000 R    EXTP      #PAG (xcp),#01H
13A8 F7F80800 R    MOVB      POF (xcp+08H),RL4
                                           ; SOURCE LINE # 3270
13AC         negative_response1:
                                           ; SOURCE LINE # 3272
13AC E7F8FE00      MOVB      RL4,#0FEH
13B0 D7400000 R    EXTP      #PAG (xcp),#01H
13B4 F7F80000 R    MOVB      POF (xcp),RL4
                                           ; SOURCE LINE # 3273
13B8 F04D          MOV       R4,R13
13BA D7400000 R    EXTP      #PAG (xcp),#01H
13BE F7F80100 R    MOVB      POF (xcp+01H),RL4
                                           ; SOURCE LINE # 3281
13C2         positive_response:
                                           ; SOURCE LINE # 3282
13C2 DA000000 R    CALLS     SEG (XcpSendCrm),XcpSendCrm
                                           ; SOURCE LINE # 3284
                                           ; SOURCE LINE # 3286
                                           ; SOURCE LINE # 3292
13C6         no_response:
13C6 FCFF          POP       R15
13C8 FCFE          POP       R14
13CA FCFD          POP       R13
13CC DB00          RETS      
             ; FUNCTION XcpCommand (END    RMASK = @0x7FFF)

             ; FUNCTION XcpSendCallBack (BEGIN  RMASK = @0x3FFF)
                                           ; SOURCE LINE # 3309
                                           ; SOURCE LINE # 3320
13CE D7400000 R    EXTP      #PAG (xcp),#01H
13D2 F3F83E08 R    MOVB      RL4,POF (xcp+083EH)
13D6 67F88F00      ANDB      RL4,#08FH
13DA D7500000 R    EXTP      #PAG (xcp),#02H
13DE F7F83E08 R    MOVB      POF (xcp+083EH),RL4
                                           ; SOURCE LINE # 3325
13E2 F3F83E08 R    MOVB      RL4,POF (xcp+083EH)
13E6 9AF40E00      JNB       R4.0,?C0188
                                           ; SOURCE LINE # 3327
13EA D7400000 R    EXTP      #PAG (xcp),#01H
13EE F3F83E08 R    MOVB      RL4,POF (xcp+083EH)
13F2 67F8FE00      ANDB      RL4,#0FEH
13F6 D7400000 R    EXTP      #PAG (xcp),#01H
13FA F7F83E08 R    MOVB      POF (xcp+083EH),RL4
C166 COMPILER V7.57.0, XCPBASIC                                                            01/03/2020 16:20:10 PAGE 106 

                                           ; SOURCE LINE # 3328
13FE DA000000 R    CALLS     SEG (XcpSendCrm),XcpSendCrm
                                           ; SOURCE LINE # 3330
1402 E118          MOVB      RL4,#01H
1404 DB00          RETS      
                                           ; SOURCE LINE # 3331
1406         ?C0188:
                                           ; SOURCE LINE # 3335
1406 D7400000 R    EXTP      #PAG (xcp),#01H
140A F3F83E08 R    MOVB      RL4,POF (xcp+083EH)
140E 9AF40E20      JNB       R4.2,?C0190
                                           ; SOURCE LINE # 3337
1412 D7400000 R    EXTP      #PAG (xcp),#01H
1416 F3F83E08 R    MOVB      RL4,POF (xcp+083EH)
141A 67F8FB00      ANDB      RL4,#0FBH
141E D7400000 R    EXTP      #PAG (xcp),#01H
1422 F7F83E08 R    MOVB      POF (xcp+083EH),RL4
                                           ; SOURCE LINE # 3338
1426 DA000000 R    CALLS     SEG (XcpSendEv),XcpSendEv
                                           ; SOURCE LINE # 3340
142A E118          MOVB      RL4,#01H
142C DB00          RETS      
                                           ; SOURCE LINE # 3341
142E         ?C0190:
                                           ; SOURCE LINE # 3345
142E D7400000 R    EXTP      #PAG (xcp),#01H
1432 F2F41400 R    MOV       R4,POF (xcp+014H)
1436 9AF40660      JNB       R4.6,?C0191
                                           ; SOURCE LINE # 3347
143A DA000000 R    CALLS     SEG (XcpSendDtoFromQueue),XcpSendDtoFromQueue
143E 4980          CMPB      RL4,#00H
1440 2D02          JMPR      cc_Z,?C0191
                                           ; SOURCE LINE # 3350
1442 E118          MOVB      RL4,#01H
1444 DB00          RETS      
                                           ; SOURCE LINE # 3351
1446         ?C0191:
                                           ; SOURCE LINE # 3358
1446 E108          MOVB      RL4,#00H
                                           ; SOURCE LINE # 3360
1448         ?C0189:
1448 DB00          RETS      
             ; FUNCTION XcpSendCallBack (END    RMASK = @0x3FFF)

             ; FUNCTION XcpInit (BEGIN  RMASK = @0x7FFF)
                                           ; SOURCE LINE # 3378
                                           ; SOURCE LINE # 3385
144A DA000000 E    CALLS     SEG (XcpCanInit),XcpCanInit
                                           ; SOURCE LINE # 3388
144E E6FA4208      MOV       R10,#0842H
1452 E6F80000 R    MOV       R8,#POF (xcp)
1456 E6F90000 R    MOV       R9,#PAG (xcp)
145A DA000000 R    CALLS     SEG (XcpMemClr),XcpMemClr
                                           ; SOURCE LINE # 3391
145E E00A          MOV       R10,#00H
1460 E089          MOV       R9,#08H
1462 E088          MOV       R8,#08H
1464 DA000000 R    CALLS     SEG (XcpSetActiveTl),XcpSetActiveTl
                                           ; SOURCE LINE # 3396
1468 D7500000 R    EXTP      #PAG (xcp),#02H
146C F68E1400 R    MOV       POF (xcp+014H),ZEROS
                                           ; SOURCE LINE # 3400
C166 COMPILER V7.57.0, XCPBASIC                                                            01/03/2020 16:20:10 PAGE 107 

1470 F78E3E08 R    MOVB      POF (xcp+083EH),ZEROS
                                           ; SOURCE LINE # 3406
1474 DB00          RETS      
             ; FUNCTION XcpInit (END    RMASK = @0x7FFF)

             ; FUNCTION XcpExit (BEGIN  RMASK = @0x8000)
                                           ; SOURCE LINE # 3416
                                           ; SOURCE LINE # 3423
1476 DB00          RETS      
             ; FUNCTION XcpExit (END    RMASK = @0x8000)

             ; FUNCTION XcpSendEvent (BEGIN  RMASK = @0x7FFF)
                                           ; SOURCE LINE # 3558
1478 ECFD          PUSH      R13
147A ECFE          PUSH      R14
147C ECFF          PUSH      R15
147E F0DB          MOV       R13,R11
;---- Variable 'len' assigned to Register 'R13' ----
1480 F0E9          MOV       R14,R9
1482 F0FA          MOV       R15,R10
;---- Variable 'c' assigned to Register 'R14/R15' ----
1484 8880          MOV       [-R0],R8
                                           ; SOURCE LINE # 3559
                                           ; SOURCE LINE # 3567
1486 0D04          JMPR      cc_UC,?C0193
1488         ?C0195:
                                           ; SOURCE LINE # 3569
1488 DA000000 E    CALLS     SEG (ApplXcpSendStall),ApplXcpSendStall
148C 4980          CMPB      RL4,#00H
148E 2D40          JMPR      cc_Z,?C0198
                                           ; SOURCE LINE # 3571
                                           ; SOURCE LINE # 3572
1490         ?C0193:
1490 D7400000 R    EXTP      #PAG (xcp),#01H
1494 F3F83E08 R    MOVB      RL4,POF (xcp+083EH)
1498 8AF4F620      JB        R4.2,?C0195
149C         ?C0194:
                                           ; SOURCE LINE # 3576
149C E7F8FD00      MOVB      RL4,#0FDH
14A0 D7400000 R    EXTP      #PAG (xcp),#01H
14A4 F7F80A00 R    MOVB      POF (xcp+0AH),RL4
                                           ; SOURCE LINE # 3577
14A8 A980          MOVB      RL4,[R0]      ; evc
14AA D7400000 R    EXTP      #PAG (xcp),#01H
14AE F7F80B00 R    MOVB      POF (xcp+0BH),RL4
                                           ; SOURCE LINE # 3578
14B2 E128          MOVB      RL4,#02H
14B4 D7400000 R    EXTP      #PAG (xcp),#01H
14B8 F7F81200 R    MOVB      POF (xcp+012H),RL4
                                           ; SOURCE LINE # 3580
14BC F04D          MOV       R4,R13
14BE 4986          CMPB      RL4,#06H
14C0 ED25          JMPR      cc_UGT,?C0199
                                           ; SOURCE LINE # 3582
14C2 F04E          MOV       R4,R14
14C4 704F          OR        R4,R15
14C6 2D19          JMPR      cc_Z,?C0200
                                           ; SOURCE LINE # 3584
14C8         ?C0205:
14C8 E10E          MOVB      RL7,#00H
;---- Variable 'i' assigned to Register 'RL7' ----
14CA 0D13          JMPR      cc_UC,?C0203
C166 COMPILER V7.57.0, XCPBASIC                                                            01/03/2020 16:20:10 PAGE 108 

14CC         ?C0204:
                                           ; SOURCE LINE # 3586
14CC C0E6          MOVBZ     R6,RL7
14CE F04E          MOV       R4,R14
14D0 0046          ADD       R4,R6
14D2 DC4F          EXTP      R15,#01H
14D4 A9A4          MOVB      RL5,[R4]
14D6 D7600000 R    EXTP      #PAG (xcp),#03H
14DA C2F41200 R    MOVBZ     R4,POF (xcp+012H)
14DE E4A40A00 R    MOVB      [R4+#POF(xcp+0AH)],RL5
                                           ; SOURCE LINE # 3587
14E2 F3F81200 R    MOVB      RL4,POF (xcp+012H)
14E6 0981          ADDB      RL4,#01H
14E8 D7400000 R    EXTP      #PAG (xcp),#01H
14EC F7F81200 R    MOVB      POF (xcp+012H),RL4
                                           ; SOURCE LINE # 3588
14F0 09E1          ADDB      RL7,#01H
14F2         ?C0203:
14F2 F05D          MOV       R5,R13
14F4 41EA          CMPB      RL7,RL5
14F6 8DEA          JMPR      cc_ULT,?C0204
14F8         ?C0202:
                                           ; SOURCE LINE # 3589
14F8 0D09          JMPR      cc_UC,?C0199
14FA         ?C0200:
                                           ; SOURCE LINE # 3592
14FA D7400000 R    EXTP      #PAG (xcp),#01H
14FE F3F81200 R    MOVB      RL4,POF (xcp+012H)
1502 004D          ADD       R4,R13
1504 D7400000 R    EXTP      #PAG (xcp),#01H
1508 F7F81200 R    MOVB      POF (xcp+012H),RL4
                                           ; SOURCE LINE # 3593
                                           ; SOURCE LINE # 3594
150C         ?C0199:
                                           ; SOURCE LINE # 3608
150C DA000000 R    CALLS     SEG (XcpSendEv),XcpSendEv
                                           ; SOURCE LINE # 3610
1510         ?C0198:
1510 0802          ADD       R0,#02H
1512 FCFF          POP       R15
1514 FCFE          POP       R14
1516 FCFD          POP       R13
1518 DB00          RETS      
             ; FUNCTION XcpSendEvent (END    RMASK = @0x7FFF)



MODULE INFORMATION:   INITIALIZED  UNINITIALIZED
  CODE SIZE        =        5402     --------
  NEAR-CONST SIZE  =           3     --------
  FAR-CONST SIZE   =    --------     --------
  HUGE-CONST SIZE  =    --------     --------
  XHUGE-CONST SIZE =    --------     --------
  NEAR-DATA SIZE   =    --------     --------
  FAR-DATA SIZE    =        2114     --------
  XHUGE-DATA SIZE  =    --------     --------
  IDATA-DATA SIZE  =    --------     --------
  SDATA-DATA SIZE  =    --------     --------
  BDATA-DATA SIZE  =    --------     --------
  HUGE-DATA SIZE   =    --------     --------
  BIT SIZE         =    --------     --------
  INIT'L SIZE      =    --------     --------
C166 COMPILER V7.57.0, XCPBASIC                                                            01/03/2020 16:20:10 PAGE 109 

END OF MODULE INFORMATION.


C166 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
