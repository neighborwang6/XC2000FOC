////////////////////////////////////////////////////////////////////////////////
/*******************************************************************************
* 
*
*  
*      
*******************************************************************************/
////////////////////////////////////////////////////////////////////////////////

#include "string.h"
#include "mcu1_imp.h"
#include "mcu2_imp.h"
#include "diag_hw.h"
#include "dtc_man.h"
#include "task_man.h"

#include "hican.h"
#include "ypara.h"

#include "adc.h"

////////////////////////////////////////////////////////////////////////////////
// Quick test only
void system_quick_diag(void);
u16 g_sys_dtc_uw=0;

////////////////////////////////////////////////////////////////////////////////

extern void timer_hook_50ms(void);
////////////////////////////////////////////////////////////////////////////////
// Legacy variables from old project: FIXME: yly
extern u16 routine_id;
extern u8 gee_stat;
extern u8 sys_state;

extern u16 on_toutx;
extern u8 task_ctrl_valid;
extern u8 task_stat;
extern u16 diag_timeout;

#define SYS_INIT 0x00   // FIXME : defined in abs_ctrl.h already

////////////////////////////////////////////////////////////////////////////////
// MCU1 message buffer (Tx)
MCUMSG1 mcumsg1;
// MCU2 message buffer (Rx)
MCUMSG2 mcumsg2;
// Dat message buffer
MCUMSGDAT mcumsgdat;

u8 mcu2_status=0x01;

////////////////////////////////////////////////////////////////////////////////
//
void mcu1_imp_init(void)
{
}

////////////////////////////////////////////////////////////////////////////////
// Generate new transmitt message
void do_mcu1(void)
{
}

////////////////////////////////////////////////////////////////////////////////
// Deal with received message
void do_mcu2_msg(void)
{

}

////////////////////////////////////////////////////////////////////////////////
//
void diag_timer_10ms_hook(void)
{
	static u8 tmx=0;

   if(++tmx>=5)
   {
      diag_timer_50ms_hook();
	  tmx=0;
   }

   hican_10ms_hook();
   system_quick_diag();
}
////////////////////////////////////////////////////////////////////////////////
//
void diag_timer_50ms_hook(void)
{
	///////////////////////////////////////////////////////
	// Update MCU1/MCU2 Status
    do_mcu1();
    do_mcu2();
	///////////////////////////////////////////////////////
	timer_hook_50ms();
}

////////////////////////////////////////////////////////////////////////////////
//
void system_quick_diag(void)
{
#if 1
	u16 tmpu16;

	// Monitor the following ...
	
	////////////////////////////////////////////////////////
	// BAT12V_MONX
	tmpu16=get_ad_value(AD_BAT12V_MON)*4; // *(1000+330)/330;
	if(tmpu16>F_VOLT(18) || tmpu16<F_VOLT(9))
		g_sys_dtc_uw|=0x0002;
	else
		g_sys_dtc_uw&=~((u16)0x0002);
	
	////////////////////////////////////////////////////////
	// BAT12V_MONYX
	tmpu16=get_ad_value(AD_BAT12V_MONY)*4; // *(1000+330)/330;
	if(tmpu16>F_VOLT(18) || tmpu16<F_VOLT(9))
		g_sys_dtc_uw|=0x0002;
	else
		g_sys_dtc_uw&=~((u16)0x0002);
	
	////////////////////////////////////////////////////////
	// VCC5_SW_MONX (VCC5_SS: Hella TAS)
	tmpu16=get_ad_value(AD_VCC5_SW_MON)*3/2; // *(10+5.1)/10;
	if(tmpu16>F_VOLT(5.5) || tmpu16<F_VOLT(4.5))
		g_sys_dtc_uw|=0x0004;
	else
		g_sys_dtc_uw&=~((u16)0x0004);

	////////////////////////////////////////////////////////
	// ERR1/ERR2
	if(GET_TLE_ERR1()==0 || GET_TLE_ERR2()==0)
	{
		SET_TLE_ENA(0);
		g_sys_dtc_uw|=0x0008;
	}
	else
	{
		SET_TLE_ENA(1);
	}
	////////////////////////////////////////////////////////
	// VO1X
	
	////////////////////////////////////////////////////////
	// VO2X
	
	////////////////////////////////////////////////////////
	// VROX
	
	////////////////////////////////////////////////////////
	// SCDLX
	
	////////////////////////////////////////////////////////
	// SH1_MON
	
	////////////////////////////////////////////////////////
	// SH2_MON
	
	////////////////////////////////////////////////////////
	// SH3_MON
	
	////////////////////////////////////////////////////////
	// TEMP_SS1X
	
	////////////////////////////////////////////////////////
	// VCC5B_MONX
	
	////////////////////////////////////////////////////////
	// DIS_UVW_X
	
	////////////////////////////////////////////////////////
	// AD2S_DOS
	
	////////////////////////////////////////////////////////
	// AD2S_LOT
	
	////////////////////////////////////////////////////////
#endif
}

////////////////////////////////////////////////////////////////////////////////
//
////////////////////////////////////////////////////////////////////////////////
void system_dtc_handling(void)
{
	if(!g_sys_dtc_uw)
		return;
}
////////////////////////////////////////////////////////////////////////////////
